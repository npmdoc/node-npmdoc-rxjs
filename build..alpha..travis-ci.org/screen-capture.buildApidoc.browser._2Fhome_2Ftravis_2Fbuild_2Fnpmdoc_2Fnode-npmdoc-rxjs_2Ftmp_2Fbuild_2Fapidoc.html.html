<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/ReactiveX/RxJS">rxjs (v5.2.0)</a>
</h1>
<h4>Reactive Extensions for modern JavaScript</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs">module rxjs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AjaxError">
            function <span class="apidocSignatureSpan">rxjs.</span>AjaxError
            <span class="apidocSignatureSpan">(message, xhr, request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AjaxResponse">
            function <span class="apidocSignatureSpan">rxjs.</span>AjaxResponse
            <span class="apidocSignatureSpan">(originalEvent, xhr, request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AjaxTimeoutError">
            function <span class="apidocSignatureSpan">rxjs.</span>AjaxTimeoutError
            <span class="apidocSignatureSpan">(xhr, request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AnonymousSubject">
            function <span class="apidocSignatureSpan">rxjs.</span>AnonymousSubject
            <span class="apidocSignatureSpan">(destination, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ArgumentOutOfRangeError">
            function <span class="apidocSignatureSpan">rxjs.</span>ArgumentOutOfRangeError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AsyncSubject">
            function <span class="apidocSignatureSpan">rxjs.</span>AsyncSubject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.BehaviorSubject">
            function <span class="apidocSignatureSpan">rxjs.</span>BehaviorSubject
            <span class="apidocSignatureSpan">(_value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>ConnectableObservable
            <span class="apidocSignatureSpan">(source, subjectFactory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.ajax">
            function <span class="apidocSignatureSpan">rxjs.</span>ConnectableObservable.ajax
            <span class="apidocSignatureSpan">(urlOrRequest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.EmptyError">
            function <span class="apidocSignatureSpan">rxjs.</span>EmptyError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Notification">
            function <span class="apidocSignatureSpan">rxjs.</span>Notification
            <span class="apidocSignatureSpan">(kind, value, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ObjectUnsubscribedError">
            function <span class="apidocSignatureSpan">rxjs.</span>ObjectUnsubscribedError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable">
            function <span class="apidocSignatureSpan">rxjs.</span>Observable
            <span class="apidocSignatureSpan">(subscribe)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ReplaySubject">
            function <span class="apidocSignatureSpan">rxjs.</span>ReplaySubject
            <span class="apidocSignatureSpan">(bufferSize, windowTime, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subject">
            function <span class="apidocSignatureSpan">rxjs.</span>Subject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscriber">
            function <span class="apidocSignatureSpan">rxjs.</span>Subscriber
            <span class="apidocSignatureSpan">(destinationOrNext, error, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscription">
            function <span class="apidocSignatureSpan">rxjs.</span>Subscription
            <span class="apidocSignatureSpan">(unsubscribe)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler">
            function <span class="apidocSignatureSpan">rxjs.</span>TestScheduler
            <span class="apidocSignatureSpan">(assertDeepEqual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TimeInterval">
            function <span class="apidocSignatureSpan">rxjs.</span>TimeInterval
            <span class="apidocSignatureSpan">(value, interval)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TimeoutError">
            function <span class="apidocSignatureSpan">rxjs.</span>TimeoutError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Timestamp">
            function <span class="apidocSignatureSpan">rxjs.</span>Timestamp
            <span class="apidocSignatureSpan">(value, timestamp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.UnsubscriptionError">
            function <span class="apidocSignatureSpan">rxjs.</span>UnsubscriptionError
            <span class="apidocSignatureSpan">(errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.VirtualTimeScheduler">
            function <span class="apidocSignatureSpan">rxjs.</span>VirtualTimeScheduler
            <span class="apidocSignatureSpan">(SchedulerAction, maxFrames)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>Action</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>AjaxError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>AjaxTimeoutError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>AnimationFrame</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>AnimationFrameAction</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>AnimationFrameScheduler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>AnonymousSubject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>ArgumentOutOfRangeError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>ArrayLikeObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>ArrayObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>AsapAction</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>AsapScheduler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>AsyncAction</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>AsyncScheduler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>AsyncSubject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>BehaviorSubject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>BoundCallbackObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>BoundNodeCallbackObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>ColdObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>ConnectableObservable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>DeferObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>EmptyError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>EmptyObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>ErrorObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>FastMap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>ForkJoinObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>FromEventObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>FromEventPatternObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>FromObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>GenerateObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>HotObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>IfObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>Immediate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>InnerSubscriber</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>IntervalObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>IteratorObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>Map</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>MapPolyfill</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>NeverObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>Notification.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>ObjectUnsubscribedError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>Observable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>OuterSubscriber</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>PairsObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>PromiseObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>QueueAction</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>QueueScheduler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>RangeObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>ReplaySubject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>ScalarObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>Scheduler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>Set</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>Subject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>SubjectSubscription</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>SubscribeOnObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>Subscriber.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>Subscription.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>SubscriptionLog</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>SubscriptionLoggable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>Symbol</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>TestScheduler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>TimeoutError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>TimerObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>UnsubscriptionError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>UsingObservable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>VirtualTimeScheduler.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>applyMixins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>assign</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>audit</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>auditTime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>bindCallback</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>bindNodeCallback</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>bufferCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>bufferTime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>bufferToggle</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>bufferWhen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>catch</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>combineAll</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>combineLatest</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>concat</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>concatAll</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>concatMap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>concatMapTo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>count</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>debounce</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>debounceTime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>defaultIfEmpty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>defer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>delay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>delayWhen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>dematerialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>distinct</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>distinctUntilChanged</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>distinctUntilKeyChanged</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>do</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>elementAt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>empty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>every</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>exhaust</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>exhaustMap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>expand</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>filter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>finally</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>find</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>findIndex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>first</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>forkJoin</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>from</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>fromEvent</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>fromEventPattern</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>fromPromise</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>groupBy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>if</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>ignoreElements</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>interval</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>isArray</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>isArrayLike</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>isDate</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>isEmpty</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>isFunction</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>isNumeric</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>isObject</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>isPromise</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>isScheduler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>iterator</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>last</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>let</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>map</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>mapTo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>materialize</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>max</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>merge</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>mergeAll</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>mergeMap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>mergeMapTo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>mergeScan</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>multicast</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>never</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>noop</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>not</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>observeOn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>of</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>onErrorResumeNext</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>pairs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>pairwise</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>partition</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>pluck</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>publish</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>publishBehavior</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>publishLast</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>publishReplay</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>race</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>range</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>reduce</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>repeat</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>repeatWhen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>retry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>retryWhen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>sample</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>sampleTime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>scan</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>sequenceEqual</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>share</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>single</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>skip</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>skipUntil</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>skipWhile</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>startWith</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>subscribeOn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>subscribeToResult</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>switch</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>switchMap</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>switchMapTo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>take</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>takeLast</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>takeUntil</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>takeWhile</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>throttle</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>throttleTime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>throw</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>timeInterval</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>timeout</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>timeoutWith</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>timer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>timestamp</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>toArray</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>toPromise</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>toSubscriber</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>tryCatch</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>using</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>window</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>windowCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>windowTime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>windowToggle</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>windowWhen</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>withLatestFrom</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>zip</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>zipAll</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Action">module rxjs.Action</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Action.Action">
            function <span class="apidocSignatureSpan">rxjs.</span>Action
            <span class="apidocSignatureSpan">(scheduler, work)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AjaxError">module rxjs.AjaxError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AjaxError.AjaxError">
            function <span class="apidocSignatureSpan">rxjs.</span>AjaxError
            <span class="apidocSignatureSpan">(message, xhr, request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AjaxError.captureStackTrace">
            function <span class="apidocSignatureSpan">rxjs.AjaxError.</span>captureStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rxjs.AjaxError.</span>stackTraceLimit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AjaxError.prototype">module rxjs.AjaxError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AjaxError.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.AjaxError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(message, xhr, request)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AjaxTimeoutError">module rxjs.AjaxTimeoutError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AjaxTimeoutError.AjaxTimeoutError">
            function <span class="apidocSignatureSpan">rxjs.</span>AjaxTimeoutError
            <span class="apidocSignatureSpan">(xhr, request)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AjaxTimeoutError.captureStackTrace">
            function <span class="apidocSignatureSpan">rxjs.AjaxTimeoutError.</span>captureStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rxjs.AjaxTimeoutError.</span>stackTraceLimit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AjaxTimeoutError.prototype">module rxjs.AjaxTimeoutError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AjaxTimeoutError.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.AjaxTimeoutError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(xhr, request)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AnimationFrame">module rxjs.AnimationFrame</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AnimationFrame.RequestAnimationFrameDefinition">
            function <span class="apidocSignatureSpan">rxjs.AnimationFrame.</span>RequestAnimationFrameDefinition
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>AnimationFrame</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AnimationFrameAction">module rxjs.AnimationFrameAction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AnimationFrameAction.AnimationFrameAction">
            function <span class="apidocSignatureSpan">rxjs.</span>AnimationFrameAction
            <span class="apidocSignatureSpan">(scheduler, work)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AnimationFrameScheduler">module rxjs.AnimationFrameScheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AnimationFrameScheduler.AnimationFrameScheduler">
            function <span class="apidocSignatureSpan">rxjs.</span>AnimationFrameScheduler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AnonymousSubject">module rxjs.AnonymousSubject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AnonymousSubject.AnonymousSubject">
            function <span class="apidocSignatureSpan">rxjs.</span>AnonymousSubject
            <span class="apidocSignatureSpan">(destination, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AnonymousSubject.create">
            function <span class="apidocSignatureSpan">rxjs.AnonymousSubject.</span>create
            <span class="apidocSignatureSpan">(destination, source)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AnonymousSubject.prototype">module rxjs.AnonymousSubject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AnonymousSubject.prototype._subscribe">
            function <span class="apidocSignatureSpan">rxjs.AnonymousSubject.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(subscriber)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AnonymousSubject.prototype.complete">
            function <span class="apidocSignatureSpan">rxjs.AnonymousSubject.prototype.</span>complete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AnonymousSubject.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.AnonymousSubject.prototype.</span>constructor
            <span class="apidocSignatureSpan">(destination, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AnonymousSubject.prototype.error">
            function <span class="apidocSignatureSpan">rxjs.AnonymousSubject.prototype.</span>error
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AnonymousSubject.prototype.next">
            function <span class="apidocSignatureSpan">rxjs.AnonymousSubject.prototype.</span>next
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ArgumentOutOfRangeError">module rxjs.ArgumentOutOfRangeError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ArgumentOutOfRangeError.ArgumentOutOfRangeError">
            function <span class="apidocSignatureSpan">rxjs.</span>ArgumentOutOfRangeError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ArgumentOutOfRangeError.captureStackTrace">
            function <span class="apidocSignatureSpan">rxjs.ArgumentOutOfRangeError.</span>captureStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rxjs.ArgumentOutOfRangeError.</span>stackTraceLimit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ArgumentOutOfRangeError.prototype">module rxjs.ArgumentOutOfRangeError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ArgumentOutOfRangeError.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.ArgumentOutOfRangeError.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ArrayLikeObservable">module rxjs.ArrayLikeObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ArrayLikeObservable.ArrayLikeObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>ArrayLikeObservable
            <span class="apidocSignatureSpan">(arrayLike, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ArrayObservable">module rxjs.ArrayObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ArrayObservable.ArrayObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>ArrayObservable
            <span class="apidocSignatureSpan">(array, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AsapAction">module rxjs.AsapAction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AsapAction.AsapAction">
            function <span class="apidocSignatureSpan">rxjs.</span>AsapAction
            <span class="apidocSignatureSpan">(scheduler, work)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AsapScheduler">module rxjs.AsapScheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AsapScheduler.AsapScheduler">
            function <span class="apidocSignatureSpan">rxjs.</span>AsapScheduler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AsyncAction">module rxjs.AsyncAction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AsyncAction.AsyncAction">
            function <span class="apidocSignatureSpan">rxjs.</span>AsyncAction
            <span class="apidocSignatureSpan">(scheduler, work)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AsyncScheduler">module rxjs.AsyncScheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AsyncScheduler.AsyncScheduler">
            function <span class="apidocSignatureSpan">rxjs.</span>AsyncScheduler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AsyncSubject">module rxjs.AsyncSubject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AsyncSubject.AsyncSubject">
            function <span class="apidocSignatureSpan">rxjs.</span>AsyncSubject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AsyncSubject.create">
            function <span class="apidocSignatureSpan">rxjs.AsyncSubject.</span>create
            <span class="apidocSignatureSpan">(destination, source)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.AsyncSubject.prototype">module rxjs.AsyncSubject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AsyncSubject.prototype._subscribe">
            function <span class="apidocSignatureSpan">rxjs.AsyncSubject.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(subscriber)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AsyncSubject.prototype.complete">
            function <span class="apidocSignatureSpan">rxjs.AsyncSubject.prototype.</span>complete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AsyncSubject.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.AsyncSubject.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AsyncSubject.prototype.error">
            function <span class="apidocSignatureSpan">rxjs.AsyncSubject.prototype.</span>error
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.AsyncSubject.prototype.next">
            function <span class="apidocSignatureSpan">rxjs.AsyncSubject.prototype.</span>next
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.BehaviorSubject">module rxjs.BehaviorSubject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.BehaviorSubject.BehaviorSubject">
            function <span class="apidocSignatureSpan">rxjs.</span>BehaviorSubject
            <span class="apidocSignatureSpan">(_value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.BehaviorSubject.create">
            function <span class="apidocSignatureSpan">rxjs.BehaviorSubject.</span>create
            <span class="apidocSignatureSpan">(destination, source)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.BehaviorSubject.prototype">module rxjs.BehaviorSubject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.BehaviorSubject.prototype._subscribe">
            function <span class="apidocSignatureSpan">rxjs.BehaviorSubject.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(subscriber)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.BehaviorSubject.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.BehaviorSubject.prototype.</span>constructor
            <span class="apidocSignatureSpan">(_value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.BehaviorSubject.prototype.getValue">
            function <span class="apidocSignatureSpan">rxjs.BehaviorSubject.prototype.</span>getValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.BehaviorSubject.prototype.next">
            function <span class="apidocSignatureSpan">rxjs.BehaviorSubject.prototype.</span>next
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.BoundCallbackObservable">module rxjs.BoundCallbackObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.BoundCallbackObservable.BoundCallbackObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>BoundCallbackObservable
            <span class="apidocSignatureSpan">(callbackFunc, selector, args, context, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.BoundNodeCallbackObservable">module rxjs.BoundNodeCallbackObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.BoundNodeCallbackObservable.BoundNodeCallbackObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>BoundNodeCallbackObservable
            <span class="apidocSignatureSpan">(callbackFunc, selector, args, context, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ColdObservable">module rxjs.ColdObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ColdObservable.ColdObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>ColdObservable
            <span class="apidocSignatureSpan">(messages, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ConnectableObservable">module rxjs.ConnectableObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.ConnectableObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>ConnectableObservable
            <span class="apidocSignatureSpan">(source, subjectFactory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.ajax">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>ajax
            <span class="apidocSignatureSpan">(urlOrRequest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.bindCallback">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>bindCallback
            <span class="apidocSignatureSpan">(func, selector, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.bindNodeCallback">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>bindNodeCallback
            <span class="apidocSignatureSpan">(func, selector, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.combineLatest">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>combineLatest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.concat">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.create">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>create
            <span class="apidocSignatureSpan">(subscribe)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.defer">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>defer
            <span class="apidocSignatureSpan">(observableFactory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.empty">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>empty
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.forkJoin">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>forkJoin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.from">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>from
            <span class="apidocSignatureSpan">(ish, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.fromEvent">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>fromEvent
            <span class="apidocSignatureSpan">(target, eventName, options, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.fromEventPattern">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>fromEventPattern
            <span class="apidocSignatureSpan">(addHandler, removeHandler, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.fromPromise">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>fromPromise
            <span class="apidocSignatureSpan">(promise, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.generate">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>generate
            <span class="apidocSignatureSpan">(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.if">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>if
            <span class="apidocSignatureSpan">(condition, thenSource, elseSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.interval">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>interval
            <span class="apidocSignatureSpan">(period, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.merge">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.never">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>never
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.of">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.onErrorResumeNext">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>onErrorResumeNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.pairs">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>pairs
            <span class="apidocSignatureSpan">(obj, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.race">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>race
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.range">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>range
            <span class="apidocSignatureSpan">(start, count, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.throw">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>throw
            <span class="apidocSignatureSpan">(error, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.timer">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>timer
            <span class="apidocSignatureSpan">(initialDelay, period, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.using">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>using
            <span class="apidocSignatureSpan">(resourceFactory, observableFactory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.webSocket">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>webSocket
            <span class="apidocSignatureSpan">(urlConfigOrSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.zip">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>zip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ConnectableObservable.ajax">module rxjs.ConnectableObservable.ajax</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.ajax.ajax">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>ajax
            <span class="apidocSignatureSpan">(urlOrRequest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.ajax.delete">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.ajax.</span>delete
            <span class="apidocSignatureSpan">(url, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.ajax.get">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.ajax.</span>get
            <span class="apidocSignatureSpan">(url, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.ajax.getJSON">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.ajax.</span>getJSON
            <span class="apidocSignatureSpan">(url, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.ajax.patch">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.ajax.</span>patch
            <span class="apidocSignatureSpan">(url, body, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.ajax.post">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.ajax.</span>post
            <span class="apidocSignatureSpan">(url, body, headers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.ajax.put">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.ajax.</span>put
            <span class="apidocSignatureSpan">(url, body, headers)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ConnectableObservable.prototype">module rxjs.ConnectableObservable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.prototype._subscribe">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(subscriber)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.prototype.connect">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.prototype.</span>constructor
            <span class="apidocSignatureSpan">(source, subjectFactory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.prototype.getSubject">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.prototype.</span>getSubject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ConnectableObservable.prototype.refCount">
            function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.prototype.</span>refCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.DeferObservable">module rxjs.DeferObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.DeferObservable.DeferObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>DeferObservable
            <span class="apidocSignatureSpan">(observableFactory)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.EmptyError">module rxjs.EmptyError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.EmptyError.EmptyError">
            function <span class="apidocSignatureSpan">rxjs.</span>EmptyError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.EmptyError.captureStackTrace">
            function <span class="apidocSignatureSpan">rxjs.EmptyError.</span>captureStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rxjs.EmptyError.</span>stackTraceLimit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.EmptyError.prototype">module rxjs.EmptyError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.EmptyError.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.EmptyError.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.EmptyObservable">module rxjs.EmptyObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.EmptyObservable.EmptyObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>EmptyObservable
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ErrorObservable">module rxjs.ErrorObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ErrorObservable.ErrorObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>ErrorObservable
            <span class="apidocSignatureSpan">(error, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.FastMap">module rxjs.FastMap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.FastMap.FastMap">
            function <span class="apidocSignatureSpan">rxjs.</span>FastMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ForkJoinObservable">module rxjs.ForkJoinObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ForkJoinObservable.ForkJoinObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>ForkJoinObservable
            <span class="apidocSignatureSpan">(sources, resultSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.FromEventObservable">module rxjs.FromEventObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.FromEventObservable.FromEventObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>FromEventObservable
            <span class="apidocSignatureSpan">(sourceObj, eventName, selector, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.FromEventPatternObservable">module rxjs.FromEventPatternObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.FromEventPatternObservable.FromEventPatternObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>FromEventPatternObservable
            <span class="apidocSignatureSpan">(addHandler, removeHandler, selector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.FromObservable">module rxjs.FromObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.FromObservable.FromObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>FromObservable
            <span class="apidocSignatureSpan">(ish, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.GenerateObservable">module rxjs.GenerateObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.GenerateObservable.GenerateObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>GenerateObservable
            <span class="apidocSignatureSpan">(initialState, condition, iterate, resultSelector, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.HotObservable">module rxjs.HotObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.HotObservable.HotObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>HotObservable
            <span class="apidocSignatureSpan">(messages, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.IfObservable">module rxjs.IfObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.IfObservable.IfObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>IfObservable
            <span class="apidocSignatureSpan">(condition, thenSource, elseSource)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Immediate">module rxjs.Immediate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Immediate.ImmediateDefinition">
            function <span class="apidocSignatureSpan">rxjs.Immediate.</span>ImmediateDefinition
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.</span>Immediate</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.InnerSubscriber">module rxjs.InnerSubscriber</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.InnerSubscriber.InnerSubscriber">
            function <span class="apidocSignatureSpan">rxjs.</span>InnerSubscriber
            <span class="apidocSignatureSpan">(parent, outerValue, outerIndex)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.IntervalObservable">module rxjs.IntervalObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.IntervalObservable.IntervalObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>IntervalObservable
            <span class="apidocSignatureSpan">(period, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.IteratorObservable">module rxjs.IteratorObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.IteratorObservable.IteratorObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>IteratorObservable
            <span class="apidocSignatureSpan">(iterator, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Map">module rxjs.Map</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Map.Map">
            function <span class="apidocSignatureSpan">rxjs.</span>Map
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.MapPolyfill">module rxjs.MapPolyfill</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.MapPolyfill.MapPolyfill">
            function <span class="apidocSignatureSpan">rxjs.</span>MapPolyfill
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.NeverObservable">module rxjs.NeverObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.NeverObservable.NeverObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>NeverObservable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Notification">module rxjs.Notification</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Notification.Notification">
            function <span class="apidocSignatureSpan">rxjs.</span>Notification
            <span class="apidocSignatureSpan">(kind, value, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Notification.createComplete">
            function <span class="apidocSignatureSpan">rxjs.Notification.</span>createComplete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Notification.createError">
            function <span class="apidocSignatureSpan">rxjs.Notification.</span>createError
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Notification.createNext">
            function <span class="apidocSignatureSpan">rxjs.Notification.</span>createNext
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.Notification.</span>completeNotification</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.Notification.</span>undefinedValueNotification</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Notification.prototype">module rxjs.Notification.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Notification.prototype.accept">
            function <span class="apidocSignatureSpan">rxjs.Notification.prototype.</span>accept
            <span class="apidocSignatureSpan">(nextOrObserver, error, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Notification.prototype.do">
            function <span class="apidocSignatureSpan">rxjs.Notification.prototype.</span>do
            <span class="apidocSignatureSpan">(next, error, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Notification.prototype.observe">
            function <span class="apidocSignatureSpan">rxjs.Notification.prototype.</span>observe
            <span class="apidocSignatureSpan">(observer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Notification.prototype.toObservable">
            function <span class="apidocSignatureSpan">rxjs.Notification.prototype.</span>toObservable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ObjectUnsubscribedError">module rxjs.ObjectUnsubscribedError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ObjectUnsubscribedError.ObjectUnsubscribedError">
            function <span class="apidocSignatureSpan">rxjs.</span>ObjectUnsubscribedError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ObjectUnsubscribedError.captureStackTrace">
            function <span class="apidocSignatureSpan">rxjs.ObjectUnsubscribedError.</span>captureStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rxjs.ObjectUnsubscribedError.</span>stackTraceLimit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ObjectUnsubscribedError.prototype">module rxjs.ObjectUnsubscribedError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ObjectUnsubscribedError.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.ObjectUnsubscribedError.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Observable">module rxjs.Observable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.Observable">
            function <span class="apidocSignatureSpan">rxjs.</span>Observable
            <span class="apidocSignatureSpan">(subscribe)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.ajax">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>ajax
            <span class="apidocSignatureSpan">(urlOrRequest)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.bindCallback">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>bindCallback
            <span class="apidocSignatureSpan">(func, selector, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.bindNodeCallback">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>bindNodeCallback
            <span class="apidocSignatureSpan">(func, selector, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.combineLatest">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>combineLatest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.concat">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.create">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>create
            <span class="apidocSignatureSpan">(subscribe)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.defer">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>defer
            <span class="apidocSignatureSpan">(observableFactory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.empty">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>empty
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.forkJoin">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>forkJoin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.from">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>from
            <span class="apidocSignatureSpan">(ish, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.fromEvent">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>fromEvent
            <span class="apidocSignatureSpan">(target, eventName, options, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.fromEventPattern">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>fromEventPattern
            <span class="apidocSignatureSpan">(addHandler, removeHandler, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.fromPromise">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>fromPromise
            <span class="apidocSignatureSpan">(promise, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.generate">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>generate
            <span class="apidocSignatureSpan">(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.if">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>if
            <span class="apidocSignatureSpan">(condition, thenSource, elseSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.interval">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>interval
            <span class="apidocSignatureSpan">(period, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.merge">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.never">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>never
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.of">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.onErrorResumeNext">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>onErrorResumeNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.pairs">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>pairs
            <span class="apidocSignatureSpan">(obj, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.race">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>race
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.range">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>range
            <span class="apidocSignatureSpan">(start, count, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.throw">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>throw
            <span class="apidocSignatureSpan">(error, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.timer">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>timer
            <span class="apidocSignatureSpan">(initialDelay, period, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.using">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>using
            <span class="apidocSignatureSpan">(resourceFactory, observableFactory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.webSocket">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>webSocket
            <span class="apidocSignatureSpan">(urlConfigOrSource)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.zip">
            function <span class="apidocSignatureSpan">rxjs.Observable.</span>zip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Observable.prototype">module rxjs.Observable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype._catch">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>_catch
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype._do">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>_do
            <span class="apidocSignatureSpan">(nextOrObserver, error, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype._finally">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>_finally
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype._subscribe">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(subscriber)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype._switch">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>_switch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype._trySubscribe">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>_trySubscribe
            <span class="apidocSignatureSpan">(sink)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.audit">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>audit
            <span class="apidocSignatureSpan">(durationSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.auditTime">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>auditTime
            <span class="apidocSignatureSpan">(duration, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.buffer">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>buffer
            <span class="apidocSignatureSpan">(closingNotifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.bufferCount">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>bufferCount
            <span class="apidocSignatureSpan">(bufferSize, startBufferEvery)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.bufferTime">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>bufferTime
            <span class="apidocSignatureSpan">(bufferTimeSpan)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.bufferToggle">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>bufferToggle
            <span class="apidocSignatureSpan">(openings, closingSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.bufferWhen">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>bufferWhen
            <span class="apidocSignatureSpan">(closingSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.catch">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>catch
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.combineAll">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>combineAll
            <span class="apidocSignatureSpan">(project)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.combineLatest">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>combineLatest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.concat">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.concatAll">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>concatAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.concatMap">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>concatMap
            <span class="apidocSignatureSpan">(project, resultSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.concatMapTo">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>concatMapTo
            <span class="apidocSignatureSpan">(innerObservable, resultSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.count">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>count
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.debounce">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>debounce
            <span class="apidocSignatureSpan">(durationSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.debounceTime">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>debounceTime
            <span class="apidocSignatureSpan">(dueTime, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.defaultIfEmpty">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>defaultIfEmpty
            <span class="apidocSignatureSpan">(defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.delay">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>delay
            <span class="apidocSignatureSpan">(delay, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.delayWhen">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>delayWhen
            <span class="apidocSignatureSpan">(delayDurationSelector, subscriptionDelay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.dematerialize">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>dematerialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.distinct">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>distinct
            <span class="apidocSignatureSpan">(keySelector, flushes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.distinctUntilChanged">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>distinctUntilChanged
            <span class="apidocSignatureSpan">(compare, keySelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.distinctUntilKeyChanged">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>distinctUntilKeyChanged
            <span class="apidocSignatureSpan">(key, compare)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.do">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>do
            <span class="apidocSignatureSpan">(nextOrObserver, error, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.elementAt">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>elementAt
            <span class="apidocSignatureSpan">(index, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.every">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>every
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.exhaust">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>exhaust
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.exhaustMap">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>exhaustMap
            <span class="apidocSignatureSpan">(project, resultSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.expand">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>expand
            <span class="apidocSignatureSpan">(project, concurrent, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.filter">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>filter
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.finally">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>finally
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.find">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>find
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.findIndex">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>findIndex
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.first">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>first
            <span class="apidocSignatureSpan">(predicate, resultSelector, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.flatMap">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>flatMap
            <span class="apidocSignatureSpan">(project, resultSelector, concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.flatMapTo">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>flatMapTo
            <span class="apidocSignatureSpan">(innerObservable, resultSelector, concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.forEach">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>forEach
            <span class="apidocSignatureSpan">(next, PromiseCtor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.groupBy">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>groupBy
            <span class="apidocSignatureSpan">(keySelector, elementSelector, durationSelector, subjectSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.ignoreElements">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>ignoreElements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.isEmpty">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.last">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>last
            <span class="apidocSignatureSpan">(predicate, resultSelector, defaultValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.let">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>let
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.letBind">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>letBind
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.lift">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>lift
            <span class="apidocSignatureSpan">(operator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.map">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>map
            <span class="apidocSignatureSpan">(project, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.mapTo">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>mapTo
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.materialize">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>materialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.max">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>max
            <span class="apidocSignatureSpan">(comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.merge">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.mergeAll">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>mergeAll
            <span class="apidocSignatureSpan">(concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.mergeMap">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>mergeMap
            <span class="apidocSignatureSpan">(project, resultSelector, concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.mergeMapTo">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>mergeMapTo
            <span class="apidocSignatureSpan">(innerObservable, resultSelector, concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.mergeScan">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>mergeScan
            <span class="apidocSignatureSpan">(accumulator, seed, concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.min">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>min
            <span class="apidocSignatureSpan">(comparer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.multicast">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>multicast
            <span class="apidocSignatureSpan">(subjectOrSubjectFactory, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.observeOn">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>observeOn
            <span class="apidocSignatureSpan">(scheduler, delay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.onErrorResumeNext">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>onErrorResumeNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.pairwise">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>pairwise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.partition">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>partition
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.pluck">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>pluck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.publish">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>publish
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.publishBehavior">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>publishBehavior
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.publishLast">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>publishLast
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.publishReplay">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>publishReplay
            <span class="apidocSignatureSpan">(bufferSize, windowTime, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.race">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>race
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.reduce">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>reduce
            <span class="apidocSignatureSpan">(accumulator, seed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.repeat">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>repeat
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.repeatWhen">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>repeatWhen
            <span class="apidocSignatureSpan">(notifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.retry">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>retry
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.retryWhen">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>retryWhen
            <span class="apidocSignatureSpan">(notifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.sample">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>sample
            <span class="apidocSignatureSpan">(notifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.sampleTime">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>sampleTime
            <span class="apidocSignatureSpan">(period, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.scan">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>scan
            <span class="apidocSignatureSpan">(accumulator, seed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.sequenceEqual">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>sequenceEqual
            <span class="apidocSignatureSpan">(compareTo, comparor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.share">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>share
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.single">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>single
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.skip">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>skip
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.skipUntil">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>skipUntil
            <span class="apidocSignatureSpan">(notifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.skipWhile">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>skipWhile
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.startWith">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>startWith
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.subscribe">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>subscribe
            <span class="apidocSignatureSpan">(observerOrNext, error, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.subscribeOn">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>subscribeOn
            <span class="apidocSignatureSpan">(scheduler, delay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.switch">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>switch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.switchMap">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>switchMap
            <span class="apidocSignatureSpan">(project, resultSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.switchMapTo">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>switchMapTo
            <span class="apidocSignatureSpan">(innerObservable, resultSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.take">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>take
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.takeLast">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>takeLast
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.takeUntil">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>takeUntil
            <span class="apidocSignatureSpan">(notifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.takeWhile">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>takeWhile
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.throttle">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>throttle
            <span class="apidocSignatureSpan">(durationSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.throttleTime">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>throttleTime
            <span class="apidocSignatureSpan">(duration, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.timeInterval">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>timeInterval
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.timeout">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>timeout
            <span class="apidocSignatureSpan">(due, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.timeoutWith">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>timeoutWith
            <span class="apidocSignatureSpan">(due, withObservable, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.timestamp">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>timestamp
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.toArray">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.toPromise">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>toPromise
            <span class="apidocSignatureSpan">(PromiseCtor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.window">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>window
            <span class="apidocSignatureSpan">(windowBoundaries)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.windowCount">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>windowCount
            <span class="apidocSignatureSpan">(windowSize, startWindowEvery)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.windowTime">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>windowTime
            <span class="apidocSignatureSpan">(windowTimeSpan)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.windowToggle">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>windowToggle
            <span class="apidocSignatureSpan">(openings, closingSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.windowWhen">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>windowWhen
            <span class="apidocSignatureSpan">(closingSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.withLatestFrom">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>withLatestFrom
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.zip">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>zip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Observable.prototype.zipAll">
            function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>zipAll
            <span class="apidocSignatureSpan">(project)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.OuterSubscriber">module rxjs.OuterSubscriber</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.OuterSubscriber.OuterSubscriber">
            function <span class="apidocSignatureSpan">rxjs.</span>OuterSubscriber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.PairsObservable">module rxjs.PairsObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.PairsObservable.PairsObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>PairsObservable
            <span class="apidocSignatureSpan">(obj, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.PromiseObservable">module rxjs.PromiseObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.PromiseObservable.PromiseObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>PromiseObservable
            <span class="apidocSignatureSpan">(promise, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.QueueAction">module rxjs.QueueAction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.QueueAction.QueueAction">
            function <span class="apidocSignatureSpan">rxjs.</span>QueueAction
            <span class="apidocSignatureSpan">(scheduler, work)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.QueueScheduler">module rxjs.QueueScheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.QueueScheduler.QueueScheduler">
            function <span class="apidocSignatureSpan">rxjs.</span>QueueScheduler
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.RangeObservable">module rxjs.RangeObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.RangeObservable.RangeObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>RangeObservable
            <span class="apidocSignatureSpan">(start, count, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ReplaySubject">module rxjs.ReplaySubject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ReplaySubject.ReplaySubject">
            function <span class="apidocSignatureSpan">rxjs.</span>ReplaySubject
            <span class="apidocSignatureSpan">(bufferSize, windowTime, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ReplaySubject.create">
            function <span class="apidocSignatureSpan">rxjs.ReplaySubject.</span>create
            <span class="apidocSignatureSpan">(destination, source)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ReplaySubject.prototype">module rxjs.ReplaySubject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ReplaySubject.prototype._getNow">
            function <span class="apidocSignatureSpan">rxjs.ReplaySubject.prototype.</span>_getNow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ReplaySubject.prototype._subscribe">
            function <span class="apidocSignatureSpan">rxjs.ReplaySubject.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(subscriber)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ReplaySubject.prototype._trimBufferThenGetEvents">
            function <span class="apidocSignatureSpan">rxjs.ReplaySubject.prototype.</span>_trimBufferThenGetEvents
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ReplaySubject.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.ReplaySubject.prototype.</span>constructor
            <span class="apidocSignatureSpan">(bufferSize, windowTime, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ReplaySubject.prototype.next">
            function <span class="apidocSignatureSpan">rxjs.ReplaySubject.prototype.</span>next
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ScalarObservable">module rxjs.ScalarObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ScalarObservable.ScalarObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>ScalarObservable
            <span class="apidocSignatureSpan">(value, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Scheduler">module rxjs.Scheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Scheduler.Scheduler">
            function <span class="apidocSignatureSpan">rxjs.</span>Scheduler
            <span class="apidocSignatureSpan">(SchedulerAction, now)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Set">module rxjs.Set</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Set.Set">
            function <span class="apidocSignatureSpan">rxjs.</span>Set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Set.minimalSetImpl">
            function <span class="apidocSignatureSpan">rxjs.Set.</span>minimalSetImpl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Subject">module rxjs.Subject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subject.Subject">
            function <span class="apidocSignatureSpan">rxjs.</span>Subject
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subject.create">
            function <span class="apidocSignatureSpan">rxjs.Subject.</span>create
            <span class="apidocSignatureSpan">(destination, source)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Subject.prototype">module rxjs.Subject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subject.prototype._subscribe">
            function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>_subscribe
            <span class="apidocSignatureSpan">(subscriber)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subject.prototype._trySubscribe">
            function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>_trySubscribe
            <span class="apidocSignatureSpan">(subscriber)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subject.prototype.asObservable">
            function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>asObservable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subject.prototype.complete">
            function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>complete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subject.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subject.prototype.error">
            function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>error
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subject.prototype.lift">
            function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>lift
            <span class="apidocSignatureSpan">(operator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subject.prototype.next">
            function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>next
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subject.prototype.unsubscribe">
            function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>unsubscribe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.SubjectSubscription">module rxjs.SubjectSubscription</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.SubjectSubscription.SubjectSubscription">
            function <span class="apidocSignatureSpan">rxjs.</span>SubjectSubscription
            <span class="apidocSignatureSpan">(subject, subscriber)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.SubscribeOnObservable">module rxjs.SubscribeOnObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.SubscribeOnObservable.SubscribeOnObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>SubscribeOnObservable
            <span class="apidocSignatureSpan">(source, delayTime, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Subscriber">module rxjs.Subscriber</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscriber.Subscriber">
            function <span class="apidocSignatureSpan">rxjs.</span>Subscriber
            <span class="apidocSignatureSpan">(destinationOrNext, error, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscriber.create">
            function <span class="apidocSignatureSpan">rxjs.Subscriber.</span>create
            <span class="apidocSignatureSpan">(next, error, complete)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.Subscriber.</span>EMPTY</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Subscriber.prototype">module rxjs.Subscriber.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscriber.prototype._complete">
            function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>_complete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscriber.prototype._error">
            function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>_error
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscriber.prototype._next">
            function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>_next
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscriber.prototype._unsubscribeAndRecycle">
            function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>_unsubscribeAndRecycle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscriber.prototype.complete">
            function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>complete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscriber.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>constructor
            <span class="apidocSignatureSpan">(destinationOrNext, error, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscriber.prototype.error">
            function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>error
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscriber.prototype.next">
            function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>next
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscriber.prototype.unsubscribe">
            function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>unsubscribe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Subscription">module rxjs.Subscription</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscription.Subscription">
            function <span class="apidocSignatureSpan">rxjs.</span>Subscription
            <span class="apidocSignatureSpan">(unsubscribe)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rxjs.Subscription.</span>EMPTY</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.Subscription.prototype">module rxjs.Subscription.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscription.prototype._addParent">
            function <span class="apidocSignatureSpan">rxjs.Subscription.prototype.</span>_addParent
            <span class="apidocSignatureSpan">(parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscription.prototype.add">
            function <span class="apidocSignatureSpan">rxjs.Subscription.prototype.</span>add
            <span class="apidocSignatureSpan">(teardown)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscription.prototype.remove">
            function <span class="apidocSignatureSpan">rxjs.Subscription.prototype.</span>remove
            <span class="apidocSignatureSpan">(subscription)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.Subscription.prototype.unsubscribe">
            function <span class="apidocSignatureSpan">rxjs.Subscription.prototype.</span>unsubscribe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.SubscriptionLog">module rxjs.SubscriptionLog</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.SubscriptionLog.SubscriptionLog">
            function <span class="apidocSignatureSpan">rxjs.</span>SubscriptionLog
            <span class="apidocSignatureSpan">(subscribedFrame, unsubscribedFrame)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.SubscriptionLoggable">module rxjs.SubscriptionLoggable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.SubscriptionLoggable.SubscriptionLoggable">
            function <span class="apidocSignatureSpan">rxjs.</span>SubscriptionLoggable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.TestScheduler">module rxjs.TestScheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler.TestScheduler">
            function <span class="apidocSignatureSpan">rxjs.</span>TestScheduler
            <span class="apidocSignatureSpan">(assertDeepEqual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler.now">
            function <span class="apidocSignatureSpan">rxjs.TestScheduler.</span>now
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler.parseMarbles">
            function <span class="apidocSignatureSpan">rxjs.TestScheduler.</span>parseMarbles
            <span class="apidocSignatureSpan">(marbles, values, errorValue, materializeInnerObservables)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler.parseMarblesAsSubscriptions">
            function <span class="apidocSignatureSpan">rxjs.TestScheduler.</span>parseMarblesAsSubscriptions
            <span class="apidocSignatureSpan">(marbles)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rxjs.TestScheduler.</span>frameTimeFactor</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.TestScheduler.prototype">module rxjs.TestScheduler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>constructor
            <span class="apidocSignatureSpan">(assertDeepEqual)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler.prototype.createColdObservable">
            function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>createColdObservable
            <span class="apidocSignatureSpan">(marbles, values, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler.prototype.createHotObservable">
            function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>createHotObservable
            <span class="apidocSignatureSpan">(marbles, values, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler.prototype.createTime">
            function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>createTime
            <span class="apidocSignatureSpan">(marbles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler.prototype.expectObservable">
            function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>expectObservable
            <span class="apidocSignatureSpan">(observable, unsubscriptionMarbles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler.prototype.expectSubscriptions">
            function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>expectSubscriptions
            <span class="apidocSignatureSpan">(actualSubscriptionLogs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler.prototype.flush">
            function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TestScheduler.prototype.materializeInnerObservable">
            function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>materializeInnerObservable
            <span class="apidocSignatureSpan">(observable, outerFrame)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.TimeoutError">module rxjs.TimeoutError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TimeoutError.TimeoutError">
            function <span class="apidocSignatureSpan">rxjs.</span>TimeoutError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TimeoutError.captureStackTrace">
            function <span class="apidocSignatureSpan">rxjs.TimeoutError.</span>captureStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rxjs.TimeoutError.</span>stackTraceLimit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.TimeoutError.prototype">module rxjs.TimeoutError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TimeoutError.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.TimeoutError.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.TimerObservable">module rxjs.TimerObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.TimerObservable.TimerObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>TimerObservable
            <span class="apidocSignatureSpan">(dueTime, period, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.UnsubscriptionError">module rxjs.UnsubscriptionError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.UnsubscriptionError.UnsubscriptionError">
            function <span class="apidocSignatureSpan">rxjs.</span>UnsubscriptionError
            <span class="apidocSignatureSpan">(errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.UnsubscriptionError.captureStackTrace">
            function <span class="apidocSignatureSpan">rxjs.UnsubscriptionError.</span>captureStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rxjs.UnsubscriptionError.</span>stackTraceLimit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.UnsubscriptionError.prototype">module rxjs.UnsubscriptionError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.UnsubscriptionError.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.UnsubscriptionError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(errors)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.UsingObservable">module rxjs.UsingObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.UsingObservable.UsingObservable">
            function <span class="apidocSignatureSpan">rxjs.</span>UsingObservable
            <span class="apidocSignatureSpan">(resourceFactory, observableFactory)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.VirtualTimeScheduler">module rxjs.VirtualTimeScheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.VirtualTimeScheduler.VirtualTimeScheduler">
            function <span class="apidocSignatureSpan">rxjs.</span>VirtualTimeScheduler
            <span class="apidocSignatureSpan">(SchedulerAction, maxFrames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.VirtualTimeScheduler.now">
            function <span class="apidocSignatureSpan">rxjs.VirtualTimeScheduler.</span>now
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">rxjs.VirtualTimeScheduler.</span>frameTimeFactor</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.VirtualTimeScheduler.prototype">module rxjs.VirtualTimeScheduler.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.VirtualTimeScheduler.prototype.constructor">
            function <span class="apidocSignatureSpan">rxjs.VirtualTimeScheduler.prototype.</span>constructor
            <span class="apidocSignatureSpan">(SchedulerAction, maxFrames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.VirtualTimeScheduler.prototype.flush">
            function <span class="apidocSignatureSpan">rxjs.VirtualTimeScheduler.prototype.</span>flush
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.applyMixins">module rxjs.applyMixins</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.applyMixins.applyMixins">
            function <span class="apidocSignatureSpan">rxjs.</span>applyMixins
            <span class="apidocSignatureSpan">(derivedCtor, baseCtors)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.assign">module rxjs.assign</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.assign.assign">
            function <span class="apidocSignatureSpan">rxjs.</span>assign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.assign.assignImpl">
            function <span class="apidocSignatureSpan">rxjs.assign.</span>assignImpl
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.assign.getAssign">
            function <span class="apidocSignatureSpan">rxjs.assign.</span>getAssign
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.audit">module rxjs.audit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.audit.audit">
            function <span class="apidocSignatureSpan">rxjs.</span>audit
            <span class="apidocSignatureSpan">(durationSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.auditTime">module rxjs.auditTime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.auditTime.auditTime">
            function <span class="apidocSignatureSpan">rxjs.</span>auditTime
            <span class="apidocSignatureSpan">(duration, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.bindCallback">module rxjs.bindCallback</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.bindCallback.bindCallback">
            function <span class="apidocSignatureSpan">rxjs.</span>bindCallback
            <span class="apidocSignatureSpan">(func, selector, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.bindNodeCallback">module rxjs.bindNodeCallback</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.bindNodeCallback.bindNodeCallback">
            function <span class="apidocSignatureSpan">rxjs.</span>bindNodeCallback
            <span class="apidocSignatureSpan">(func, selector, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.buffer">module rxjs.buffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.buffer.buffer">
            function <span class="apidocSignatureSpan">rxjs.</span>buffer
            <span class="apidocSignatureSpan">(closingNotifier)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.bufferCount">module rxjs.bufferCount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.bufferCount.bufferCount">
            function <span class="apidocSignatureSpan">rxjs.</span>bufferCount
            <span class="apidocSignatureSpan">(bufferSize, startBufferEvery)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.bufferTime">module rxjs.bufferTime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.bufferTime.bufferTime">
            function <span class="apidocSignatureSpan">rxjs.</span>bufferTime
            <span class="apidocSignatureSpan">(bufferTimeSpan)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.bufferToggle">module rxjs.bufferToggle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.bufferToggle.bufferToggle">
            function <span class="apidocSignatureSpan">rxjs.</span>bufferToggle
            <span class="apidocSignatureSpan">(openings, closingSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.bufferWhen">module rxjs.bufferWhen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.bufferWhen.bufferWhen">
            function <span class="apidocSignatureSpan">rxjs.</span>bufferWhen
            <span class="apidocSignatureSpan">(closingSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.catch">module rxjs.catch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.catch._catch">
            function <span class="apidocSignatureSpan">rxjs.catch.</span>_catch
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.combineAll">module rxjs.combineAll</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.combineAll.combineAll">
            function <span class="apidocSignatureSpan">rxjs.</span>combineAll
            <span class="apidocSignatureSpan">(project)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.combineLatest">module rxjs.combineLatest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.combineLatest.combineLatest">
            function <span class="apidocSignatureSpan">rxjs.</span>combineLatest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.concat">module rxjs.concat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.concat.concat">
            function <span class="apidocSignatureSpan">rxjs.</span>concat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.concatAll">module rxjs.concatAll</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.concatAll.concatAll">
            function <span class="apidocSignatureSpan">rxjs.</span>concatAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.concatMap">module rxjs.concatMap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.concatMap.concatMap">
            function <span class="apidocSignatureSpan">rxjs.</span>concatMap
            <span class="apidocSignatureSpan">(project, resultSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.concatMapTo">module rxjs.concatMapTo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.concatMapTo.concatMapTo">
            function <span class="apidocSignatureSpan">rxjs.</span>concatMapTo
            <span class="apidocSignatureSpan">(innerObservable, resultSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.count">module rxjs.count</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.count.count">
            function <span class="apidocSignatureSpan">rxjs.</span>count
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.debounce">module rxjs.debounce</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.debounce.debounce">
            function <span class="apidocSignatureSpan">rxjs.</span>debounce
            <span class="apidocSignatureSpan">(durationSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.debounceTime">module rxjs.debounceTime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.debounceTime.debounceTime">
            function <span class="apidocSignatureSpan">rxjs.</span>debounceTime
            <span class="apidocSignatureSpan">(dueTime, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.defaultIfEmpty">module rxjs.defaultIfEmpty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.defaultIfEmpty.defaultIfEmpty">
            function <span class="apidocSignatureSpan">rxjs.</span>defaultIfEmpty
            <span class="apidocSignatureSpan">(defaultValue)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.defer">module rxjs.defer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.defer.defer">
            function <span class="apidocSignatureSpan">rxjs.</span>defer
            <span class="apidocSignatureSpan">(observableFactory)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.delay">module rxjs.delay</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.delay.delay">
            function <span class="apidocSignatureSpan">rxjs.</span>delay
            <span class="apidocSignatureSpan">(delay, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.delayWhen">module rxjs.delayWhen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.delayWhen.delayWhen">
            function <span class="apidocSignatureSpan">rxjs.</span>delayWhen
            <span class="apidocSignatureSpan">(delayDurationSelector, subscriptionDelay)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.dematerialize">module rxjs.dematerialize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.dematerialize.dematerialize">
            function <span class="apidocSignatureSpan">rxjs.</span>dematerialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.distinct">module rxjs.distinct</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.distinct.distinct">
            function <span class="apidocSignatureSpan">rxjs.</span>distinct
            <span class="apidocSignatureSpan">(keySelector, flushes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.distinct.DistinctSubscriber">
            function <span class="apidocSignatureSpan">rxjs.distinct.</span>DistinctSubscriber
            <span class="apidocSignatureSpan">(destination, keySelector, flushes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.distinctUntilChanged">module rxjs.distinctUntilChanged</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.distinctUntilChanged.distinctUntilChanged">
            function <span class="apidocSignatureSpan">rxjs.</span>distinctUntilChanged
            <span class="apidocSignatureSpan">(compare, keySelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.distinctUntilKeyChanged">module rxjs.distinctUntilKeyChanged</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.distinctUntilKeyChanged.distinctUntilKeyChanged">
            function <span class="apidocSignatureSpan">rxjs.</span>distinctUntilKeyChanged
            <span class="apidocSignatureSpan">(key, compare)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.do">module rxjs.do</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.do._do">
            function <span class="apidocSignatureSpan">rxjs.do.</span>_do
            <span class="apidocSignatureSpan">(nextOrObserver, error, complete)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.elementAt">module rxjs.elementAt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.elementAt.elementAt">
            function <span class="apidocSignatureSpan">rxjs.</span>elementAt
            <span class="apidocSignatureSpan">(index, defaultValue)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.empty">module rxjs.empty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.empty.empty">
            function <span class="apidocSignatureSpan">rxjs.</span>empty
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.every">module rxjs.every</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.every.every">
            function <span class="apidocSignatureSpan">rxjs.</span>every
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.exhaust">module rxjs.exhaust</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.exhaust.exhaust">
            function <span class="apidocSignatureSpan">rxjs.</span>exhaust
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.exhaustMap">module rxjs.exhaustMap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.exhaustMap.exhaustMap">
            function <span class="apidocSignatureSpan">rxjs.</span>exhaustMap
            <span class="apidocSignatureSpan">(project, resultSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.expand">module rxjs.expand</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.expand.expand">
            function <span class="apidocSignatureSpan">rxjs.</span>expand
            <span class="apidocSignatureSpan">(project, concurrent, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.expand.ExpandOperator">
            function <span class="apidocSignatureSpan">rxjs.expand.</span>ExpandOperator
            <span class="apidocSignatureSpan">(project, concurrent, scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.expand.ExpandSubscriber">
            function <span class="apidocSignatureSpan">rxjs.expand.</span>ExpandSubscriber
            <span class="apidocSignatureSpan">(destination, project, concurrent, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.filter">module rxjs.filter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.filter.filter">
            function <span class="apidocSignatureSpan">rxjs.</span>filter
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.finally">module rxjs.finally</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.finally._finally">
            function <span class="apidocSignatureSpan">rxjs.finally.</span>_finally
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.find">module rxjs.find</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.find.find">
            function <span class="apidocSignatureSpan">rxjs.</span>find
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.find.FindValueOperator">
            function <span class="apidocSignatureSpan">rxjs.find.</span>FindValueOperator
            <span class="apidocSignatureSpan">(predicate, source, yieldIndex, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.find.FindValueSubscriber">
            function <span class="apidocSignatureSpan">rxjs.find.</span>FindValueSubscriber
            <span class="apidocSignatureSpan">(destination, predicate, source, yieldIndex, thisArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.findIndex">module rxjs.findIndex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.findIndex.findIndex">
            function <span class="apidocSignatureSpan">rxjs.</span>findIndex
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.first">module rxjs.first</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.first.first">
            function <span class="apidocSignatureSpan">rxjs.</span>first
            <span class="apidocSignatureSpan">(predicate, resultSelector, defaultValue)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.forkJoin">module rxjs.forkJoin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.forkJoin.forkJoin">
            function <span class="apidocSignatureSpan">rxjs.</span>forkJoin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.from">module rxjs.from</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.from.from">
            function <span class="apidocSignatureSpan">rxjs.</span>from
            <span class="apidocSignatureSpan">(ish, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.fromEvent">module rxjs.fromEvent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.fromEvent.fromEvent">
            function <span class="apidocSignatureSpan">rxjs.</span>fromEvent
            <span class="apidocSignatureSpan">(target, eventName, options, selector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.fromEventPattern">module rxjs.fromEventPattern</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.fromEventPattern.fromEventPattern">
            function <span class="apidocSignatureSpan">rxjs.</span>fromEventPattern
            <span class="apidocSignatureSpan">(addHandler, removeHandler, selector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.fromPromise">module rxjs.fromPromise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.fromPromise.fromPromise">
            function <span class="apidocSignatureSpan">rxjs.</span>fromPromise
            <span class="apidocSignatureSpan">(promise, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.groupBy">module rxjs.groupBy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.groupBy.groupBy">
            function <span class="apidocSignatureSpan">rxjs.</span>groupBy
            <span class="apidocSignatureSpan">(keySelector, elementSelector, durationSelector, subjectSelector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.groupBy.GroupedObservable">
            function <span class="apidocSignatureSpan">rxjs.groupBy.</span>GroupedObservable
            <span class="apidocSignatureSpan">(key, groupSubject, refCountSubscription)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.if">module rxjs.if</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.if._if">
            function <span class="apidocSignatureSpan">rxjs.if.</span>_if
            <span class="apidocSignatureSpan">(condition, thenSource, elseSource)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.ignoreElements">module rxjs.ignoreElements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.ignoreElements.ignoreElements">
            function <span class="apidocSignatureSpan">rxjs.</span>ignoreElements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.interval">module rxjs.interval</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.interval.interval">
            function <span class="apidocSignatureSpan">rxjs.</span>interval
            <span class="apidocSignatureSpan">(period, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.isArray">module rxjs.isArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.isArray.isArray">
            function <span class="apidocSignatureSpan">rxjs.</span>isArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.isArrayLike">module rxjs.isArrayLike</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.isArrayLike.isArrayLike">
            function <span class="apidocSignatureSpan">rxjs.</span>isArrayLike
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.isDate">module rxjs.isDate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.isDate.isDate">
            function <span class="apidocSignatureSpan">rxjs.</span>isDate
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.isEmpty">module rxjs.isEmpty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.isEmpty.isEmpty">
            function <span class="apidocSignatureSpan">rxjs.</span>isEmpty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.isFunction">module rxjs.isFunction</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.isFunction.isFunction">
            function <span class="apidocSignatureSpan">rxjs.</span>isFunction
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.isNumeric">module rxjs.isNumeric</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.isNumeric.isNumeric">
            function <span class="apidocSignatureSpan">rxjs.</span>isNumeric
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.isObject">module rxjs.isObject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.isObject.isObject">
            function <span class="apidocSignatureSpan">rxjs.</span>isObject
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.isPromise">module rxjs.isPromise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.isPromise.isPromise">
            function <span class="apidocSignatureSpan">rxjs.</span>isPromise
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.isScheduler">module rxjs.isScheduler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.isScheduler.isScheduler">
            function <span class="apidocSignatureSpan">rxjs.</span>isScheduler
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.iterator">module rxjs.iterator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.iterator.symbolIteratorPonyfill">
            function <span class="apidocSignatureSpan">rxjs.iterator.</span>symbolIteratorPonyfill
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.last">module rxjs.last</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.last.last">
            function <span class="apidocSignatureSpan">rxjs.</span>last
            <span class="apidocSignatureSpan">(predicate, resultSelector, defaultValue)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.let">module rxjs.let</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.let.letProto">
            function <span class="apidocSignatureSpan">rxjs.let.</span>letProto
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.map">module rxjs.map</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.map.map">
            function <span class="apidocSignatureSpan">rxjs.</span>map
            <span class="apidocSignatureSpan">(project, thisArg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.map.MapOperator">
            function <span class="apidocSignatureSpan">rxjs.map.</span>MapOperator
            <span class="apidocSignatureSpan">(project, thisArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.mapTo">module rxjs.mapTo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mapTo.mapTo">
            function <span class="apidocSignatureSpan">rxjs.</span>mapTo
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.materialize">module rxjs.materialize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.materialize.materialize">
            function <span class="apidocSignatureSpan">rxjs.</span>materialize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.max">module rxjs.max</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.max.max">
            function <span class="apidocSignatureSpan">rxjs.</span>max
            <span class="apidocSignatureSpan">(comparer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.merge">module rxjs.merge</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.merge.merge">
            function <span class="apidocSignatureSpan">rxjs.</span>merge
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.mergeAll">module rxjs.mergeAll</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mergeAll.mergeAll">
            function <span class="apidocSignatureSpan">rxjs.</span>mergeAll
            <span class="apidocSignatureSpan">(concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mergeAll.MergeAllOperator">
            function <span class="apidocSignatureSpan">rxjs.mergeAll.</span>MergeAllOperator
            <span class="apidocSignatureSpan">(concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mergeAll.MergeAllSubscriber">
            function <span class="apidocSignatureSpan">rxjs.mergeAll.</span>MergeAllSubscriber
            <span class="apidocSignatureSpan">(destination, concurrent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.mergeMap">module rxjs.mergeMap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mergeMap.mergeMap">
            function <span class="apidocSignatureSpan">rxjs.</span>mergeMap
            <span class="apidocSignatureSpan">(project, resultSelector, concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mergeMap.MergeMapOperator">
            function <span class="apidocSignatureSpan">rxjs.mergeMap.</span>MergeMapOperator
            <span class="apidocSignatureSpan">(project, resultSelector, concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mergeMap.MergeMapSubscriber">
            function <span class="apidocSignatureSpan">rxjs.mergeMap.</span>MergeMapSubscriber
            <span class="apidocSignatureSpan">(destination, project, resultSelector, concurrent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.mergeMapTo">module rxjs.mergeMapTo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mergeMapTo.mergeMapTo">
            function <span class="apidocSignatureSpan">rxjs.</span>mergeMapTo
            <span class="apidocSignatureSpan">(innerObservable, resultSelector, concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mergeMapTo.MergeMapToOperator">
            function <span class="apidocSignatureSpan">rxjs.mergeMapTo.</span>MergeMapToOperator
            <span class="apidocSignatureSpan">(ish, resultSelector, concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mergeMapTo.MergeMapToSubscriber">
            function <span class="apidocSignatureSpan">rxjs.mergeMapTo.</span>MergeMapToSubscriber
            <span class="apidocSignatureSpan">(destination, ish, resultSelector, concurrent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.mergeScan">module rxjs.mergeScan</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mergeScan.mergeScan">
            function <span class="apidocSignatureSpan">rxjs.</span>mergeScan
            <span class="apidocSignatureSpan">(accumulator, seed, concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mergeScan.MergeScanOperator">
            function <span class="apidocSignatureSpan">rxjs.mergeScan.</span>MergeScanOperator
            <span class="apidocSignatureSpan">(accumulator, seed, concurrent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.mergeScan.MergeScanSubscriber">
            function <span class="apidocSignatureSpan">rxjs.mergeScan.</span>MergeScanSubscriber
            <span class="apidocSignatureSpan">(destination, accumulator, acc, concurrent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.multicast">module rxjs.multicast</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.multicast.multicast">
            function <span class="apidocSignatureSpan">rxjs.</span>multicast
            <span class="apidocSignatureSpan">(subjectOrSubjectFactory, selector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.multicast.MulticastOperator">
            function <span class="apidocSignatureSpan">rxjs.multicast.</span>MulticastOperator
            <span class="apidocSignatureSpan">(subjectFactory, selector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.never">module rxjs.never</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.never.never">
            function <span class="apidocSignatureSpan">rxjs.</span>never
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.noop">module rxjs.noop</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.noop.noop">
            function <span class="apidocSignatureSpan">rxjs.</span>noop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.not">module rxjs.not</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.not.not">
            function <span class="apidocSignatureSpan">rxjs.</span>not
            <span class="apidocSignatureSpan">(pred, thisArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.observeOn">module rxjs.observeOn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.observeOn.observeOn">
            function <span class="apidocSignatureSpan">rxjs.</span>observeOn
            <span class="apidocSignatureSpan">(scheduler, delay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.observeOn.ObserveOnMessage">
            function <span class="apidocSignatureSpan">rxjs.observeOn.</span>ObserveOnMessage
            <span class="apidocSignatureSpan">(notification, destination)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.observeOn.ObserveOnOperator">
            function <span class="apidocSignatureSpan">rxjs.observeOn.</span>ObserveOnOperator
            <span class="apidocSignatureSpan">(scheduler, delay)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.observeOn.ObserveOnSubscriber">
            function <span class="apidocSignatureSpan">rxjs.observeOn.</span>ObserveOnSubscriber
            <span class="apidocSignatureSpan">(destination, scheduler, delay)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.of">module rxjs.of</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.of.of">
            function <span class="apidocSignatureSpan">rxjs.</span>of
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.onErrorResumeNext">module rxjs.onErrorResumeNext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.onErrorResumeNext.onErrorResumeNext">
            function <span class="apidocSignatureSpan">rxjs.</span>onErrorResumeNext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.onErrorResumeNext.onErrorResumeNextStatic">
            function <span class="apidocSignatureSpan">rxjs.onErrorResumeNext.</span>onErrorResumeNextStatic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.pairs">module rxjs.pairs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.pairs.pairs">
            function <span class="apidocSignatureSpan">rxjs.</span>pairs
            <span class="apidocSignatureSpan">(obj, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.pairwise">module rxjs.pairwise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.pairwise.pairwise">
            function <span class="apidocSignatureSpan">rxjs.</span>pairwise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.partition">module rxjs.partition</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.partition.partition">
            function <span class="apidocSignatureSpan">rxjs.</span>partition
            <span class="apidocSignatureSpan">(predicate, thisArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.pluck">module rxjs.pluck</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.pluck.pluck">
            function <span class="apidocSignatureSpan">rxjs.</span>pluck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.publish">module rxjs.publish</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.publish.publish">
            function <span class="apidocSignatureSpan">rxjs.</span>publish
            <span class="apidocSignatureSpan">(selector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.publishBehavior">module rxjs.publishBehavior</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.publishBehavior.publishBehavior">
            function <span class="apidocSignatureSpan">rxjs.</span>publishBehavior
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.publishLast">module rxjs.publishLast</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.publishLast.publishLast">
            function <span class="apidocSignatureSpan">rxjs.</span>publishLast
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.publishReplay">module rxjs.publishReplay</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.publishReplay.publishReplay">
            function <span class="apidocSignatureSpan">rxjs.</span>publishReplay
            <span class="apidocSignatureSpan">(bufferSize, windowTime, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.race">module rxjs.race</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.race.race">
            function <span class="apidocSignatureSpan">rxjs.</span>race
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.race.RaceOperator">
            function <span class="apidocSignatureSpan">rxjs.race.</span>RaceOperator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.race.RaceSubscriber">
            function <span class="apidocSignatureSpan">rxjs.race.</span>RaceSubscriber
            <span class="apidocSignatureSpan">(destination)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.race.raceStatic">
            function <span class="apidocSignatureSpan">rxjs.race.</span>raceStatic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.range">module rxjs.range</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.range.range">
            function <span class="apidocSignatureSpan">rxjs.</span>range
            <span class="apidocSignatureSpan">(start, count, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.reduce">module rxjs.reduce</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.reduce.reduce">
            function <span class="apidocSignatureSpan">rxjs.</span>reduce
            <span class="apidocSignatureSpan">(accumulator, seed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.reduce.ReduceOperator">
            function <span class="apidocSignatureSpan">rxjs.reduce.</span>ReduceOperator
            <span class="apidocSignatureSpan">(accumulator, seed, hasSeed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.reduce.ReduceSubscriber">
            function <span class="apidocSignatureSpan">rxjs.reduce.</span>ReduceSubscriber
            <span class="apidocSignatureSpan">(destination, accumulator, seed, hasSeed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.repeat">module rxjs.repeat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.repeat.repeat">
            function <span class="apidocSignatureSpan">rxjs.</span>repeat
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.repeatWhen">module rxjs.repeatWhen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.repeatWhen.repeatWhen">
            function <span class="apidocSignatureSpan">rxjs.</span>repeatWhen
            <span class="apidocSignatureSpan">(notifier)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.retry">module rxjs.retry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.retry.retry">
            function <span class="apidocSignatureSpan">rxjs.</span>retry
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.retryWhen">module rxjs.retryWhen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.retryWhen.retryWhen">
            function <span class="apidocSignatureSpan">rxjs.</span>retryWhen
            <span class="apidocSignatureSpan">(notifier)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.sample">module rxjs.sample</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.sample.sample">
            function <span class="apidocSignatureSpan">rxjs.</span>sample
            <span class="apidocSignatureSpan">(notifier)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.sampleTime">module rxjs.sampleTime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.sampleTime.sampleTime">
            function <span class="apidocSignatureSpan">rxjs.</span>sampleTime
            <span class="apidocSignatureSpan">(period, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.scan">module rxjs.scan</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.scan.scan">
            function <span class="apidocSignatureSpan">rxjs.</span>scan
            <span class="apidocSignatureSpan">(accumulator, seed)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.sequenceEqual">module rxjs.sequenceEqual</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.sequenceEqual.sequenceEqual">
            function <span class="apidocSignatureSpan">rxjs.</span>sequenceEqual
            <span class="apidocSignatureSpan">(compareTo, comparor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.sequenceEqual.SequenceEqualOperator">
            function <span class="apidocSignatureSpan">rxjs.sequenceEqual.</span>SequenceEqualOperator
            <span class="apidocSignatureSpan">(compareTo, comparor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.sequenceEqual.SequenceEqualSubscriber">
            function <span class="apidocSignatureSpan">rxjs.sequenceEqual.</span>SequenceEqualSubscriber
            <span class="apidocSignatureSpan">(destination, compareTo, comparor)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.share">module rxjs.share</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.share.share">
            function <span class="apidocSignatureSpan">rxjs.</span>share
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.single">module rxjs.single</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.single.single">
            function <span class="apidocSignatureSpan">rxjs.</span>single
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.skip">module rxjs.skip</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.skip.skip">
            function <span class="apidocSignatureSpan">rxjs.</span>skip
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.skipUntil">module rxjs.skipUntil</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.skipUntil.skipUntil">
            function <span class="apidocSignatureSpan">rxjs.</span>skipUntil
            <span class="apidocSignatureSpan">(notifier)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.skipWhile">module rxjs.skipWhile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.skipWhile.skipWhile">
            function <span class="apidocSignatureSpan">rxjs.</span>skipWhile
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.startWith">module rxjs.startWith</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.startWith.startWith">
            function <span class="apidocSignatureSpan">rxjs.</span>startWith
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.subscribeOn">module rxjs.subscribeOn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.subscribeOn.subscribeOn">
            function <span class="apidocSignatureSpan">rxjs.</span>subscribeOn
            <span class="apidocSignatureSpan">(scheduler, delay)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.subscribeToResult">module rxjs.subscribeToResult</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.subscribeToResult.subscribeToResult">
            function <span class="apidocSignatureSpan">rxjs.</span>subscribeToResult
            <span class="apidocSignatureSpan">(outerSubscriber, result, outerValue, outerIndex)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.switch">module rxjs.switch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.switch._switch">
            function <span class="apidocSignatureSpan">rxjs.switch.</span>_switch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.switchMap">module rxjs.switchMap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.switchMap.switchMap">
            function <span class="apidocSignatureSpan">rxjs.</span>switchMap
            <span class="apidocSignatureSpan">(project, resultSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.switchMapTo">module rxjs.switchMapTo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.switchMapTo.switchMapTo">
            function <span class="apidocSignatureSpan">rxjs.</span>switchMapTo
            <span class="apidocSignatureSpan">(innerObservable, resultSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.take">module rxjs.take</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.take.take">
            function <span class="apidocSignatureSpan">rxjs.</span>take
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.takeLast">module rxjs.takeLast</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.takeLast.takeLast">
            function <span class="apidocSignatureSpan">rxjs.</span>takeLast
            <span class="apidocSignatureSpan">(count)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.takeUntil">module rxjs.takeUntil</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.takeUntil.takeUntil">
            function <span class="apidocSignatureSpan">rxjs.</span>takeUntil
            <span class="apidocSignatureSpan">(notifier)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.takeWhile">module rxjs.takeWhile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.takeWhile.takeWhile">
            function <span class="apidocSignatureSpan">rxjs.</span>takeWhile
            <span class="apidocSignatureSpan">(predicate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.throttle">module rxjs.throttle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.throttle.throttle">
            function <span class="apidocSignatureSpan">rxjs.</span>throttle
            <span class="apidocSignatureSpan">(durationSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.throttleTime">module rxjs.throttleTime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.throttleTime.throttleTime">
            function <span class="apidocSignatureSpan">rxjs.</span>throttleTime
            <span class="apidocSignatureSpan">(duration, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.throw">module rxjs.throw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.throw._throw">
            function <span class="apidocSignatureSpan">rxjs.throw.</span>_throw
            <span class="apidocSignatureSpan">(error, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.timeInterval">module rxjs.timeInterval</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.timeInterval.timeInterval">
            function <span class="apidocSignatureSpan">rxjs.</span>timeInterval
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.timeInterval.TimeInterval">
            function <span class="apidocSignatureSpan">rxjs.timeInterval.</span>TimeInterval
            <span class="apidocSignatureSpan">(value, interval)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.timeout">module rxjs.timeout</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.timeout.timeout">
            function <span class="apidocSignatureSpan">rxjs.</span>timeout
            <span class="apidocSignatureSpan">(due, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.timeoutWith">module rxjs.timeoutWith</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.timeoutWith.timeoutWith">
            function <span class="apidocSignatureSpan">rxjs.</span>timeoutWith
            <span class="apidocSignatureSpan">(due, withObservable, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.timer">module rxjs.timer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.timer.timer">
            function <span class="apidocSignatureSpan">rxjs.</span>timer
            <span class="apidocSignatureSpan">(initialDelay, period, scheduler)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.timestamp">module rxjs.timestamp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.timestamp.timestamp">
            function <span class="apidocSignatureSpan">rxjs.</span>timestamp
            <span class="apidocSignatureSpan">(scheduler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.timestamp.Timestamp">
            function <span class="apidocSignatureSpan">rxjs.timestamp.</span>Timestamp
            <span class="apidocSignatureSpan">(value, timestamp)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.toArray">module rxjs.toArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.toArray.toArray">
            function <span class="apidocSignatureSpan">rxjs.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.toPromise">module rxjs.toPromise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.toPromise.toPromise">
            function <span class="apidocSignatureSpan">rxjs.</span>toPromise
            <span class="apidocSignatureSpan">(PromiseCtor)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.toSubscriber">module rxjs.toSubscriber</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.toSubscriber.toSubscriber">
            function <span class="apidocSignatureSpan">rxjs.</span>toSubscriber
            <span class="apidocSignatureSpan">(nextOrObserver, error, complete)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.tryCatch">module rxjs.tryCatch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.tryCatch.tryCatch">
            function <span class="apidocSignatureSpan">rxjs.</span>tryCatch
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.using">module rxjs.using</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.using.using">
            function <span class="apidocSignatureSpan">rxjs.</span>using
            <span class="apidocSignatureSpan">(resourceFactory, observableFactory)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.window">module rxjs.window</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.window.window">
            function <span class="apidocSignatureSpan">rxjs.</span>window
            <span class="apidocSignatureSpan">(windowBoundaries)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.windowCount">module rxjs.windowCount</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.windowCount.windowCount">
            function <span class="apidocSignatureSpan">rxjs.</span>windowCount
            <span class="apidocSignatureSpan">(windowSize, startWindowEvery)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.windowTime">module rxjs.windowTime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.windowTime.windowTime">
            function <span class="apidocSignatureSpan">rxjs.</span>windowTime
            <span class="apidocSignatureSpan">(windowTimeSpan)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.windowToggle">module rxjs.windowToggle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.windowToggle.windowToggle">
            function <span class="apidocSignatureSpan">rxjs.</span>windowToggle
            <span class="apidocSignatureSpan">(openings, closingSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.windowWhen">module rxjs.windowWhen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.windowWhen.windowWhen">
            function <span class="apidocSignatureSpan">rxjs.</span>windowWhen
            <span class="apidocSignatureSpan">(closingSelector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.withLatestFrom">module rxjs.withLatestFrom</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.withLatestFrom.withLatestFrom">
            function <span class="apidocSignatureSpan">rxjs.</span>withLatestFrom
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.zip">module rxjs.zip</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.zip.zip">
            function <span class="apidocSignatureSpan">rxjs.</span>zip
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rxjs.zipAll">module rxjs.zipAll</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rxjs.zipAll.zipAll">
            function <span class="apidocSignatureSpan">rxjs.</span>zipAll
            <span class="apidocSignatureSpan">(project)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs" id="apidoc.module.rxjs">module rxjs</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AjaxError" id="apidoc.element.rxjs.AjaxError">
        function <span class="apidocSignatureSpan">rxjs.</span>AjaxError
        <span class="apidocSignatureSpan">(message, xhr, request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AjaxError(message, xhr, request) {
    _super.call(this, message);
    this.message = message;
    this.xhr = xhr;
    this.request = request;
    this.status = xhr.status;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AjaxResponse" id="apidoc.element.rxjs.AjaxResponse">
        function <span class="apidocSignatureSpan">rxjs.</span>AjaxResponse
        <span class="apidocSignatureSpan">(originalEvent, xhr, request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AjaxResponse(originalEvent, xhr, request) {
    this.originalEvent = originalEvent;
    this.xhr = xhr;
    this.request = request;
    this.status = xhr.status;
    this.responseType = xhr.responseType || request.responseType;
    switch (this.responseType) {
        case 'json':
            if ('response' in xhr) {
                //IE does not support json as responseType, parse it internally
                this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
            }
            else {
                this.response = JSON.parse(xhr.responseText || 'null');
            }
            break;
        case 'xml':
            this.response = xhr.responseXML;
            break;
        case 'text':
        default:
            this.response = ('response' in xhr) ? xhr.response : xhr.responseText;
            break;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AjaxTimeoutError" id="apidoc.element.rxjs.AjaxTimeoutError">
        function <span class="apidocSignatureSpan">rxjs.</span>AjaxTimeoutError
        <span class="apidocSignatureSpan">(xhr, request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AjaxTimeoutError(xhr, request) {
    _super.call(this, 'ajax timeout', xhr, request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AnonymousSubject" id="apidoc.element.rxjs.AnonymousSubject">
        function <span class="apidocSignatureSpan">rxjs.</span>AnonymousSubject
        <span class="apidocSignatureSpan">(destination, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousSubject(destination, source) {
    _super.call(this);
    this.destination = destination;
    this.source = source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ArgumentOutOfRangeError" id="apidoc.element.rxjs.ArgumentOutOfRangeError">
        function <span class="apidocSignatureSpan">rxjs.</span>ArgumentOutOfRangeError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArgumentOutOfRangeError() {
    var err = _super.call(this, 'argument out of range');
    this.name = err.name = 'ArgumentOutOfRangeError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AsyncSubject" id="apidoc.element.rxjs.AsyncSubject">
        function <span class="apidocSignatureSpan">rxjs.</span>AsyncSubject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncSubject() {
    _super.apply(this, arguments);
    this.value = null;
    this.hasNext = false;
    this.hasCompleted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    BoundCallbackObservable.prototype._subscribe = function (subscriber) {
var callbackFunc = this.callbackFunc;
var args = this.args;
var scheduler = this.scheduler;
var subject = this.subject;
if (!scheduler) {
    if (!subject) {
        subject = this.subject = new AsyncSubject_1.<span class="apidocCodeKeywordSpan">AsyncSubject</span>();
        var handler = function handlerFn() {
            var innerArgs = [];
            for (var _i = 0; _i &lt; arguments.length; _i++) {
                innerArgs[_i - 0] = arguments[_i];
            }
            var source = handlerFn.source;
            var selector = source.selector, subject = source.subject;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.BehaviorSubject" id="apidoc.element.rxjs.BehaviorSubject">
        function <span class="apidocSignatureSpan">rxjs.</span>BehaviorSubject
        <span class="apidocSignatureSpan">(_value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehaviorSubject(_value) {
    _super.call(this);
    this._value = _value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * @param value
 * @return {ConnectableObservable&lt;T&gt;}
 * @method publishBehavior
 * @owner Observable
 */
function publishBehavior(value) {
    return multicast_1.multicast.call(this, new BehaviorSubject_1.<span class="apidocCodeKeywordSpan">BehaviorSubject</span>(value
));
}
exports.publishBehavior = publishBehavior;
//# sourceMappingURL=publishBehavior.js.map
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable" id="apidoc.element.rxjs.ConnectableObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>ConnectableObservable
        <span class="apidocSignatureSpan">(source, subjectFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConnectableObservable(source, subjectFactory) {
    _super.call(this);
    this.source = source;
    this.subjectFactory = subjectFactory;
    this._refCount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.ajax" id="apidoc.element.rxjs.ConnectableObservable.ajax">
        function <span class="apidocSignatureSpan">rxjs.</span>ConnectableObservable.ajax
        <span class="apidocSignatureSpan">(urlOrRequest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConnectableObservable.ajax = function (urlOrRequest) {
    return new AjaxObservable(urlOrRequest);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.EmptyError" id="apidoc.element.rxjs.EmptyError">
        function <span class="apidocSignatureSpan">rxjs.</span>EmptyError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EmptyError() {
    var err = _super.call(this, 'no elements in sequence');
    this.name = err.name = 'EmptyError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Notification" id="apidoc.element.rxjs.Notification">
        function <span class="apidocSignatureSpan">rxjs.</span>Notification
        <span class="apidocSignatureSpan">(kind, value, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Notification(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === 'N';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `error`. Such Observable is the output of a `materialize` operation. Those
* notifications are then unwrapped using the metadata they contain, and emitted
* as `next`, `error`, and `complete` on the output Observable.
*
* Use this operator in conjunction with {@link materialize}.
*
* @example &lt;caption&gt;Convert an Observable of Notifications to an actual Observable&lt;/caption&gt;
* var notifA = new Rx.<span class="apidocCodeKeywordSpan">Notification</span>('N', 'A');
* var notifB = new Rx.Notification('N', 'B');
* var notifE = new Rx.Notification('E', void 0,
*   new TypeError('x.toUpperCase is not a function')
* );
* var materialized = Rx.Observable.of(notifA, notifB, notifE);
* var upperCase = materialized.dematerialize();
* upperCase.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ObjectUnsubscribedError" id="apidoc.element.rxjs.ObjectUnsubscribedError">
        function <span class="apidocSignatureSpan">rxjs.</span>ObjectUnsubscribedError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectUnsubscribedError() {
    var err = _super.call(this, 'object unsubscribed');
    this.name = err.name = 'ObjectUnsubscribedError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return subscription;
};
BehaviorSubject.prototype.getValue = function () {
    if (this.hasError) {
        throw this.thrownError;
    }
    else if (this.closed) {
        throw new ObjectUnsubscribedError_1.<span class="apidocCodeKeywordSpan">ObjectUnsubscribedError</span>();
    }
    else {
        return this._value;
    }
};
BehaviorSubject.prototype.next = function (value) {
    _super.prototype.next.call(this, this._value = value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable" id="apidoc.element.rxjs.Observable">
        function <span class="apidocSignatureSpan">rxjs.</span>Observable
        <span class="apidocSignatureSpan">(subscribe)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Observable(subscribe) {
    this._isScalar = false;
    if (subscribe) {
        this._subscribe = subscribe;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    else {
        this.observers.push(subscriber);
        return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
    }
};
Subject.prototype.asObservable = function () {
    var observable = new Observable_1.<span class="apidocCodeKeywordSpan">Observable</span>();
    observable.source = this;
    return observable;
};
Subject.create = function (destination, source) {
    return new AnonymousSubject(destination, source);
};
return Subject;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ReplaySubject" id="apidoc.element.rxjs.ReplaySubject">
        function <span class="apidocSignatureSpan">rxjs.</span>ReplaySubject
        <span class="apidocSignatureSpan">(bufferSize, windowTime, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReplaySubject(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
    _super.call(this);
    this.scheduler = scheduler;
    this._events = [];
    this._bufferSize = bufferSize &lt; 1 ? 1 : bufferSize;
    this._windowTime = windowTime &lt; 1 ? 1 : windowTime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {ConnectableObservable&lt;T&gt;}
 * @method publishReplay
 * @owner Observable
 */
function publishReplay(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
    return multicast_1.multicast.call(this, new ReplaySubject_1.<span class="apidocCodeKeywordSpan">ReplaySubject</span>(bufferSize
, windowTime, scheduler));
}
exports.publishReplay = publishReplay;
//# sourceMappingURL=publishReplay.js.map
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subject" id="apidoc.element.rxjs.Subject">
        function <span class="apidocSignatureSpan">rxjs.</span>Subject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subject() {
    _super.call(this);
    this.observers = [];
    this.closed = false;
    this.isStopped = false;
    this.hasError = false;
    this.thrownError = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.error(err);
    }
}
else {
    element = value;
}
if (!group) {
    group = this.subjectSelector ? this.subjectSelector() : new Subject_1.<span class="apidocCodeKeywordSpan">Subject</span>();
    groups.set(key, group);
    var groupedObservable = new GroupedObservable(key, group, this);
    this.destination.next(groupedObservable);
    if (this.durationSelector) {
        var duration = void 0;
        try {
            duration = this.durationSelector(new GroupedObservable(key, group));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscriber" id="apidoc.element.rxjs.Subscriber">
        function <span class="apidocSignatureSpan">rxjs.</span>Subscriber
        <span class="apidocSignatureSpan">(destinationOrNext, error, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subscriber(destinationOrNext, error, complete) {
    _super.call(this);
    this.syncErrorValue = null;
    this.syncErrorThrown = false;
    this.syncErrorThrowable = false;
    this.isStopped = false;
    switch (arguments.length) {
        case 0:
            this.destination = Observer_1.empty;
            break;
        case 1:
            if (!destinationOrNext) {
                this.destination = Observer_1.empty;
                break;
            }
            if (typeof destinationOrNext === 'object') {
                if (destinationOrNext instanceof Subscriber) {
                    this.destination = destinationOrNext;
                    this.destination.add(this);
                }
                else {
                    this.syncErrorThrowable = true;
                    this.destination = new SafeSubscriber(this, destinationOrNext);
                }
                break;
            }
        default:
            this.syncErrorThrowable = true;
            this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
            break;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = (function (_super) {
__extends(DoSubscriber, _super);
function DoSubscriber(destination, nextOrObserver, error, complete) {
    _super.call(this, destination);
    var safeSubscriber = new Subscriber_1.<span class="apidocCodeKeywordSpan">Subscriber</span>(nextOrObserver, error, complete);
    safeSubscriber.syncErrorThrowable = true;
    this.add(safeSubscriber);
    this.safeSubscriber = safeSubscriber;
}
DoSubscriber.prototype._next = function (value) {
    var safeSubscriber = this.safeSubscriber;
    safeSubscriber.next(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscription" id="apidoc.element.rxjs.Subscription">
        function <span class="apidocSignatureSpan">rxjs.</span>Subscription
        <span class="apidocSignatureSpan">(unsubscribe)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subscription(unsubscribe) {
<span class="apidocCodeCommentSpan">    /**
     * A flag to indicate whether this Subscription has already been unsubscribed.
     * @type {boolean}
     */
</span>    this.closed = false;
    this._parent = null;
    this._parents = null;
    this._subscriptions = null;
    if (unsubscribe) {
        this._unsubscribe = unsubscribe;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this._subject = this.subjectFactory();
    }
    return this._subject;
};
ConnectableObservable.prototype.connect = function () {
    var connection = this._connection;
    if (!connection) {
        connection = this._connection = new Subscription_1.<span class="apidocCodeKeywordSpan">Subscription</span>();
        connection.add(this.source
            .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
        if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
        }
        else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler" id="apidoc.element.rxjs.TestScheduler">
        function <span class="apidocSignatureSpan">rxjs.</span>TestScheduler
        <span class="apidocSignatureSpan">(assertDeepEqual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TestScheduler(assertDeepEqual) {
    _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame);
    this.assertDeepEqual = assertDeepEqual;
    this.hotObservables = [];
    this.coldObservables = [];
    this.flushTests = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TimeInterval" id="apidoc.element.rxjs.TimeInterval">
        function <span class="apidocSignatureSpan">rxjs.</span>TimeInterval
        <span class="apidocSignatureSpan">(value, interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeInterval(value, interval) {
    this.value = value;
    this.interval = interval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TimeoutError" id="apidoc.element.rxjs.TimeoutError">
        function <span class="apidocSignatureSpan">rxjs.</span>TimeoutError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError() {
    var err = _super.call(this, 'Timeout has occurred');
    this.name = err.name = 'TimeoutError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @method timeout
 * @owner Observable
 */
function timeout(due, scheduler) {
if (scheduler === void 0) { scheduler = async_1.async; }
var absoluteTimeout = isDate_1.isDate(due);
var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.<span class="apidocCodeKeywordSpan">
TimeoutError</span>()));
}
exports.timeout = timeout;
var TimeoutOperator = (function () {
function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
    this.waitFor = waitFor;
    this.absoluteTimeout = absoluteTimeout;
    this.scheduler = scheduler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Timestamp" id="apidoc.element.rxjs.Timestamp">
        function <span class="apidocSignatureSpan">rxjs.</span>Timestamp
        <span class="apidocSignatureSpan">(value, timestamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Timestamp(value, timestamp) {
    this.value = value;
    this.timestamp = timestamp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.UnsubscriptionError" id="apidoc.element.rxjs.UnsubscriptionError">
        function <span class="apidocSignatureSpan">rxjs.</span>UnsubscriptionError
        <span class="apidocSignatureSpan">(errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UnsubscriptionError(errors) {
    _super.call(this);
    this.errors = errors;
    var err = Error.call(this, errors ?
        errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " +
err.toString()); }).join('\n  ') : '');
    this.name = err.name = 'UnsubscriptionError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        errors.push(err);
                    }
                }
            }
        }
    }
    if (hasErrors) {
        throw new UnsubscriptionError_1.<span class="apidocCodeKeywordSpan">UnsubscriptionError</span>(errors);
    }
};
/**
 * Adds a tear down to be called during the unsubscribe() of this
 * Subscription.
 *
 * If the tear down being added is a subscription that is already
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.VirtualTimeScheduler" id="apidoc.element.rxjs.VirtualTimeScheduler">
        function <span class="apidocSignatureSpan">rxjs.</span>VirtualTimeScheduler
        <span class="apidocSignatureSpan">(SchedulerAction, maxFrames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VirtualTimeScheduler(SchedulerAction, maxFrames) {
    var _this = this;
    if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
    if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
    _super.call(this, SchedulerAction, function () { return _this.frame; });
    this.maxFrames = maxFrames;
    this.frame = 0;
    this.index = -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















































































































































































































































































































































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Action" id="apidoc.module.rxjs.Action">module rxjs.Action</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Action.Action" id="apidoc.element.rxjs.Action.Action">
        function <span class="apidocSignatureSpan">rxjs.</span>Action
        <span class="apidocSignatureSpan">(scheduler, work)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Action(scheduler, work) {
    _super.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AjaxError" id="apidoc.module.rxjs.AjaxError">module rxjs.AjaxError</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AjaxError.AjaxError" id="apidoc.element.rxjs.AjaxError.AjaxError">
        function <span class="apidocSignatureSpan">rxjs.</span>AjaxError
        <span class="apidocSignatureSpan">(message, xhr, request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AjaxError(message, xhr, request) {
    _super.call(this, message);
    this.message = message;
    this.xhr = xhr;
    this.request = request;
    this.status = xhr.status;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AjaxError.captureStackTrace" id="apidoc.element.rxjs.AjaxError.captureStackTrace">
        function <span class="apidocSignatureSpan">rxjs.AjaxError.</span>captureStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureStackTrace() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AjaxError.prototype" id="apidoc.module.rxjs.AjaxError.prototype">module rxjs.AjaxError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AjaxError.prototype.constructor" id="apidoc.element.rxjs.AjaxError.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.AjaxError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(message, xhr, request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AjaxError(message, xhr, request) {
    _super.call(this, message);
    this.message = message;
    this.xhr = xhr;
    this.request = request;
    this.status = xhr.status;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AjaxTimeoutError" id="apidoc.module.rxjs.AjaxTimeoutError">module rxjs.AjaxTimeoutError</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AjaxTimeoutError.AjaxTimeoutError" id="apidoc.element.rxjs.AjaxTimeoutError.AjaxTimeoutError">
        function <span class="apidocSignatureSpan">rxjs.</span>AjaxTimeoutError
        <span class="apidocSignatureSpan">(xhr, request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AjaxTimeoutError(xhr, request) {
    _super.call(this, 'ajax timeout', xhr, request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AjaxTimeoutError.captureStackTrace" id="apidoc.element.rxjs.AjaxTimeoutError.captureStackTrace">
        function <span class="apidocSignatureSpan">rxjs.AjaxTimeoutError.</span>captureStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureStackTrace() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AjaxTimeoutError.prototype" id="apidoc.module.rxjs.AjaxTimeoutError.prototype">module rxjs.AjaxTimeoutError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AjaxTimeoutError.prototype.constructor" id="apidoc.element.rxjs.AjaxTimeoutError.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.AjaxTimeoutError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(xhr, request)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AjaxTimeoutError(xhr, request) {
    _super.call(this, 'ajax timeout', xhr, request);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AnimationFrame" id="apidoc.module.rxjs.AnimationFrame">module rxjs.AnimationFrame</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AnimationFrame.RequestAnimationFrameDefinition" id="apidoc.element.rxjs.AnimationFrame.RequestAnimationFrameDefinition">
        function <span class="apidocSignatureSpan">rxjs.AnimationFrame.</span>RequestAnimationFrameDefinition
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RequestAnimationFrameDefinition(root) {
    if (root.requestAnimationFrame) {
        this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);
        this.requestAnimationFrame = root.requestAnimationFrame.bind(root);
    }
    else if (root.mozRequestAnimationFrame) {
        this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);
        this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);
    }
    else if (root.webkitRequestAnimationFrame) {
        this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);
        this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);
    }
    else if (root.msRequestAnimationFrame) {
        this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);
        this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);
    }
    else if (root.oRequestAnimationFrame) {
        this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);
        this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);
    }
    else {
        this.cancelAnimationFrame = root.clearTimeout.bind(root);
        this.requestAnimationFrame = function (cb) { return root.setTimeout(cb, 1000 / 60); };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AnimationFrameAction" id="apidoc.module.rxjs.AnimationFrameAction">module rxjs.AnimationFrameAction</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AnimationFrameAction.AnimationFrameAction" id="apidoc.element.rxjs.AnimationFrameAction.AnimationFrameAction">
        function <span class="apidocSignatureSpan">rxjs.</span>AnimationFrameAction
        <span class="apidocSignatureSpan">(scheduler, work)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnimationFrameAction(scheduler, work) {
    _super.call(this, scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AnimationFrameScheduler" id="apidoc.module.rxjs.AnimationFrameScheduler">module rxjs.AnimationFrameScheduler</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AnimationFrameScheduler.AnimationFrameScheduler" id="apidoc.element.rxjs.AnimationFrameScheduler.AnimationFrameScheduler">
        function <span class="apidocSignatureSpan">rxjs.</span>AnimationFrameScheduler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnimationFrameScheduler() {
    _super.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * // You will see .some-div element growing in height
 *
 *
 * @static true
 * @name animationFrame
 * @owner Scheduler
 */
exports.animationFrame = new AnimationFrameScheduler_1.<span class="apidocCodeKeywordSpan">AnimationFrameScheduler</span>(AnimationFrameAction_1
.AnimationFrameAction);
//# sourceMappingURL=animationFrame.js.map
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AnonymousSubject" id="apidoc.module.rxjs.AnonymousSubject">module rxjs.AnonymousSubject</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AnonymousSubject.AnonymousSubject" id="apidoc.element.rxjs.AnonymousSubject.AnonymousSubject">
        function <span class="apidocSignatureSpan">rxjs.</span>AnonymousSubject
        <span class="apidocSignatureSpan">(destination, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousSubject(destination, source) {
    _super.call(this);
    this.destination = destination;
    this.source = source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AnonymousSubject.create" id="apidoc.element.rxjs.AnonymousSubject.create">
        function <span class="apidocSignatureSpan">rxjs.AnonymousSubject.</span>create
        <span class="apidocSignatureSpan">(destination, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (destination, source) {
    return new AnonymousSubject(destination, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



"use strict";
var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.<span class="apidocCodeKeywordSpan">create</span>(b) : (__.prototype = b.prototype, new __
());
};
var Subject_1 = require('./Subject');
var Subscription_1 = require('./Subscription');
/**
 * @class AsyncSubject&lt;T&gt;
 */
var AsyncSubject = (function (_super) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AnonymousSubject.prototype" id="apidoc.module.rxjs.AnonymousSubject.prototype">module rxjs.AnonymousSubject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AnonymousSubject.prototype._subscribe" id="apidoc.element.rxjs.AnonymousSubject.prototype._subscribe">
        function <span class="apidocSignatureSpan">rxjs.AnonymousSubject.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(subscriber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (subscriber) {
    var source = this.source;
    if (source) {
        return this.source.subscribe(subscriber);
    }
    else {
        return Subscription_1.Subscription.EMPTY;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            throw sink.syncErrorValue;
        }
    }
    return sink;
};
Observable.prototype._trySubscribe = function (sink) {
    try {
        return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(sink);
    }
    catch (err) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
        sink.error(err);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AnonymousSubject.prototype.complete" id="apidoc.element.rxjs.AnonymousSubject.prototype.complete">
        function <span class="apidocSignatureSpan">rxjs.AnonymousSubject.prototype.</span>complete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">complete = function () {
    var destination = this.destination;
    if (destination &amp;&amp; destination.complete) {
        this.destination.complete();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.next(this.value);
        subscriber.<span class="apidocCodeKeywordSpan">complete</span>();
        return Subscription_1.Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
};
AsyncSubject.prototype.next = function (value) {
    if (!this.hasCompleted) {
        this.value = value;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AnonymousSubject.prototype.constructor" id="apidoc.element.rxjs.AnonymousSubject.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.AnonymousSubject.prototype.</span>constructor
        <span class="apidocSignatureSpan">(destination, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AnonymousSubject(destination, source) {
    _super.call(this);
    this.destination = destination;
    this.source = source;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AnonymousSubject.prototype.error" id="apidoc.element.rxjs.AnonymousSubject.prototype.error">
        function <span class="apidocSignatureSpan">rxjs.AnonymousSubject.prototype.</span>error
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (err) {
    var destination = this.destination;
    if (destination &amp;&amp; destination.error) {
        this.destination.error(err);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    _super.apply(this, arguments);
    this.value = null;
    this.hasNext = false;
    this.hasCompleted = false;
}
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.<span class="apidocCodeKeywordSpan">error</span>(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.next(this.value);
        subscriber.complete();
        return Subscription_1.Subscription.EMPTY;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AnonymousSubject.prototype.next" id="apidoc.element.rxjs.AnonymousSubject.prototype.next">
        function <span class="apidocSignatureSpan">rxjs.AnonymousSubject.prototype.</span>next
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (value) {
    var destination = this.destination;
    if (destination &amp;&amp; destination.next) {
        destination.next(value);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.<span class="apidocCodeKeywordSpan">next</span>(this.value);
        subscriber.complete();
        return Subscription_1.Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
};
AsyncSubject.prototype.next = function (value) {
    if (!this.hasCompleted) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ArgumentOutOfRangeError" id="apidoc.module.rxjs.ArgumentOutOfRangeError">module rxjs.ArgumentOutOfRangeError</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ArgumentOutOfRangeError.ArgumentOutOfRangeError" id="apidoc.element.rxjs.ArgumentOutOfRangeError.ArgumentOutOfRangeError">
        function <span class="apidocSignatureSpan">rxjs.</span>ArgumentOutOfRangeError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArgumentOutOfRangeError() {
    var err = _super.call(this, 'argument out of range');
    this.name = err.name = 'ArgumentOutOfRangeError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ArgumentOutOfRangeError.captureStackTrace" id="apidoc.element.rxjs.ArgumentOutOfRangeError.captureStackTrace">
        function <span class="apidocSignatureSpan">rxjs.ArgumentOutOfRangeError.</span>captureStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureStackTrace() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ArgumentOutOfRangeError.prototype" id="apidoc.module.rxjs.ArgumentOutOfRangeError.prototype">module rxjs.ArgumentOutOfRangeError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ArgumentOutOfRangeError.prototype.constructor" id="apidoc.element.rxjs.ArgumentOutOfRangeError.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.ArgumentOutOfRangeError.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArgumentOutOfRangeError() {
    var err = _super.call(this, 'argument out of range');
    this.name = err.name = 'ArgumentOutOfRangeError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ArrayLikeObservable" id="apidoc.module.rxjs.ArrayLikeObservable">module rxjs.ArrayLikeObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ArrayLikeObservable.ArrayLikeObservable" id="apidoc.element.rxjs.ArrayLikeObservable.ArrayLikeObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>ArrayLikeObservable
        <span class="apidocSignatureSpan">(arrayLike, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArrayLikeObservable(arrayLike, scheduler) {
    _super.call(this);
    this.arrayLike = arrayLike;
    this.scheduler = scheduler;
    if (!scheduler &amp;&amp; arrayLike.length === 1) {
        this._isScalar = true;
        this.value = arrayLike[0];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        else if (isPromise_1.isPromise(ish)) {
            return new PromiseObservable_1.PromiseObservable(ish, scheduler);
        }
        else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
            return new IteratorObservable_1.IteratorObservable(ish, scheduler);
        }
        else if (isArrayLike_1.isArrayLike(ish)) {
            return new ArrayLikeObservable_1.<span class="apidocCodeKeywordSpan">ArrayLikeObservable</span>(ish, scheduler);
        }
    }
    throw new TypeError((ish !== null &amp;&amp; typeof ish || ish) + ' is not observable');
};
FromObservable.prototype._subscribe = function (subscriber) {
    var ish = this.ish;
    var scheduler = this.scheduler;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ArrayObservable" id="apidoc.module.rxjs.ArrayObservable">module rxjs.ArrayObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ArrayObservable.ArrayObservable" id="apidoc.element.rxjs.ArrayObservable.ArrayObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>ArrayObservable
        <span class="apidocSignatureSpan">(array, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ArrayObservable(array, scheduler) {
    _super.call(this);
    this.array = array;
    this.scheduler = scheduler;
    if (!scheduler &amp;&amp; array.length === 1) {
        this._isScalar = true;
        this.value = array[0];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (typeof ish[observable_1.$$observable] === 'function') {
    if (ish instanceof Observable_1.Observable &amp;&amp; !scheduler) {
        return ish;
    }
    return new FromObservable(ish, scheduler);
}
else if (isArray_1.isArray(ish)) {
    return new ArrayObservable_1.<span class="apidocCodeKeywordSpan">ArrayObservable</span>(ish, scheduler);
}
else if (isPromise_1.isPromise(ish)) {
    return new PromiseObservable_1.PromiseObservable(ish, scheduler);
}
else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
    return new IteratorObservable_1.IteratorObservable(ish, scheduler);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AsapAction" id="apidoc.module.rxjs.AsapAction">module rxjs.AsapAction</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AsapAction.AsapAction" id="apidoc.element.rxjs.AsapAction.AsapAction">
        function <span class="apidocSignatureSpan">rxjs.</span>AsapAction
        <span class="apidocSignatureSpan">(scheduler, work)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsapAction(scheduler, work) {
    _super.call(this, scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AsapScheduler" id="apidoc.module.rxjs.AsapScheduler">module rxjs.AsapScheduler</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AsapScheduler.AsapScheduler" id="apidoc.element.rxjs.AsapScheduler.AsapScheduler">
        function <span class="apidocSignatureSpan">rxjs.</span>AsapScheduler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsapScheduler() {
    _super.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * // "async"
 * // ... but 'asap' goes first!
 *
 * @static true
 * @name asap
 * @owner Scheduler
 */
exports.asap = new AsapScheduler_1.<span class="apidocCodeKeywordSpan">AsapScheduler</span>(AsapAction_1.AsapAction);
//# sourceMappingURL=asap.js.map
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AsyncAction" id="apidoc.module.rxjs.AsyncAction">module rxjs.AsyncAction</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AsyncAction.AsyncAction" id="apidoc.element.rxjs.AsyncAction.AsyncAction">
        function <span class="apidocSignatureSpan">rxjs.</span>AsyncAction
        <span class="apidocSignatureSpan">(scheduler, work)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncAction(scheduler, work) {
    _super.call(this, scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
    this.pending = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AsyncScheduler" id="apidoc.module.rxjs.AsyncScheduler">module rxjs.AsyncScheduler</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AsyncScheduler.AsyncScheduler" id="apidoc.element.rxjs.AsyncScheduler.AsyncScheduler">
        function <span class="apidocSignatureSpan">rxjs.</span>AsyncScheduler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncScheduler() {
    _super.apply(this, arguments);
    this.actions = [];
<span class="apidocCodeCommentSpan">    /**
     * A flag to indicate whether the Scheduler is currently executing a batch of
     * queued actions.
     * @type {boolean}
     */
</span>    this.active = false;
    /**
     * An internal ID used to track the latest asynchronous task such as those
     * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
     * others.
     * @type {any}
     */
    this.scheduled = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.<span class="apidocCodeKeywordSpan">AsyncScheduler</span>(AsyncAction_1.AsyncAction);
//# sourceMappingURL=async.js.map
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AsyncSubject" id="apidoc.module.rxjs.AsyncSubject">module rxjs.AsyncSubject</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AsyncSubject.AsyncSubject" id="apidoc.element.rxjs.AsyncSubject.AsyncSubject">
        function <span class="apidocSignatureSpan">rxjs.</span>AsyncSubject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncSubject() {
    _super.apply(this, arguments);
    this.value = null;
    this.hasNext = false;
    this.hasCompleted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    BoundCallbackObservable.prototype._subscribe = function (subscriber) {
var callbackFunc = this.callbackFunc;
var args = this.args;
var scheduler = this.scheduler;
var subject = this.subject;
if (!scheduler) {
    if (!subject) {
        subject = this.subject = new AsyncSubject_1.<span class="apidocCodeKeywordSpan">AsyncSubject</span>();
        var handler = function handlerFn() {
            var innerArgs = [];
            for (var _i = 0; _i &lt; arguments.length; _i++) {
                innerArgs[_i - 0] = arguments[_i];
            }
            var source = handlerFn.source;
            var selector = source.selector, subject = source.subject;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AsyncSubject.create" id="apidoc.element.rxjs.AsyncSubject.create">
        function <span class="apidocSignatureSpan">rxjs.AsyncSubject.</span>create
        <span class="apidocSignatureSpan">(destination, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (destination, source) {
    return new AnonymousSubject(destination, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



"use strict";
var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.<span class="apidocCodeKeywordSpan">create</span>(b) : (__.prototype = b.prototype, new __
());
};
var Subject_1 = require('./Subject');
var Subscription_1 = require('./Subscription');
/**
 * @class AsyncSubject&lt;T&gt;
 */
var AsyncSubject = (function (_super) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.AsyncSubject.prototype" id="apidoc.module.rxjs.AsyncSubject.prototype">module rxjs.AsyncSubject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.AsyncSubject.prototype._subscribe" id="apidoc.element.rxjs.AsyncSubject.prototype._subscribe">
        function <span class="apidocSignatureSpan">rxjs.AsyncSubject.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(subscriber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.next(this.value);
        subscriber.complete();
        return Subscription_1.Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            throw sink.syncErrorValue;
        }
    }
    return sink;
};
Observable.prototype._trySubscribe = function (sink) {
    try {
        return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(sink);
    }
    catch (err) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
        sink.error(err);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AsyncSubject.prototype.complete" id="apidoc.element.rxjs.AsyncSubject.prototype.complete">
        function <span class="apidocSignatureSpan">rxjs.AsyncSubject.prototype.</span>complete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">complete = function () {
    this.hasCompleted = true;
    if (this.hasNext) {
        _super.prototype.next.call(this, this.value);
    }
    _super.prototype.complete.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.next(this.value);
        subscriber.<span class="apidocCodeKeywordSpan">complete</span>();
        return Subscription_1.Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
};
AsyncSubject.prototype.next = function (value) {
    if (!this.hasCompleted) {
        this.value = value;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AsyncSubject.prototype.constructor" id="apidoc.element.rxjs.AsyncSubject.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.AsyncSubject.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncSubject() {
    _super.apply(this, arguments);
    this.value = null;
    this.hasNext = false;
    this.hasCompleted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AsyncSubject.prototype.error" id="apidoc.element.rxjs.AsyncSubject.prototype.error">
        function <span class="apidocSignatureSpan">rxjs.AsyncSubject.prototype.</span>error
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (error) {
    if (!this.hasCompleted) {
        _super.prototype.error.call(this, error);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    _super.apply(this, arguments);
    this.value = null;
    this.hasNext = false;
    this.hasCompleted = false;
}
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.<span class="apidocCodeKeywordSpan">error</span>(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.next(this.value);
        subscriber.complete();
        return Subscription_1.Subscription.EMPTY;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.AsyncSubject.prototype.next" id="apidoc.element.rxjs.AsyncSubject.prototype.next">
        function <span class="apidocSignatureSpan">rxjs.AsyncSubject.prototype.</span>next
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (value) {
    if (!this.hasCompleted) {
        this.value = value;
        this.hasNext = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.<span class="apidocCodeKeywordSpan">next</span>(this.value);
        subscriber.complete();
        return Subscription_1.Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
};
AsyncSubject.prototype.next = function (value) {
    if (!this.hasCompleted) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.BehaviorSubject" id="apidoc.module.rxjs.BehaviorSubject">module rxjs.BehaviorSubject</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.BehaviorSubject.BehaviorSubject" id="apidoc.element.rxjs.BehaviorSubject.BehaviorSubject">
        function <span class="apidocSignatureSpan">rxjs.</span>BehaviorSubject
        <span class="apidocSignatureSpan">(_value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehaviorSubject(_value) {
    _super.call(this);
    this._value = _value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * @param value
 * @return {ConnectableObservable&lt;T&gt;}
 * @method publishBehavior
 * @owner Observable
 */
function publishBehavior(value) {
    return multicast_1.multicast.call(this, new BehaviorSubject_1.<span class="apidocCodeKeywordSpan">BehaviorSubject</span>(value
));
}
exports.publishBehavior = publishBehavior;
//# sourceMappingURL=publishBehavior.js.map
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.BehaviorSubject.create" id="apidoc.element.rxjs.BehaviorSubject.create">
        function <span class="apidocSignatureSpan">rxjs.BehaviorSubject.</span>create
        <span class="apidocSignatureSpan">(destination, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (destination, source) {
    return new AnonymousSubject(destination, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



"use strict";
var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.<span class="apidocCodeKeywordSpan">create</span>(b) : (__.prototype = b.prototype, new __
());
};
var Subject_1 = require('./Subject');
var Subscription_1 = require('./Subscription');
/**
 * @class AsyncSubject&lt;T&gt;
 */
var AsyncSubject = (function (_super) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.BehaviorSubject.prototype" id="apidoc.module.rxjs.BehaviorSubject.prototype">module rxjs.BehaviorSubject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.BehaviorSubject.prototype._subscribe" id="apidoc.element.rxjs.BehaviorSubject.prototype._subscribe">
        function <span class="apidocSignatureSpan">rxjs.BehaviorSubject.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(subscriber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    if (subscription &amp;&amp; !subscription.closed) {
        subscriber.next(this._value);
    }
    return subscription;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            throw sink.syncErrorValue;
        }
    }
    return sink;
};
Observable.prototype._trySubscribe = function (sink) {
    try {
        return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(sink);
    }
    catch (err) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
        sink.error(err);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.BehaviorSubject.prototype.constructor" id="apidoc.element.rxjs.BehaviorSubject.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.BehaviorSubject.prototype.</span>constructor
        <span class="apidocSignatureSpan">(_value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BehaviorSubject(_value) {
    _super.call(this);
    this._value = _value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.BehaviorSubject.prototype.getValue" id="apidoc.element.rxjs.BehaviorSubject.prototype.getValue">
        function <span class="apidocSignatureSpan">rxjs.BehaviorSubject.prototype.</span>getValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValue = function () {
    if (this.hasError) {
        throw this.thrownError;
    }
    else if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
    }
    else {
        return this._value;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
__extends(BehaviorSubject, _super);
function BehaviorSubject(_value) {
    _super.call(this);
    this._value = _value;
}
Object.defineProperty(BehaviorSubject.prototype, "value", {
    get: function () {
        return this.<span class="apidocCodeKeywordSpan">getValue</span>();
    },
    enumerable: true,
    configurable: true
});
BehaviorSubject.prototype._subscribe = function (subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    if (subscription &amp;&amp; !subscription.closed) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.BehaviorSubject.prototype.next" id="apidoc.element.rxjs.BehaviorSubject.prototype.next">
        function <span class="apidocSignatureSpan">rxjs.BehaviorSubject.prototype.</span>next
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (value) {
    _super.prototype.next.call(this, this._value = value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.<span class="apidocCodeKeywordSpan">next</span>(this.value);
        subscriber.complete();
        return Subscription_1.Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
};
AsyncSubject.prototype.next = function (value) {
    if (!this.hasCompleted) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.BoundCallbackObservable" id="apidoc.module.rxjs.BoundCallbackObservable">module rxjs.BoundCallbackObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.BoundCallbackObservable.BoundCallbackObservable" id="apidoc.element.rxjs.BoundCallbackObservable.BoundCallbackObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>BoundCallbackObservable
        <span class="apidocSignatureSpan">(callbackFunc, selector, args, context, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {
    _super.call(this);
    this.callbackFunc = callbackFunc;
    this.selector = selector;
    this.args = args;
    this.context = context;
    this.scheduler = scheduler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.BoundNodeCallbackObservable" id="apidoc.module.rxjs.BoundNodeCallbackObservable">module rxjs.BoundNodeCallbackObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.BoundNodeCallbackObservable.BoundNodeCallbackObservable" id="apidoc.element.rxjs.BoundNodeCallbackObservable.BoundNodeCallbackObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>BoundNodeCallbackObservable
        <span class="apidocSignatureSpan">(callbackFunc, selector, args, context, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BoundNodeCallbackObservable(callbackFunc, selector, args, context, scheduler) {
    _super.call(this);
    this.callbackFunc = callbackFunc;
    this.selector = selector;
    this.args = args;
    this.context = context;
    this.scheduler = scheduler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ColdObservable" id="apidoc.module.rxjs.ColdObservable">module rxjs.ColdObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ColdObservable.ColdObservable" id="apidoc.element.rxjs.ColdObservable.ColdObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>ColdObservable
        <span class="apidocSignatureSpan">(messages, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ColdObservable(messages, scheduler) {
    _super.call(this, function (subscriber) {
        var observable = this;
        var index = observable.logSubscribedFrame();
        subscriber.add(new Subscription_1.Subscription(function () {
            observable.logUnsubscribedFrame(index);
        }));
        observable.scheduleMessages(subscriber);
        return subscriber;
    });
    this.messages = messages;
    this.subscriptions = [];
    this.scheduler = scheduler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (marbles.indexOf('^') !== -1) {
        throw new Error('cold observable cannot have subscription offset "^"');
    }
    if (marbles.indexOf('!') !== -1) {
        throw new Error('cold observable cannot have unsubscription marker "!"');
    }
    var messages = TestScheduler.parseMarbles(marbles, values, error);
    var cold = new ColdObservable_1.<span class="apidocCodeKeywordSpan">ColdObservable</span>(messages, this);
    this.coldObservables.push(cold);
    return cold;
};
TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
    if (marbles.indexOf('!') !== -1) {
        throw new Error('hot observable cannot have unsubscription marker "!"');
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ConnectableObservable" id="apidoc.module.rxjs.ConnectableObservable">module rxjs.ConnectableObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.ConnectableObservable" id="apidoc.element.rxjs.ConnectableObservable.ConnectableObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>ConnectableObservable
        <span class="apidocSignatureSpan">(source, subjectFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConnectableObservable(source, subjectFactory) {
    _super.call(this);
    this.source = source;
    this.subjectFactory = subjectFactory;
    this._refCount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.ajax" id="apidoc.element.rxjs.ConnectableObservable.ajax">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>ajax
        <span class="apidocSignatureSpan">(urlOrRequest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ajax = function (urlOrRequest) {
    return new AjaxObservable(urlOrRequest);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.bindCallback" id="apidoc.element.rxjs.ConnectableObservable.bindCallback">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>bindCallback
        <span class="apidocSignatureSpan">(func, selector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindCallback = function (func, selector, scheduler) {
    if (selector === void 0) { selector = undefined; }
    return function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        return new BoundCallbackObservable(func, selector, args, this, scheduler);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* provides convenient error handling and probably is a better choice.
* `bindCallback` will treat such functions without any difference and error parameter
* (whether passed or not) will always be interpreted as regular callback argument.
*
*
* @example &lt;caption&gt;Convert jQuery's getJSON to an Observable API&lt;/caption&gt;
* // Suppose we have jQuery.getJSON('/my/url', callback)
* var getJSONAsObservable = Rx.Observable.<span class="apidocCodeKeywordSpan">bindCallback</span>(jQuery.getJSON);
* var result = getJSONAsObservable('/my/url');
* result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
*
*
* @example &lt;caption&gt;Receive array of arguments passed to callback&lt;/caption&gt;
* someFunction((a, b, c) =&gt; {
*   console.log(a); // 5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.bindNodeCallback" id="apidoc.element.rxjs.ConnectableObservable.bindNodeCallback">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>bindNodeCallback
        <span class="apidocSignatureSpan">(func, selector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindNodeCallback = function (func, selector, scheduler) {
    if (selector === void 0) { selector = undefined; }
    return function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Note that even if error parameter is technically present in callback, but its value
* is falsy, it still won't appear in array emitted by Observable or in selector function.
*
*
* @example &lt;caption&gt;Read a file from the filesystem and get the data as an Observable&lt;/caption&gt;
* import * as fs from 'fs';
* var readFileAsObservable = Rx.Observable.<span class="apidocCodeKeywordSpan">bindNodeCallback</span>(fs.readFile);
* var result = readFileAsObservable('./roadNames.txt', 'utf8');
* result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
*
*
* @example &lt;caption&gt;Use on function calling callback with multiple arguments&lt;/caption&gt;
* someFunction((err, a, b) =&gt; {
*   console.log(err); // null
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.combineLatest" id="apidoc.element.rxjs.ConnectableObservable.combineLatest">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>combineLatest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function combineLatest() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 &amp;&amp; isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* of values, but values themselves. That means default `project` can be imagined
* as function that takes all its arguments and puts them into an array.
*
*
* @example &lt;caption&gt;Combine two timer Observables&lt;/caption&gt;
* const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
* const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
* const combinedTimers = Rx.Observable.<span class="apidocCodeKeywordSpan">combineLatest</span>(firstTimer, secondTimer);
* combinedTimers.subscribe(value =&gt; console.log(value));
* // Logs
* // [0, 0] after 0.5s
* // [1, 0] after 1s
* // [1, 1] after 1.5s
* // [2, 1] after 2s
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.concat" id="apidoc.element.rxjs.ConnectableObservable.concat">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatStatic() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var scheduler = null;
    var args = observables;
    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
        scheduler = args.pop();
    }
    if (scheduler === null &amp;&amp; observables.length === 1 &amp;&amp; observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (isObject_1.isObject(sub)) {
        var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
        if (trial === errorObject_1.errorObject) {
            hasErrors = true;
            errors = errors || [];
            var err = errorObject_1.errorObject.e;
            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                errors = errors.<span class="apidocCodeKeywordSpan">concat</span>(flattenUnsubscriptionErrors(err.errors));
            }
            else {
                errors.push(err);
            }
        }
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.create" id="apidoc.element.rxjs.ConnectableObservable.create">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>create
        <span class="apidocSignatureSpan">(subscribe)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (subscribe) {
    return new Observable(subscribe);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



"use strict";
var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.<span class="apidocCodeKeywordSpan">create</span>(b) : (__.prototype = b.prototype, new __
());
};
var Subject_1 = require('./Subject');
var Subscription_1 = require('./Subscription');
/**
 * @class AsyncSubject&lt;T&gt;
 */
var AsyncSubject = (function (_super) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.defer" id="apidoc.element.rxjs.ConnectableObservable.defer">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>defer
        <span class="apidocSignatureSpan">(observableFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defer = function (observableFactory) {
    return new DeferObservable(observableFactory);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* an Observer subscribes to it, and then it generates an Observable,
* typically with an Observable factory function. It does this afresh for each
* subscriber, so although each subscriber may think it is subscribing to the
* same Observable, in fact each subscriber gets its own individual
* Observable.
*
* @example &lt;caption&gt;Subscribe to either an Observable of clicks or an Observable of interval, at random&lt;/caption&amp;#
x3e;
* var clicksOrInterval = Rx.Observable.<span class="apidocCodeKeywordSpan">defer</span>(function () {
*   if (Math.random() &gt; 0.5) {
*     return Rx.Observable.fromEvent(document, 'click');
*   } else {
*     return Rx.Observable.interval(1000);
*   }
* });
* clicksOrInterval.subscribe(x =&gt; console.log(x));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.empty" id="apidoc.element.rxjs.ConnectableObservable.empty">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>empty
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function (scheduler) {
    return new EmptyObservable(scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var kind = this.kind;
    switch (kind) {
        case 'N':
            return Observable_1.Observable.of(this.value);
        case 'E':
            return Observable_1.Observable.throw(this.error);
        case 'C':
            return Observable_1.Observable.<span class="apidocCodeKeywordSpan">empty</span>();
    }
    throw new Error('unexpected notification kind value');
};
/**
 * A shortcut to create a Notification instance of the type `next` from a
 * given value.
 * @param {T} value The `next` value.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.forkJoin" id="apidoc.element.rxjs.ConnectableObservable.forkJoin">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>forkJoin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forkJoin = function () {
    var sources = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        sources[_i - 0] = arguments[_i];
    }
    if (sources === null || arguments.length === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    var resultSelector = null;
    if (typeof sources[sources.length - 1] === 'function') {
        resultSelector = sources.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`
    if (sources.length === 1 &amp;&amp; isArray_1.isArray(sources[0])) {
        sources = sources[0];
    }
    if (sources.length === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    return new ForkJoinObservable(sources, resultSelector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.from" id="apidoc.element.rxjs.ConnectableObservable.from">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>from
        <span class="apidocSignatureSpan">(ish, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (ish, scheduler) {
    if (ish != null) {
        if (typeof ish[observable_1.$$observable] === 'function') {
            if (ish instanceof Observable_1.Observable &amp;&amp; !scheduler) {
                return ish;
            }
            return new FromObservable(ish, scheduler);
        }
        else if (isArray_1.isArray(ish)) {
            return new ArrayObservable_1.ArrayObservable(ish, scheduler);
        }
        else if (isPromise_1.isPromise(ish)) {
            return new PromiseObservable_1.PromiseObservable(ish, scheduler);
        }
        else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
            return new IteratorObservable_1.IteratorObservable(ish, scheduler);
        }
        else if (isArrayLike_1.isArrayLike(ish)) {
            return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
        }
    }
    throw new TypeError((ish !== null &amp;&amp; typeof ish || ish) + ' is not observable');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* object into an Observable that emits the items in that promise or array or
* iterable. A String, in this context, is treated as an array of characters.
* Observable-like objects (contains a function named with the ES2015 Symbol
* for Observable) can also be converted through this operator.
*
* @example &lt;caption&gt;Converts an array to an Observable&lt;/caption&gt;
* var array = [10, 20, 30];
* var result = Rx.Observable.<span class="apidocCodeKeywordSpan">from</span>(array);
* result.subscribe(x =&gt; console.log(x));
*
* // Results in the following:
* // 10 20 30
*
* @example &lt;caption&gt;Convert an infinite iterable (from a generator) to an Observable&lt;/caption&gt;
* function* generateDoubles(seed) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.fromEvent" id="apidoc.element.rxjs.ConnectableObservable.fromEvent">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>fromEvent
        <span class="apidocSignatureSpan">(target, eventName, options, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEvent = function (target, eventName, options, selector) {
    if (isFunction_1.isFunction(options)) {
        selector = options;
        options = undefined;
    }
    return new FromEventObservable(target, eventName, selector, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* subscriber, so although each subscriber may think it is subscribing to the
* same Observable, in fact each subscriber gets its own individual
* Observable.
*
* @example &lt;caption&gt;Subscribe to either an Observable of clicks or an Observable of interval, at random&lt;/caption&amp;#
x3e;
* var clicksOrInterval = Rx.Observable.defer(function () {
*   if (Math.random() &gt; 0.5) {
*     return Rx.Observable.<span class="apidocCodeKeywordSpan">fromEvent</span>(document, 'click');
*   } else {
*     return Rx.Observable.interval(1000);
*   }
* });
* clicksOrInterval.subscribe(x =&gt; console.log(x));
*
* // Results in the following behavior:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.fromEventPattern" id="apidoc.element.rxjs.ConnectableObservable.fromEventPattern">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>fromEventPattern
        <span class="apidocSignatureSpan">(addHandler, removeHandler, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEventPattern = function (addHandler, removeHandler, selector) {
    return new FromEventPatternObservable(addHandler, removeHandler, selector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*   document.addEventListener('click', handler);
* }
*
* function removeClickHandler(handler) {
*   document.removeEventListener('click', handler);
* }
*
* var clicks = Rx.Observable.<span class="apidocCodeKeywordSpan">fromEventPattern</span>(
*   addClickHandler,
*   removeClickHandler
* );
* clicks.subscribe(x =&gt; console.log(x));
*
* @see {@link from}
* @see {@link fromEvent}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.fromPromise" id="apidoc.element.rxjs.ConnectableObservable.fromPromise">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>fromPromise
        <span class="apidocSignatureSpan">(promise, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromPromise = function (promise, scheduler) {
    return new PromiseObservable(promise, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
* Observable. If the Promise resolves with a value, the output Observable
* emits that resolved value as a `next`, and then completes. If the Promise
* is rejected, then the output Observable emits the corresponding Error.
*
* @example &lt;caption&gt;Convert the Promise returned by Fetch to an Observable&lt;/caption&gt;
* var result = Rx.Observable.<span class="apidocCodeKeywordSpan">fromPromise</span>(fetch('http://myserver.com/'));
* result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
*
* @see {@link bindCallback}
* @see {@link from}
*
* @param {Promise&lt;T&gt;} promise The promise to be converted.
* @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.generate" id="apidoc.element.rxjs.ConnectableObservable.generate">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>generate
        <span class="apidocSignatureSpan">(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    if (arguments.length == 1) {
        return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions
.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);
    }
    if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
        return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);
    }
    return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.if" id="apidoc.element.rxjs.ConnectableObservable.if">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>if
        <span class="apidocSignatureSpan">(condition, thenSource, elseSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">if = function (condition, thenSource, elseSource) {
    return new IfObservable(condition, thenSource, elseSource);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.interval" id="apidoc.element.rxjs.ConnectableObservable.interval">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>interval
        <span class="apidocSignatureSpan">(period, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interval = function (period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async_1.async; }
    return new IntervalObservable(period, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* By default, it uses a `null` IScheduler, which means the `next`
* notifications are sent synchronously, although with a different IScheduler
* it is possible to determine when those notifications will be delivered.
*
* @example &lt;caption&gt;Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second
.&lt;/caption&gt;
* var numbers = Rx.Observable.of(10, 20, 30);
* var letters = Rx.Observable.of('a', 'b', 'c');
* var interval = Rx.Observable.<span class="apidocCodeKeywordSpan">interval</span>(1000);
* var result = numbers.concat(letters).concat(interval);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link create}
* @see {@link empty}
* @see {@link never}
* @see {@link throw}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.merge" id="apidoc.element.rxjs.ConnectableObservable.merge">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeStatic() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length &gt; 1 &amp;&amp; typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null &amp;&amp; observables.length === 1 &amp;&amp; observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.never" id="apidoc.element.rxjs.ConnectableObservable.never">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>never
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">never = function () {
    return new NeverObservable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* subscription from being disposed automatically. Subscriptions need to be
* manually disposed.
*
* @example &lt;caption&gt;Emit the number 7, then never emit anything else (not even complete).&lt;/caption&gt;
* function info() {
*   console.log('Will not be called');
* }
* var result = Rx.Observable.<span class="apidocCodeKeywordSpan">never</span>().startWith(7);
* result.subscribe(x =&gt; console.log(x), info, info);
*
* @see {@link create}
* @see {@link empty}
* @see {@link of}
* @see {@link throw}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.of" id="apidoc.element.rxjs.ConnectableObservable.of">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {
    var array = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
    }
    else {
        scheduler = null;
    }
    var len = array.length;
    if (len &gt; 1) {
        return new ArrayObservable(array, scheduler);
    }
    else if (len === 1) {
        return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
    }
    else {
        return new EmptyObservable_1.EmptyObservable(scheduler);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

To import the entire core set of functionality:

```js
import Rx from 'rxjs/Rx';

Rx.Observable.<span class="apidocCodeKeywordSpan">of</span>(1,2,3)
```

To import only what you need by patching (this is useful for size-sensitive bundling):

```js
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.onErrorResumeNext" id="apidoc.element.rxjs.ConnectableObservable.onErrorResumeNext">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>onErrorResumeNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    var source = null;
    if (nextSources.length === 1 &amp;&amp; isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.pairs" id="apidoc.element.rxjs.ConnectableObservable.pairs">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>pairs
        <span class="apidocSignatureSpan">(obj, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pairs = function (obj, scheduler) {
    return new PairsObservable(obj, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @example &lt;caption&gt;Converts a javascript object to an Observable&lt;/caption&gt;
* var obj = {
*   foo: 42,
*   bar: 56,
*   baz: 78
* };
*
* var source = Rx.Observable.<span class="apidocCodeKeywordSpan">pairs</span>(obj);
*
* var subscription = source.subscribe(
*   function (x) {
*     console.log('Next: %s', x);
*   },
*   function (err) {
*     console.log('Error: %s', err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.race" id="apidoc.element.rxjs.ConnectableObservable.race">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>race
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function raceStatic() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `pair([obs1, obs2, ...])`
    if (observables.length === 1) {
        if (isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.range" id="apidoc.element.rxjs.ConnectableObservable.range">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>range
        <span class="apidocSignatureSpan">(start, count, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">range = function (start, count, scheduler) {
    if (start === void 0) { start = 0; }
    if (count === void 0) { count = 0; }
    return new RangeObservable(start, count, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// connection Subscription on the shared ConnectableObservable. In cases
// where the ConnectableObservable source synchronously emits values, and
// the RefCountSubscriber's downstream Observers synchronously unsubscribe,
// execution continues to here before the RefCountOperator has a chance to
// supply the RefCountSubscriber with the shared connection Subscription.
// For example:
// ```
// Observable.<span class="apidocCodeKeywordSpan">range</span>(0, 10)
//   .publish()
//   .refCount()
//   .take(5)
//   .subscribe();
// ```
// In order to account for this case, RefCountSubscriber should only dispose
// the ConnectableObservable's shared connection Subscription if the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.throw" id="apidoc.element.rxjs.ConnectableObservable.throw">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>throw
        <span class="apidocSignatureSpan">(error, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throw = function (error, scheduler) {
    return new ErrorObservable(error, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Notification.prototype.toObservable = function () {
    var kind = this.kind;
    switch (kind) {
        case 'N':
            return Observable_1.Observable.of(this.value);
        case 'E':
            return Observable_1.Observable.<span class="apidocCodeKeywordSpan">throw</span>(this.error);
        case 'C':
            return Observable_1.Observable.empty();
    }
    throw new Error('unexpected notification kind value');
};
/**
 * A shortcut to create a Notification instance of the type `next` from a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.timer" id="apidoc.element.rxjs.ConnectableObservable.timer">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>timer
        <span class="apidocSignatureSpan">(initialDelay, period, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timer = function (initialDelay, period, scheduler) {
    if (initialDelay === void 0) { initialDelay = 0; }
    return new TimerObservable(initialDelay, period, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `initialDelay`. The initial delay may be a {@link Date}. By default, this
* operator uses the `async` IScheduler to provide a notion of time, but you
* may pass any IScheduler to it. If `period` is not specified, the output
* Observable emits only one value, `0`. Otherwise, it emits an infinite
* sequence.
*
* @example &lt;caption&gt;Emits ascending numbers, one every second (1000ms), starting after 3 seconds&lt;/caption&gt;
* var numbers = Rx.Observable.<span class="apidocCodeKeywordSpan">timer</span>(3000, 1000);
* numbers.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Emits one number after five seconds&lt;/caption&gt;
* var numbers = Rx.Observable.timer(5000);
* numbers.subscribe(x =&gt; console.log(x));
*
* @see {@link interval}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.using" id="apidoc.element.rxjs.ConnectableObservable.using">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>using
        <span class="apidocSignatureSpan">(resourceFactory, observableFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">using = function (resourceFactory, observableFactory) {
    return new UsingObservable(resourceFactory, observableFactory);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.webSocket" id="apidoc.element.rxjs.ConnectableObservable.webSocket">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>webSocket
        <span class="apidocSignatureSpan">(urlConfigOrSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">webSocket = function (urlConfigOrSource) {
    return new WebSocketSubject(urlConfigOrSource);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.zip" id="apidoc.element.rxjs.ConnectableObservable.zip">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>zip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zipStatic() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ConnectableObservable.ajax" id="apidoc.module.rxjs.ConnectableObservable.ajax">module rxjs.ConnectableObservable.ajax</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.ajax.ajax" id="apidoc.element.rxjs.ConnectableObservable.ajax.ajax">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.</span>ajax
        <span class="apidocSignatureSpan">(urlOrRequest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ajax = function (urlOrRequest) {
    return new AjaxObservable(urlOrRequest);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.ajax.delete" id="apidoc.element.rxjs.ConnectableObservable.ajax.delete">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.ajax.</span>delete
        <span class="apidocSignatureSpan">(url, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ajaxDelete(url, headers) {
    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            group.complete();
        });
        groups.clear();
    }
    this.destination.complete();
};
GroupBySubscriber.prototype.removeGroup = function (key) {
    this.groups.<span class="apidocCodeKeywordSpan">delete</span>(key);
};
GroupBySubscriber.prototype.unsubscribe = function () {
    if (!this.closed) {
        this.attemptedToUnsubscribe = true;
        if (this.count === 0) {
            _super.prototype.unsubscribe.call(this);
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.ajax.get" id="apidoc.element.rxjs.ConnectableObservable.ajax.get">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.ajax.</span>get
        <span class="apidocSignatureSpan">(url, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ajaxGet(url, headers) {
    if (headers === void 0) { headers = null; }
    return new AjaxObservable({ method: 'GET', url: url, headers: headers });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._group(value, key);
};
GroupBySubscriber.prototype._group = function (value, key) {
    var groups = this.groups;
    if (!groups) {
        groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();
    }
    var group = groups.<span class="apidocCodeKeywordSpan">get</span>(key);
    var element;
    if (this.elementSelector) {
        try {
            element = this.elementSelector(value);
        }
        catch (err) {
            this.error(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.ajax.getJSON" id="apidoc.element.rxjs.ConnectableObservable.ajax.getJSON">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.ajax.</span>getJSON
        <span class="apidocSignatureSpan">(url, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ajaxGetJSON(url, headers) {
    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers })
        .lift(new map_1.MapOperator(function (x, index) { return x.response; }, null));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* optional error parameter signaling whether call failed or not), {@link bindNodeCallback}
* provides convenient error handling and probably is a better choice.
* `bindCallback` will treat such functions without any difference and error parameter
* (whether passed or not) will always be interpreted as regular callback argument.
*
*
* @example &lt;caption&gt;Convert jQuery's getJSON to an Observable API&lt;/caption&gt;
* // Suppose we have jQuery.<span class="apidocCodeKeywordSpan">getJSON</span>('/my/url', callback)
* var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);
* var result = getJSONAsObservable('/my/url');
* result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
*
*
* @example &lt;caption&gt;Receive array of arguments passed to callback&lt;/caption&gt;
* someFunction((a, b, c) =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.ajax.patch" id="apidoc.element.rxjs.ConnectableObservable.ajax.patch">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.ajax.</span>patch
        <span class="apidocSignatureSpan">(url, body, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ajaxPatch(url, body, headers) {
    return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.ajax.post" id="apidoc.element.rxjs.ConnectableObservable.ajax.post">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.ajax.</span>post
        <span class="apidocSignatureSpan">(url, body, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ajaxPost(url, body, headers) {
    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.ajax.put" id="apidoc.element.rxjs.ConnectableObservable.ajax.put">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.ajax.</span>put
        <span class="apidocSignatureSpan">(url, body, headers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ajaxPut(url, body, headers) {
    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ConnectableObservable.prototype" id="apidoc.module.rxjs.ConnectableObservable.prototype">module rxjs.ConnectableObservable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.prototype._subscribe" id="apidoc.element.rxjs.ConnectableObservable.prototype._subscribe">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(subscriber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (subscriber) {
    return this.getSubject().subscribe(subscriber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            throw sink.syncErrorValue;
        }
    }
    return sink;
};
Observable.prototype._trySubscribe = function (sink) {
    try {
        return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(sink);
    }
    catch (err) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
        sink.error(err);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.prototype.connect" id="apidoc.element.rxjs.ConnectableObservable.prototype.connect">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function () {
    var connection = this._connection;
    if (!connection) {
        connection = this._connection = new Subscription_1.Subscription();
        connection.add(this.source
            .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
        if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
        }
        else {
            this._connection = connection;
        }
    }
    return connection;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
RefCountOperator.prototype.call = function (subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);
    if (!refCounter.closed) {
        refCounter.connection = connectable.<span class="apidocCodeKeywordSpan">connect</span>();
    }
    return subscription;
};
return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
__extends(RefCountSubscriber, _super);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.prototype.constructor" id="apidoc.element.rxjs.ConnectableObservable.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.prototype.</span>constructor
        <span class="apidocSignatureSpan">(source, subjectFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ConnectableObservable(source, subjectFactory) {
    _super.call(this);
    this.source = source;
    this.subjectFactory = subjectFactory;
    this._refCount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.prototype.getSubject" id="apidoc.element.rxjs.ConnectableObservable.prototype.getSubject">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.prototype.</span>getSubject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSubject = function () {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
    }
    return this._subject;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function ConnectableObservable(source, subjectFactory) {
    _super.call(this);
    this.source = source;
    this.subjectFactory = subjectFactory;
    this._refCount = 0;
}
ConnectableObservable.prototype._subscribe = function (subscriber) {
    return this.<span class="apidocCodeKeywordSpan">getSubject</span>().subscribe(subscriber);
};
ConnectableObservable.prototype.getSubject = function () {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
    }
    return this._subject;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ConnectableObservable.prototype.refCount" id="apidoc.element.rxjs.ConnectableObservable.prototype.refCount">
        function <span class="apidocSignatureSpan">rxjs.ConnectableObservable.prototype.</span>refCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">refCount = function () {
    return this.lift(new RefCountOperator(this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// the RefCountSubscriber's downstream Observers synchronously unsubscribe,
// execution continues to here before the RefCountOperator has a chance to
// supply the RefCountSubscriber with the shared connection Subscription.
// For example:
// ```
// Observable.range(0, 10)
//   .publish()
//   .<span class="apidocCodeKeywordSpan">refCount</span>()
//   .take(5)
//   .subscribe();
// ```
// In order to account for this case, RefCountSubscriber should only dispose
// the ConnectableObservable's shared connection Subscription if the
// connection Subscription exists, *and* either:
//   a. RefCountSubscriber doesn't have a reference to the shared connection
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.DeferObservable" id="apidoc.module.rxjs.DeferObservable">module rxjs.DeferObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.DeferObservable.DeferObservable" id="apidoc.element.rxjs.DeferObservable.DeferObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>DeferObservable
        <span class="apidocSignatureSpan">(observableFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DeferObservable(observableFactory) {
    _super.call(this);
    this.observableFactory = observableFactory;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.EmptyError" id="apidoc.module.rxjs.EmptyError">module rxjs.EmptyError</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.EmptyError.EmptyError" id="apidoc.element.rxjs.EmptyError.EmptyError">
        function <span class="apidocSignatureSpan">rxjs.</span>EmptyError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EmptyError() {
    var err = _super.call(this, 'no elements in sequence');
    this.name = err.name = 'EmptyError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.EmptyError.captureStackTrace" id="apidoc.element.rxjs.EmptyError.captureStackTrace">
        function <span class="apidocSignatureSpan">rxjs.EmptyError.</span>captureStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureStackTrace() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.EmptyError.prototype" id="apidoc.module.rxjs.EmptyError.prototype">module rxjs.EmptyError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.EmptyError.prototype.constructor" id="apidoc.element.rxjs.EmptyError.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.EmptyError.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EmptyError() {
    var err = _super.call(this, 'no elements in sequence');
    this.name = err.name = 'EmptyError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.EmptyObservable" id="apidoc.module.rxjs.EmptyObservable">module rxjs.EmptyObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.EmptyObservable.EmptyObservable" id="apidoc.element.rxjs.EmptyObservable.EmptyObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>EmptyObservable
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EmptyObservable(scheduler) {
    _super.call(this);
    this.scheduler = scheduler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this._isScalar = true;
        this.value = arrayLike[0];
    }
}
ArrayLikeObservable.create = function (arrayLike, scheduler) {
    var length = arrayLike.length;
    if (length === 0) {
        return new EmptyObservable_1.<span class="apidocCodeKeywordSpan">EmptyObservable</span>();
    }
    else if (length === 1) {
        return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
    }
    else {
        return new ArrayLikeObservable(arrayLike, scheduler);
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ErrorObservable" id="apidoc.module.rxjs.ErrorObservable">module rxjs.ErrorObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ErrorObservable.ErrorObservable" id="apidoc.element.rxjs.ErrorObservable.ErrorObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>ErrorObservable
        <span class="apidocSignatureSpan">(error, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ErrorObservable(error, scheduler) {
    _super.call(this);
    this.error = error;
    this.scheduler = scheduler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.FastMap" id="apidoc.module.rxjs.FastMap">module rxjs.FastMap</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.FastMap.FastMap" id="apidoc.element.rxjs.FastMap.FastMap">
        function <span class="apidocSignatureSpan">rxjs.</span>FastMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FastMap() {
    this.values = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
    }
    this._group(value, key);
};
GroupBySubscriber.prototype._group = function (value, key) {
    var groups = this.groups;
    if (!groups) {
        groups = this.groups = typeof key === 'string' ? new FastMap_1.<span class="apidocCodeKeywordSpan">FastMap</span>() : new Map_1.Map();
    }
    var group = groups.get(key);
    var element;
    if (this.elementSelector) {
        try {
            element = this.elementSelector(value);
        }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ForkJoinObservable" id="apidoc.module.rxjs.ForkJoinObservable">module rxjs.ForkJoinObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ForkJoinObservable.ForkJoinObservable" id="apidoc.element.rxjs.ForkJoinObservable.ForkJoinObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>ForkJoinObservable
        <span class="apidocSignatureSpan">(sources, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ForkJoinObservable(sources, resultSelector) {
    _super.call(this);
    this.sources = sources;
    this.resultSelector = resultSelector;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.FromEventObservable" id="apidoc.module.rxjs.FromEventObservable">module rxjs.FromEventObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.FromEventObservable.FromEventObservable" id="apidoc.element.rxjs.FromEventObservable.FromEventObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>FromEventObservable
        <span class="apidocSignatureSpan">(sourceObj, eventName, selector, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FromEventObservable(sourceObj, eventName, selector, options) {
    _super.call(this);
    this.sourceObj = sourceObj;
    this.eventName = eventName;
    this.selector = selector;
    this.options = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.FromEventPatternObservable" id="apidoc.module.rxjs.FromEventPatternObservable">module rxjs.FromEventPatternObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.FromEventPatternObservable.FromEventPatternObservable" id="apidoc.element.rxjs.FromEventPatternObservable.FromEventPatternObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>FromEventPatternObservable
        <span class="apidocSignatureSpan">(addHandler, removeHandler, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FromEventPatternObservable(addHandler, removeHandler, selector) {
    _super.call(this);
    this.addHandler = addHandler;
    this.removeHandler = removeHandler;
    this.selector = selector;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.FromObservable" id="apidoc.module.rxjs.FromObservable">module rxjs.FromObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.FromObservable.FromObservable" id="apidoc.element.rxjs.FromObservable.FromObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>FromObservable
        <span class="apidocSignatureSpan">(ish, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FromObservable(ish, scheduler) {
    _super.call(this, null);
    this.ish = ish;
    this.scheduler = scheduler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    nextSources[_i - 0] = arguments[_i];
}
var source = null;
if (nextSources.length === 1 &amp;&amp; isArray_1.isArray(nextSources[0])) {
    nextSources = nextSources[0];
}
source = nextSources.shift();
return new FromObservable_1.<span class="apidocCodeKeywordSpan">FromObservable</span>(source, null).lift(new OnErrorResumeNextOperator
(nextSources));
}
exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
var OnErrorResumeNextOperator = (function () {
function OnErrorResumeNextOperator(nextSources) {
    this.nextSources = nextSources;
}
OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.GenerateObservable" id="apidoc.module.rxjs.GenerateObservable">module rxjs.GenerateObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.GenerateObservable.GenerateObservable" id="apidoc.element.rxjs.GenerateObservable.GenerateObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>GenerateObservable
        <span class="apidocSignatureSpan">(initialState, condition, iterate, resultSelector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {
    _super.call(this);
    this.initialState = initialState;
    this.condition = condition;
    this.iterate = iterate;
    this.resultSelector = resultSelector;
    this.scheduler = scheduler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.HotObservable" id="apidoc.module.rxjs.HotObservable">module rxjs.HotObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.HotObservable.HotObservable" id="apidoc.element.rxjs.HotObservable.HotObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>HotObservable
        <span class="apidocSignatureSpan">(messages, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HotObservable(messages, scheduler) {
    _super.call(this);
    this.messages = messages;
    this.subscriptions = [];
    this.scheduler = scheduler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return cold;
};
TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
    if (marbles.indexOf('!') !== -1) {
        throw new Error('hot observable cannot have unsubscription marker "!"');
    }
    var messages = TestScheduler.parseMarbles(marbles, values, error);
    var subject = new HotObservable_1.<span class="apidocCodeKeywordSpan">HotObservable</span>(messages, this);
    this.hotObservables.push(subject);
    return subject;
};
TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {
    var _this = this;
    var messages = [];
    observable.subscribe(function (value) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.IfObservable" id="apidoc.module.rxjs.IfObservable">module rxjs.IfObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.IfObservable.IfObservable" id="apidoc.element.rxjs.IfObservable.IfObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>IfObservable
        <span class="apidocSignatureSpan">(condition, thenSource, elseSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IfObservable(condition, thenSource, elseSource) {
    _super.call(this);
    this.condition = condition;
    this.thenSource = thenSource;
    this.elseSource = elseSource;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Immediate" id="apidoc.module.rxjs.Immediate">module rxjs.Immediate</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Immediate.ImmediateDefinition" id="apidoc.element.rxjs.Immediate.ImmediateDefinition">
        function <span class="apidocSignatureSpan">rxjs.Immediate.</span>ImmediateDefinition
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ImmediateDefinition(root) {
    this.root = root;
    if (root.setImmediate &amp;&amp; typeof root.setImmediate === 'function') {
        this.setImmediate = root.setImmediate.bind(root);
        this.clearImmediate = root.clearImmediate.bind(root);
    }
    else {
        this.nextHandle = 1;
        this.tasksByHandle = {};
        this.currentlyRunningATask = false;
        // Don't get fooled by e.g. browserify environments.
        if (this.canUseProcessNextTick()) {
            // For Node.js before 0.9
            this.setImmediate = this.createProcessNextTickSetImmediate();
        }
        else if (this.canUsePostMessage()) {
            // For non-IE10 modern browsers
            this.setImmediate = this.createPostMessageSetImmediate();
        }
        else if (this.canUseMessageChannel()) {
            // For web workers, where supported
            this.setImmediate = this.createMessageChannelSetImmediate();
        }
        else if (this.canUseReadyStateChange()) {
            // For IE 6â€“8
            this.setImmediate = this.createReadyStateChangeSetImmediate();
        }
        else {
            // For older browsers
            this.setImmediate = this.createSetTimeoutSetImmediate();
        }
        var ci = function clearImmediate(handle) {
            delete clearImmediate.instance.tasksByHandle[handle];
        };
        ci.instance = this;
        this.clearImmediate = ci;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.InnerSubscriber" id="apidoc.module.rxjs.InnerSubscriber">module rxjs.InnerSubscriber</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.InnerSubscriber.InnerSubscriber" id="apidoc.element.rxjs.InnerSubscriber.InnerSubscriber">
        function <span class="apidocSignatureSpan">rxjs.</span>InnerSubscriber
        <span class="apidocSignatureSpan">(parent, outerValue, outerIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function InnerSubscriber(parent, outerValue, outerIndex) {
    _super.call(this);
    this.parent = parent;
    this.outerValue = outerValue;
    this.outerIndex = outerIndex;
    this.index = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var isPromise_1 = require('./isPromise');
var isObject_1 = require('./isObject');
var Observable_1 = require('../Observable');
var iterator_1 = require('../symbol/iterator');
var InnerSubscriber_1 = require('../InnerSubscriber');
var observable_1 = require('../symbol/observable');
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
var destination = new InnerSubscriber_1.<span class="apidocCodeKeywordSpan">InnerSubscriber</span>(outerSubscriber, outerValue,
outerIndex);
if (destination.closed) {
    return null;
}
if (result instanceof Observable_1.Observable) {
    if (result._isScalar) {
        destination.next(result.value);
        destination.complete();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.IntervalObservable" id="apidoc.module.rxjs.IntervalObservable">module rxjs.IntervalObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.IntervalObservable.IntervalObservable" id="apidoc.element.rxjs.IntervalObservable.IntervalObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>IntervalObservable
        <span class="apidocSignatureSpan">(period, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IntervalObservable(period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async_1.async; }
    _super.call(this);
    this.period = period;
    this.scheduler = scheduler;
    if (!isNumeric_1.isNumeric(period) || period &lt; 0) {
        this.period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        this.scheduler = async_1.async;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.IteratorObservable" id="apidoc.module.rxjs.IteratorObservable">module rxjs.IteratorObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.IteratorObservable.IteratorObservable" id="apidoc.element.rxjs.IteratorObservable.IteratorObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>IteratorObservable
        <span class="apidocSignatureSpan">(iterator, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IteratorObservable(iterator, scheduler) {
    _super.call(this);
    this.scheduler = scheduler;
    if (iterator == null) {
        throw new Error('iterator cannot be null.');
    }
    this.iterator = getIterator(iterator);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        else if (isArray_1.isArray(ish)) {
            return new ArrayObservable_1.ArrayObservable(ish, scheduler);
        }
        else if (isPromise_1.isPromise(ish)) {
            return new PromiseObservable_1.PromiseObservable(ish, scheduler);
        }
        else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
            return new IteratorObservable_1.<span class="apidocCodeKeywordSpan">IteratorObservable</span>(ish, scheduler);
        }
        else if (isArrayLike_1.isArrayLike(ish)) {
            return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
        }
    }
    throw new TypeError((ish !== null &amp;&amp; typeof ish || ish) + ' is not observable');
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Map" id="apidoc.module.rxjs.Map">module rxjs.Map</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Map.Map" id="apidoc.element.rxjs.Map.Map">
        function <span class="apidocSignatureSpan">rxjs.</span>Map
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Map() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return;
    }
    this._group(value, key);
};
GroupBySubscriber.prototype._group = function (value, key) {
    var groups = this.groups;
    if (!groups) {
        groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.<span class="apidocCodeKeywordSpan
">Map</span>();
    }
    var group = groups.get(key);
    var element;
    if (this.elementSelector) {
        try {
            element = this.elementSelector(value);
        }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.MapPolyfill" id="apidoc.module.rxjs.MapPolyfill">module rxjs.MapPolyfill</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.MapPolyfill.MapPolyfill" id="apidoc.element.rxjs.MapPolyfill.MapPolyfill">
        function <span class="apidocSignatureSpan">rxjs.</span>MapPolyfill
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MapPolyfill() {
    this.size = 0;
    this._values = [];
    this._keys = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.NeverObservable" id="apidoc.module.rxjs.NeverObservable">module rxjs.NeverObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.NeverObservable.NeverObservable" id="apidoc.element.rxjs.NeverObservable.NeverObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>NeverObservable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NeverObservable() {
    _super.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Notification" id="apidoc.module.rxjs.Notification">module rxjs.Notification</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Notification.Notification" id="apidoc.element.rxjs.Notification.Notification">
        function <span class="apidocSignatureSpan">rxjs.</span>Notification
        <span class="apidocSignatureSpan">(kind, value, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Notification(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === 'N';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `error`. Such Observable is the output of a `materialize` operation. Those
* notifications are then unwrapped using the metadata they contain, and emitted
* as `next`, `error`, and `complete` on the output Observable.
*
* Use this operator in conjunction with {@link materialize}.
*
* @example &lt;caption&gt;Convert an Observable of Notifications to an actual Observable&lt;/caption&gt;
* var notifA = new Rx.<span class="apidocCodeKeywordSpan">Notification</span>('N', 'A');
* var notifB = new Rx.Notification('N', 'B');
* var notifE = new Rx.Notification('E', void 0,
*   new TypeError('x.toUpperCase is not a function')
* );
* var materialized = Rx.Observable.of(notifA, notifB, notifE);
* var upperCase = materialized.dematerialize();
* upperCase.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Notification.createComplete" id="apidoc.element.rxjs.Notification.createComplete">
        function <span class="apidocSignatureSpan">rxjs.Notification.</span>createComplete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createComplete = function () {
    return this.completeNotification;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
DelaySubscriber.prototype._error = function (err) {
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
};
DelaySubscriber.prototype._complete = function () {
    this.scheduleNotification(Notification_1.Notification.<span class="apidocCodeKeywordSpan">createComplete</span>());
};
return DelaySubscriber;
}(Subscriber_1.Subscriber));
var DelayMessage = (function () {
function DelayMessage(time, notification) {
    this.time = time;
    this.notification = notification;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Notification.createError" id="apidoc.element.rxjs.Notification.createError">
        function <span class="apidocSignatureSpan">rxjs.Notification.</span>createError
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createError = function (err) {
    return new Notification('E', undefined, err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    _super.call(this, destination);
}
MaterializeSubscriber.prototype._next = function (value) {
    this.destination.next(Notification_1.Notification.createNext(value));
};
MaterializeSubscriber.prototype._error = function (err) {
    var destination = this.destination;
    destination.next(Notification_1.Notification.<span class="apidocCodeKeywordSpan">createError</span>(err));
    destination.complete();
};
MaterializeSubscriber.prototype._complete = function () {
    var destination = this.destination;
    destination.next(Notification_1.Notification.createComplete());
    destination.complete();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Notification.createNext" id="apidoc.element.rxjs.Notification.createNext">
        function <span class="apidocSignatureSpan">rxjs.Notification.</span>createNext
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createNext = function (value) {
    if (typeof value !== 'undefined') {
        return new Notification('N', value);
    }
    return this.undefinedValueNotification;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var message = new DelayMessage(scheduler.now() + this.delay, notification);
    this.queue.push(message);
    if (this.active === false) {
        this._schedule(scheduler);
    }
};
DelaySubscriber.prototype._next = function (value) {
    this.scheduleNotification(Notification_1.Notification.<span class="apidocCodeKeywordSpan">createNext</span>(value));
};
DelaySubscriber.prototype._error = function (err) {
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
};
DelaySubscriber.prototype._complete = function () {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Notification.prototype" id="apidoc.module.rxjs.Notification.prototype">module rxjs.Notification.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Notification.prototype.accept" id="apidoc.element.rxjs.Notification.prototype.accept">
        function <span class="apidocSignatureSpan">rxjs.Notification.prototype.</span>accept
        <span class="apidocSignatureSpan">(nextOrObserver, error, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accept = function (nextOrObserver, error, complete) {
    if (nextOrObserver &amp;&amp; typeof nextOrObserver.next === 'function') {
        return this.observe(nextOrObserver);
    }
    else {
        return this.do(nextOrObserver, error, complete);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Notification.prototype.do" id="apidoc.element.rxjs.Notification.prototype.do">
        function <span class="apidocSignatureSpan">rxjs.Notification.prototype.</span>do
        <span class="apidocSignatureSpan">(next, error, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">do = function (next, error, complete) {
    var kind = this.kind;
    switch (kind) {
        case 'N':
            return next &amp;&amp; next(this.value);
        case 'E':
            return error &amp;&amp; error(this.error);
        case 'C':
            return complete &amp;&amp; complete();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {any}
 */
Notification.prototype.accept = function (nextOrObserver, error, complete) {
    if (nextOrObserver &amp;&amp; typeof nextOrObserver.next === 'function') {
        return this.observe(nextOrObserver);
    }
    else {
        return this.<span class="apidocCodeKeywordSpan">do</span>(nextOrObserver, error, complete);
    }
};
/**
 * Returns a simple Observable that just delivers the notification represented
 * by this Notification instance.
 * @return {any}
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Notification.prototype.observe" id="apidoc.element.rxjs.Notification.prototype.observe">
        function <span class="apidocSignatureSpan">rxjs.Notification.prototype.</span>observe
        <span class="apidocSignatureSpan">(observer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observe = function (observer) {
    switch (this.kind) {
        case 'N':
            return observer.next &amp;&amp; observer.next(this.value);
        case 'E':
            return observer.error &amp;&amp; observer.error(this.error);
        case 'C':
            return observer.complete &amp;&amp; observer.complete();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * the `next` callback.
 * @param {function(err: any): void} [error] An Observer `error` callback.
 * @param {function(): void} [complete] An Observer `complete` callback.
 * @return {any}
 */
Notification.prototype.accept = function (nextOrObserver, error, complete) {
    if (nextOrObserver &amp;&amp; typeof nextOrObserver.next === 'function') {
        return this.<span class="apidocCodeKeywordSpan">observe</span>(nextOrObserver);
    }
    else {
        return this.do(nextOrObserver, error, complete);
    }
};
/**
 * Returns a simple Observable that just delivers the notification represented
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Notification.prototype.toObservable" id="apidoc.element.rxjs.Notification.prototype.toObservable">
        function <span class="apidocSignatureSpan">rxjs.Notification.prototype.</span>toObservable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObservable = function () {
    var kind = this.kind;
    switch (kind) {
        case 'N':
            return Observable_1.Observable.of(this.value);
        case 'E':
            return Observable_1.Observable.throw(this.error);
        case 'C':
            return Observable_1.Observable.empty();
    }
    throw new Error('unexpected notification kind value');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ObjectUnsubscribedError" id="apidoc.module.rxjs.ObjectUnsubscribedError">module rxjs.ObjectUnsubscribedError</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ObjectUnsubscribedError.ObjectUnsubscribedError" id="apidoc.element.rxjs.ObjectUnsubscribedError.ObjectUnsubscribedError">
        function <span class="apidocSignatureSpan">rxjs.</span>ObjectUnsubscribedError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectUnsubscribedError() {
    var err = _super.call(this, 'object unsubscribed');
    this.name = err.name = 'ObjectUnsubscribedError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return subscription;
};
BehaviorSubject.prototype.getValue = function () {
    if (this.hasError) {
        throw this.thrownError;
    }
    else if (this.closed) {
        throw new ObjectUnsubscribedError_1.<span class="apidocCodeKeywordSpan">ObjectUnsubscribedError</span>();
    }
    else {
        return this._value;
    }
};
BehaviorSubject.prototype.next = function (value) {
    _super.prototype.next.call(this, this._value = value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ObjectUnsubscribedError.captureStackTrace" id="apidoc.element.rxjs.ObjectUnsubscribedError.captureStackTrace">
        function <span class="apidocSignatureSpan">rxjs.ObjectUnsubscribedError.</span>captureStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureStackTrace() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ObjectUnsubscribedError.prototype" id="apidoc.module.rxjs.ObjectUnsubscribedError.prototype">module rxjs.ObjectUnsubscribedError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ObjectUnsubscribedError.prototype.constructor" id="apidoc.element.rxjs.ObjectUnsubscribedError.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.ObjectUnsubscribedError.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectUnsubscribedError() {
    var err = _super.call(this, 'object unsubscribed');
    this.name = err.name = 'ObjectUnsubscribedError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Observable" id="apidoc.module.rxjs.Observable">module rxjs.Observable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Observable.Observable" id="apidoc.element.rxjs.Observable.Observable">
        function <span class="apidocSignatureSpan">rxjs.</span>Observable
        <span class="apidocSignatureSpan">(subscribe)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Observable(subscribe) {
    this._isScalar = false;
    if (subscribe) {
        this._subscribe = subscribe;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    else {
        this.observers.push(subscriber);
        return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
    }
};
Subject.prototype.asObservable = function () {
    var observable = new Observable_1.<span class="apidocCodeKeywordSpan">Observable</span>();
    observable.source = this;
    return observable;
};
Subject.create = function (destination, source) {
    return new AnonymousSubject(destination, source);
};
return Subject;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.ajax" id="apidoc.element.rxjs.Observable.ajax">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>ajax
        <span class="apidocSignatureSpan">(urlOrRequest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ajax = function (urlOrRequest) {
    return new AjaxObservable(urlOrRequest);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.bindCallback" id="apidoc.element.rxjs.Observable.bindCallback">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>bindCallback
        <span class="apidocSignatureSpan">(func, selector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindCallback = function (func, selector, scheduler) {
    if (selector === void 0) { selector = undefined; }
    return function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        return new BoundCallbackObservable(func, selector, args, this, scheduler);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* provides convenient error handling and probably is a better choice.
* `bindCallback` will treat such functions without any difference and error parameter
* (whether passed or not) will always be interpreted as regular callback argument.
*
*
* @example &lt;caption&gt;Convert jQuery's getJSON to an Observable API&lt;/caption&gt;
* // Suppose we have jQuery.getJSON('/my/url', callback)
* var getJSONAsObservable = Rx.Observable.<span class="apidocCodeKeywordSpan">bindCallback</span>(jQuery.getJSON);
* var result = getJSONAsObservable('/my/url');
* result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
*
*
* @example &lt;caption&gt;Receive array of arguments passed to callback&lt;/caption&gt;
* someFunction((a, b, c) =&gt; {
*   console.log(a); // 5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.bindNodeCallback" id="apidoc.element.rxjs.Observable.bindNodeCallback">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>bindNodeCallback
        <span class="apidocSignatureSpan">(func, selector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindNodeCallback = function (func, selector, scheduler) {
    if (selector === void 0) { selector = undefined; }
    return function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Note that even if error parameter is technically present in callback, but its value
* is falsy, it still won't appear in array emitted by Observable or in selector function.
*
*
* @example &lt;caption&gt;Read a file from the filesystem and get the data as an Observable&lt;/caption&gt;
* import * as fs from 'fs';
* var readFileAsObservable = Rx.Observable.<span class="apidocCodeKeywordSpan">bindNodeCallback</span>(fs.readFile);
* var result = readFileAsObservable('./roadNames.txt', 'utf8');
* result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
*
*
* @example &lt;caption&gt;Use on function calling callback with multiple arguments&lt;/caption&gt;
* someFunction((err, a, b) =&gt; {
*   console.log(err); // null
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.combineLatest" id="apidoc.element.rxjs.Observable.combineLatest">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>combineLatest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function combineLatest() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 &amp;&amp; isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* of values, but values themselves. That means default `project` can be imagined
* as function that takes all its arguments and puts them into an array.
*
*
* @example &lt;caption&gt;Combine two timer Observables&lt;/caption&gt;
* const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
* const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
* const combinedTimers = Rx.Observable.<span class="apidocCodeKeywordSpan">combineLatest</span>(firstTimer, secondTimer);
* combinedTimers.subscribe(value =&gt; console.log(value));
* // Logs
* // [0, 0] after 0.5s
* // [1, 0] after 1s
* // [1, 1] after 1.5s
* // [2, 1] after 2s
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.concat" id="apidoc.element.rxjs.Observable.concat">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatStatic() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var scheduler = null;
    var args = observables;
    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
        scheduler = args.pop();
    }
    if (scheduler === null &amp;&amp; observables.length === 1 &amp;&amp; observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (isObject_1.isObject(sub)) {
        var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
        if (trial === errorObject_1.errorObject) {
            hasErrors = true;
            errors = errors || [];
            var err = errorObject_1.errorObject.e;
            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                errors = errors.<span class="apidocCodeKeywordSpan">concat</span>(flattenUnsubscriptionErrors(err.errors));
            }
            else {
                errors.push(err);
            }
        }
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.create" id="apidoc.element.rxjs.Observable.create">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>create
        <span class="apidocSignatureSpan">(subscribe)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (subscribe) {
    return new Observable(subscribe);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



"use strict";
var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.<span class="apidocCodeKeywordSpan">create</span>(b) : (__.prototype = b.prototype, new __
());
};
var Subject_1 = require('./Subject');
var Subscription_1 = require('./Subscription');
/**
 * @class AsyncSubject&lt;T&gt;
 */
var AsyncSubject = (function (_super) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.defer" id="apidoc.element.rxjs.Observable.defer">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>defer
        <span class="apidocSignatureSpan">(observableFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defer = function (observableFactory) {
    return new DeferObservable(observableFactory);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* an Observer subscribes to it, and then it generates an Observable,
* typically with an Observable factory function. It does this afresh for each
* subscriber, so although each subscriber may think it is subscribing to the
* same Observable, in fact each subscriber gets its own individual
* Observable.
*
* @example &lt;caption&gt;Subscribe to either an Observable of clicks or an Observable of interval, at random&lt;/caption&amp;#
x3e;
* var clicksOrInterval = Rx.Observable.<span class="apidocCodeKeywordSpan">defer</span>(function () {
*   if (Math.random() &gt; 0.5) {
*     return Rx.Observable.fromEvent(document, 'click');
*   } else {
*     return Rx.Observable.interval(1000);
*   }
* });
* clicksOrInterval.subscribe(x =&gt; console.log(x));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.empty" id="apidoc.element.rxjs.Observable.empty">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>empty
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function (scheduler) {
    return new EmptyObservable(scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var kind = this.kind;
    switch (kind) {
        case 'N':
            return Observable_1.Observable.of(this.value);
        case 'E':
            return Observable_1.Observable.throw(this.error);
        case 'C':
            return Observable_1.Observable.<span class="apidocCodeKeywordSpan">empty</span>();
    }
    throw new Error('unexpected notification kind value');
};
/**
 * A shortcut to create a Notification instance of the type `next` from a
 * given value.
 * @param {T} value The `next` value.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.forkJoin" id="apidoc.element.rxjs.Observable.forkJoin">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>forkJoin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forkJoin = function () {
    var sources = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        sources[_i - 0] = arguments[_i];
    }
    if (sources === null || arguments.length === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    var resultSelector = null;
    if (typeof sources[sources.length - 1] === 'function') {
        resultSelector = sources.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`
    if (sources.length === 1 &amp;&amp; isArray_1.isArray(sources[0])) {
        sources = sources[0];
    }
    if (sources.length === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    return new ForkJoinObservable(sources, resultSelector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.from" id="apidoc.element.rxjs.Observable.from">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>from
        <span class="apidocSignatureSpan">(ish, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (ish, scheduler) {
    if (ish != null) {
        if (typeof ish[observable_1.$$observable] === 'function') {
            if (ish instanceof Observable_1.Observable &amp;&amp; !scheduler) {
                return ish;
            }
            return new FromObservable(ish, scheduler);
        }
        else if (isArray_1.isArray(ish)) {
            return new ArrayObservable_1.ArrayObservable(ish, scheduler);
        }
        else if (isPromise_1.isPromise(ish)) {
            return new PromiseObservable_1.PromiseObservable(ish, scheduler);
        }
        else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
            return new IteratorObservable_1.IteratorObservable(ish, scheduler);
        }
        else if (isArrayLike_1.isArrayLike(ish)) {
            return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
        }
    }
    throw new TypeError((ish !== null &amp;&amp; typeof ish || ish) + ' is not observable');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* object into an Observable that emits the items in that promise or array or
* iterable. A String, in this context, is treated as an array of characters.
* Observable-like objects (contains a function named with the ES2015 Symbol
* for Observable) can also be converted through this operator.
*
* @example &lt;caption&gt;Converts an array to an Observable&lt;/caption&gt;
* var array = [10, 20, 30];
* var result = Rx.Observable.<span class="apidocCodeKeywordSpan">from</span>(array);
* result.subscribe(x =&gt; console.log(x));
*
* // Results in the following:
* // 10 20 30
*
* @example &lt;caption&gt;Convert an infinite iterable (from a generator) to an Observable&lt;/caption&gt;
* function* generateDoubles(seed) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.fromEvent" id="apidoc.element.rxjs.Observable.fromEvent">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>fromEvent
        <span class="apidocSignatureSpan">(target, eventName, options, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEvent = function (target, eventName, options, selector) {
    if (isFunction_1.isFunction(options)) {
        selector = options;
        options = undefined;
    }
    return new FromEventObservable(target, eventName, selector, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* subscriber, so although each subscriber may think it is subscribing to the
* same Observable, in fact each subscriber gets its own individual
* Observable.
*
* @example &lt;caption&gt;Subscribe to either an Observable of clicks or an Observable of interval, at random&lt;/caption&amp;#
x3e;
* var clicksOrInterval = Rx.Observable.defer(function () {
*   if (Math.random() &gt; 0.5) {
*     return Rx.Observable.<span class="apidocCodeKeywordSpan">fromEvent</span>(document, 'click');
*   } else {
*     return Rx.Observable.interval(1000);
*   }
* });
* clicksOrInterval.subscribe(x =&gt; console.log(x));
*
* // Results in the following behavior:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.fromEventPattern" id="apidoc.element.rxjs.Observable.fromEventPattern">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>fromEventPattern
        <span class="apidocSignatureSpan">(addHandler, removeHandler, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEventPattern = function (addHandler, removeHandler, selector) {
    return new FromEventPatternObservable(addHandler, removeHandler, selector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*   document.addEventListener('click', handler);
* }
*
* function removeClickHandler(handler) {
*   document.removeEventListener('click', handler);
* }
*
* var clicks = Rx.Observable.<span class="apidocCodeKeywordSpan">fromEventPattern</span>(
*   addClickHandler,
*   removeClickHandler
* );
* clicks.subscribe(x =&gt; console.log(x));
*
* @see {@link from}
* @see {@link fromEvent}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.fromPromise" id="apidoc.element.rxjs.Observable.fromPromise">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>fromPromise
        <span class="apidocSignatureSpan">(promise, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromPromise = function (promise, scheduler) {
    return new PromiseObservable(promise, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
* Observable. If the Promise resolves with a value, the output Observable
* emits that resolved value as a `next`, and then completes. If the Promise
* is rejected, then the output Observable emits the corresponding Error.
*
* @example &lt;caption&gt;Convert the Promise returned by Fetch to an Observable&lt;/caption&gt;
* var result = Rx.Observable.<span class="apidocCodeKeywordSpan">fromPromise</span>(fetch('http://myserver.com/'));
* result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
*
* @see {@link bindCallback}
* @see {@link from}
*
* @param {Promise&lt;T&gt;} promise The promise to be converted.
* @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.generate" id="apidoc.element.rxjs.Observable.generate">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>generate
        <span class="apidocSignatureSpan">(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    if (arguments.length == 1) {
        return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions
.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);
    }
    if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
        return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);
    }
    return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.if" id="apidoc.element.rxjs.Observable.if">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>if
        <span class="apidocSignatureSpan">(condition, thenSource, elseSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">if = function (condition, thenSource, elseSource) {
    return new IfObservable(condition, thenSource, elseSource);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.interval" id="apidoc.element.rxjs.Observable.interval">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>interval
        <span class="apidocSignatureSpan">(period, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interval = function (period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async_1.async; }
    return new IntervalObservable(period, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* By default, it uses a `null` IScheduler, which means the `next`
* notifications are sent synchronously, although with a different IScheduler
* it is possible to determine when those notifications will be delivered.
*
* @example &lt;caption&gt;Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second
.&lt;/caption&gt;
* var numbers = Rx.Observable.of(10, 20, 30);
* var letters = Rx.Observable.of('a', 'b', 'c');
* var interval = Rx.Observable.<span class="apidocCodeKeywordSpan">interval</span>(1000);
* var result = numbers.concat(letters).concat(interval);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link create}
* @see {@link empty}
* @see {@link never}
* @see {@link throw}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.merge" id="apidoc.element.rxjs.Observable.merge">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeStatic() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length &gt; 1 &amp;&amp; typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null &amp;&amp; observables.length === 1 &amp;&amp; observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.never" id="apidoc.element.rxjs.Observable.never">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>never
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">never = function () {
    return new NeverObservable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* subscription from being disposed automatically. Subscriptions need to be
* manually disposed.
*
* @example &lt;caption&gt;Emit the number 7, then never emit anything else (not even complete).&lt;/caption&gt;
* function info() {
*   console.log('Will not be called');
* }
* var result = Rx.Observable.<span class="apidocCodeKeywordSpan">never</span>().startWith(7);
* result.subscribe(x =&gt; console.log(x), info, info);
*
* @see {@link create}
* @see {@link empty}
* @see {@link of}
* @see {@link throw}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.of" id="apidoc.element.rxjs.Observable.of">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {
    var array = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
    }
    else {
        scheduler = null;
    }
    var len = array.length;
    if (len &gt; 1) {
        return new ArrayObservable(array, scheduler);
    }
    else if (len === 1) {
        return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
    }
    else {
        return new EmptyObservable_1.EmptyObservable(scheduler);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

To import the entire core set of functionality:

```js
import Rx from 'rxjs/Rx';

Rx.Observable.<span class="apidocCodeKeywordSpan">of</span>(1,2,3)
```

To import only what you need by patching (this is useful for size-sensitive bundling):

```js
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.onErrorResumeNext" id="apidoc.element.rxjs.Observable.onErrorResumeNext">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>onErrorResumeNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    var source = null;
    if (nextSources.length === 1 &amp;&amp; isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.pairs" id="apidoc.element.rxjs.Observable.pairs">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>pairs
        <span class="apidocSignatureSpan">(obj, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pairs = function (obj, scheduler) {
    return new PairsObservable(obj, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @example &lt;caption&gt;Converts a javascript object to an Observable&lt;/caption&gt;
* var obj = {
*   foo: 42,
*   bar: 56,
*   baz: 78
* };
*
* var source = Rx.Observable.<span class="apidocCodeKeywordSpan">pairs</span>(obj);
*
* var subscription = source.subscribe(
*   function (x) {
*     console.log('Next: %s', x);
*   },
*   function (err) {
*     console.log('Error: %s', err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.race" id="apidoc.element.rxjs.Observable.race">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>race
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function raceStatic() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `pair([obs1, obs2, ...])`
    if (observables.length === 1) {
        if (isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.range" id="apidoc.element.rxjs.Observable.range">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>range
        <span class="apidocSignatureSpan">(start, count, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">range = function (start, count, scheduler) {
    if (start === void 0) { start = 0; }
    if (count === void 0) { count = 0; }
    return new RangeObservable(start, count, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// connection Subscription on the shared ConnectableObservable. In cases
// where the ConnectableObservable source synchronously emits values, and
// the RefCountSubscriber's downstream Observers synchronously unsubscribe,
// execution continues to here before the RefCountOperator has a chance to
// supply the RefCountSubscriber with the shared connection Subscription.
// For example:
// ```
// Observable.<span class="apidocCodeKeywordSpan">range</span>(0, 10)
//   .publish()
//   .refCount()
//   .take(5)
//   .subscribe();
// ```
// In order to account for this case, RefCountSubscriber should only dispose
// the ConnectableObservable's shared connection Subscription if the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.throw" id="apidoc.element.rxjs.Observable.throw">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>throw
        <span class="apidocSignatureSpan">(error, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throw = function (error, scheduler) {
    return new ErrorObservable(error, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Notification.prototype.toObservable = function () {
    var kind = this.kind;
    switch (kind) {
        case 'N':
            return Observable_1.Observable.of(this.value);
        case 'E':
            return Observable_1.Observable.<span class="apidocCodeKeywordSpan">throw</span>(this.error);
        case 'C':
            return Observable_1.Observable.empty();
    }
    throw new Error('unexpected notification kind value');
};
/**
 * A shortcut to create a Notification instance of the type `next` from a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.timer" id="apidoc.element.rxjs.Observable.timer">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>timer
        <span class="apidocSignatureSpan">(initialDelay, period, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timer = function (initialDelay, period, scheduler) {
    if (initialDelay === void 0) { initialDelay = 0; }
    return new TimerObservable(initialDelay, period, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `initialDelay`. The initial delay may be a {@link Date}. By default, this
* operator uses the `async` IScheduler to provide a notion of time, but you
* may pass any IScheduler to it. If `period` is not specified, the output
* Observable emits only one value, `0`. Otherwise, it emits an infinite
* sequence.
*
* @example &lt;caption&gt;Emits ascending numbers, one every second (1000ms), starting after 3 seconds&lt;/caption&gt;
* var numbers = Rx.Observable.<span class="apidocCodeKeywordSpan">timer</span>(3000, 1000);
* numbers.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Emits one number after five seconds&lt;/caption&gt;
* var numbers = Rx.Observable.timer(5000);
* numbers.subscribe(x =&gt; console.log(x));
*
* @see {@link interval}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.using" id="apidoc.element.rxjs.Observable.using">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>using
        <span class="apidocSignatureSpan">(resourceFactory, observableFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">using = function (resourceFactory, observableFactory) {
    return new UsingObservable(resourceFactory, observableFactory);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.webSocket" id="apidoc.element.rxjs.Observable.webSocket">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>webSocket
        <span class="apidocSignatureSpan">(urlConfigOrSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">webSocket = function (urlConfigOrSource) {
    return new WebSocketSubject(urlConfigOrSource);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.zip" id="apidoc.element.rxjs.Observable.zip">
        function <span class="apidocSignatureSpan">rxjs.Observable.</span>zip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zipStatic() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Observable.prototype" id="apidoc.module.rxjs.Observable.prototype">module rxjs.Observable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype._catch" id="apidoc.element.rxjs.Observable.prototype._catch">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>_catch
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _catch(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return (operator.caught = caught);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype._do" id="apidoc.element.rxjs.Observable.prototype._do">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>_do
        <span class="apidocSignatureSpan">(nextOrObserver, error, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _do(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype._finally" id="apidoc.element.rxjs.Observable.prototype._finally">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>_finally
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _finally(callback) {
    return this.lift(new FinallyOperator(callback));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype._subscribe" id="apidoc.element.rxjs.Observable.prototype._subscribe">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(subscriber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (subscriber) {
    return this.source.subscribe(subscriber);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            throw sink.syncErrorValue;
        }
    }
    return sink;
};
Observable.prototype._trySubscribe = function (sink) {
    try {
        return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(sink);
    }
    catch (err) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
        sink.error(err);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype._switch" id="apidoc.element.rxjs.Observable.prototype._switch">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>_switch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _switch() {
    return this.lift(new SwitchOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype._trySubscribe" id="apidoc.element.rxjs.Observable.prototype._trySubscribe">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>_trySubscribe
        <span class="apidocSignatureSpan">(sink)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_trySubscribe = function (sink) {
    try {
        return this._subscribe(sink);
    }
    catch (err) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
        sink.error(err);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
var operator = this.operator;
var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
if (operator) {
    operator.call(sink, this.source);
}
else {
    sink.add(this.<span class="apidocCodeKeywordSpan">_trySubscribe</span>(sink));
}
if (sink.syncErrorThrowable) {
    sink.syncErrorThrowable = false;
    if (sink.syncErrorThrown) {
        throw sink.syncErrorValue;
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.audit" id="apidoc.element.rxjs.Observable.prototype.audit">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>audit
        <span class="apidocSignatureSpan">(durationSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function audit(durationSelector) {
    return this.lift(new AuditOperator(durationSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* source value, which returns the "duration" Observable. When the duration
* Observable emits a value or completes, the timer is disabled, then the most
* recent source value is emitted on the output Observable, and this process
* repeats for the next source value.
*
* @example &lt;caption&gt;Emit clicks at a rate of at most one click per second&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">audit</span>(ev =&gt; Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link auditTime}
* @see {@link debounce}
* @see {@link delayWhen}
* @see {@link sample}
* @see {@link throttle}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.auditTime" id="apidoc.element.rxjs.Observable.prototype.auditTime">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>auditTime
        <span class="apidocSignatureSpan">(duration, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function auditTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new AuditTimeOperator(duration, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the time unit determined internally by the optional `scheduler`) has passed,
* the timer is disabled, then the most recent source value is emitted on the
* output Observable, and this process repeats for the next source value.
* Optionally takes a {@link IScheduler} for managing timers.
*
* @example &lt;caption&gt;Emit clicks at a rate of at most one click per second&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">auditTime</span>(1000);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link audit}
* @see {@link debounceTime}
* @see {@link delay}
* @see {@link sampleTime}
* @see {@link throttleTime}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.buffer" id="apidoc.element.rxjs.Observable.prototype.buffer">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>buffer
        <span class="apidocSignatureSpan">(closingNotifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buffer(closingNotifier) {
    return this.lift(new BufferOperator(closingNotifier));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Observable emits a value, at which point it emits the buffer on the output
* Observable and starts a new buffer internally, awaiting the next time
* `closingNotifier` emits.
*
* @example &lt;caption&gt;On every click, emit array of most recent interval events&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var interval = Rx.Observable.interval(1000);
* var buffered = interval.<span class="apidocCodeKeywordSpan">buffer</span>(clicks);
* buffered.subscribe(x =&gt; console.log(x));
*
* @see {@link bufferCount}
* @see {@link bufferTime}
* @see {@link bufferToggle}
* @see {@link bufferWhen}
* @see {@link window}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.bufferCount" id="apidoc.element.rxjs.Observable.prototype.bufferCount">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>bufferCount
        <span class="apidocSignatureSpan">(bufferSize, startBufferEvery)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) { startBufferEvery = null; }
    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* emits the buffer and clears it, and starts a new buffer each
* `startBufferEvery` values. If `startBufferEvery` is not provided or is
* `null`, then new buffers are started immediately at the start of the source
* and when each buffer closes and is emitted.
*
* @example &lt;caption&gt;Emit the last two click events as an array&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var buffered = clicks.<span class="apidocCodeKeywordSpan">bufferCount</span>(2);
* buffered.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;On every click, emit the last two click events as an array&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var buffered = clicks.bufferCount(2, 1);
* buffered.subscribe(x =&gt; console.log(x));
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.bufferTime" id="apidoc.element.rxjs.Observable.prototype.bufferTime">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>bufferTime
        <span class="apidocSignatureSpan">(bufferTimeSpan)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = async_1.async;
    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length &gt;= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length &gt;= 3) {
        maxBufferSize = arguments[2];
    }
    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `bufferCreationInterval` milliseconds and closes (emits and resets) the
* buffer every `bufferTimeSpan` milliseconds. When the optional argument
* `maxBufferSize` is specified, the buffer will be closed either after
* `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
*
* @example &lt;caption&gt;Every second, emit an array of the recent click events&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var buffered = clicks.<span class="apidocCodeKeywordSpan">bufferTime</span>(1000);
* buffered.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Every 5 seconds, emit the click events from the next 2 seconds&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var buffered = clicks.bufferTime(2000, 5000);
* buffered.subscribe(x =&gt; console.log(x));
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.bufferToggle" id="apidoc.element.rxjs.Observable.prototype.bufferToggle">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>bufferToggle
        <span class="apidocSignatureSpan">(openings, closingSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bufferToggle(openings, closingSelector) {
    return this.lift(new BufferToggleOperator(openings, closingSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Buffers values from the source by opening the buffer via signals from an
* Observable provided to `openings`, and closing and sending the buffers when
* a Subscribable or Promise returned by the `closingSelector` function emits.
*
* @example &lt;caption&gt;Every other second, emit the click events from the next 500ms&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var openings = Rx.Observable.interval(1000);
* var buffered = clicks.<span class="apidocCodeKeywordSpan">bufferToggle</span>(openings, i =&gt;
*   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
* );
* buffered.subscribe(x =&gt; console.log(x));
*
* @see {@link buffer}
* @see {@link bufferCount}
* @see {@link bufferTime}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.bufferWhen" id="apidoc.element.rxjs.Observable.prototype.bufferWhen">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>bufferWhen
        <span class="apidocSignatureSpan">(closingSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bufferWhen(closingSelector) {
    return this.lift(new BufferWhenOperator(closingSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Opens a buffer immediately, then closes the buffer when the observable
* returned by calling `closingSelector` function emits a value. When it closes
* the buffer, it immediately opens a new buffer and repeats the process.
*
* @example &lt;caption&gt;Emit an array of the last clicks every [1-5] random seconds&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var buffered = clicks.<span class="apidocCodeKeywordSpan">bufferWhen</span>(() =&gt;
*   Rx.Observable.interval(1000 + Math.random() * 4000)
* );
* buffered.subscribe(x =&gt; console.log(x));
*
* @see {@link buffer}
* @see {@link bufferCount}
* @see {@link bufferTime}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.catch" id="apidoc.element.rxjs.Observable.prototype.catch">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>catch
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _catch(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return (operator.caught = caught);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Observable.of(1, 2, 3, 4, 5)
*   .map(n =&gt; {
* 	   if (n == 4) {
* 	     throw 'four!';
*     }
*	   return n;
*   })
*   .<span class="apidocCodeKeywordSpan">catch</span>(err =&gt; Observable.of('I', 'II', 'III', &amp;#
x27;IV', 'V'))
*   .subscribe(x =&gt; console.log(x));
*   // 1, 2, 3, I, II, III, IV, V
*
* @example &lt;caption&gt;Retries the caught source Observable again in case of error, similar to retry() operator&lt;/caption
&gt;
*
* Observable.of(1, 2, 3, 4, 5)
*   .map(n =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.combineAll" id="apidoc.element.rxjs.Observable.prototype.combineAll">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>combineAll
        <span class="apidocSignatureSpan">(project)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function combineAll(project) {
    return this.lift(new combineLatest_1.CombineLatestOperator(project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     values is emitted by the output Observable.
*
* @example &lt;caption&gt;Map two click events to a finite interval Observable, then apply combineAll&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var higherOrder = clicks.map(ev =&gt;
*   Rx.Observable.interval(Math.random()*2000).take(3)
* ).take(2);
* var result = higherOrder.<span class="apidocCodeKeywordSpan">combineAll</span>();
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link combineLatest}
* @see {@link mergeAll}
*
* @param {function} [project] An optional function to map the most recent
* values from each inner Observable into a new result. Takes each of the most
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.combineLatest" id="apidoc.element.rxjs.Observable.prototype.combineLatest">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>combineLatest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function combineLatest() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 &amp;&amp; isArray_1.isArray(observables[0])) {
        observables = observables[0].slice();
    }
    observables.unshift(this);
    return this.lift.call(new ArrayObservable_1.ArrayObservable(observables), new CombineLatestOperator(project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* of values, but values themselves. That means default `project` can be imagined
* as function that takes all its arguments and puts them into an array.
*
*
* @example &lt;caption&gt;Combine two timer Observables&lt;/caption&gt;
* const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
* const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
* const combinedTimers = Rx.Observable.<span class="apidocCodeKeywordSpan">combineLatest</span>(firstTimer, secondTimer);
* combinedTimers.subscribe(value =&gt; console.log(value));
* // Logs
* // [0, 0] after 0.5s
* // [1, 0] after 1s
* // [1, 1] after 1.5s
* // [2, 1] after 2s
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.concat" id="apidoc.element.rxjs.Observable.prototype.concat">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concat() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (isObject_1.isObject(sub)) {
        var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
        if (trial === errorObject_1.errorObject) {
            hasErrors = true;
            errors = errors || [];
            var err = errorObject_1.errorObject.e;
            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                errors = errors.<span class="apidocCodeKeywordSpan">concat</span>(flattenUnsubscriptionErrors(err.errors));
            }
            else {
                errors.push(err);
            }
        }
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.concatAll" id="apidoc.element.rxjs.Observable.prototype.concatAll">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>concatAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatAll() {
    return this.lift(new mergeAll_1.MergeAllOperator(1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
* to `1`.
*
* @example &lt;caption&gt;For each click event, tick every second from 0 to 3, with no concurrency&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var higherOrder = clicks.map(ev =&gt; Rx.Observable.interval(1000).take(4));
* var firstOrder = higherOrder.<span class="apidocCodeKeywordSpan">concatAll</span>();
* firstOrder.subscribe(x =&gt; console.log(x));
*
* // Results in the following:
* // (results are not concurrent)
* // For every click on the "document" it will emit values 0 to 3 spaced
* // on a 1000ms interval
* // one click = 1000ms-&gt; 0 -1000ms-&gt; 1 -1000ms-&gt; 2 -1000ms-&gt; 3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.concatMap" id="apidoc.element.rxjs.Observable.prototype.concatMap">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>concatMap
        <span class="apidocSignatureSpan">(project, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatMap(project, resultSelector) {
    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* be subscribed to.
*
* Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
* to `1`.
*
* @example &lt;caption&gt;For each click event, tick every second from 0 to 3, with no concurrency&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">concatMap</span>(ev =&gt; Rx.Observable.interval(1000).take(4));
* result.subscribe(x =&gt; console.log(x));
*
* // Results in the following:
* // (results are not concurrent)
* // For every click on the "document" it will emit values 0 to 3 spaced
* // on a 1000ms interval
* // one click = 1000ms-&gt; 0 -1000ms-&gt; 1 -1000ms-&gt; 2 -1000ms-&gt; 3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.concatMapTo" id="apidoc.element.rxjs.Observable.prototype.concatMapTo">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>concatMapTo
        <span class="apidocSignatureSpan">(innerObservable, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatMapTo(innerObservable, resultSelector) {
    return this.lift(new mergeMapTo_1.MergeMapToOperator(innerObservable, resultSelector, 1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* be subscribed to.
*
* Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
* set to `1`.
*
* @example &lt;caption&gt;For each click event, tick every second from 0 to 3, with no concurrency&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">concatMapTo</span>(Rx.Observable.interval(1000).take(4));
* result.subscribe(x =&gt; console.log(x));
*
* // Results in the following:
* // (results are not concurrent)
* // For every click on the "document" it will emit values 0 to 3 spaced
* // on a 1000ms interval
* // one click = 1000ms-&gt; 0 -1000ms-&gt; 1 -1000ms-&gt; 2 -1000ms-&gt; 3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.count" id="apidoc.element.rxjs.Observable.prototype.count">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>count
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function count(predicate) {
    return this.lift(new CountOperator(predicate, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* as argument, in which case the output emission will represent the number of
* source values that matched `true` with the `predicate`.
*
* @example &lt;caption&gt;Counts how many seconds have passed before the first click happened&lt;/caption&gt;
* var seconds = Rx.Observable.interval(1000);
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var secondsBeforeClick = seconds.takeUntil(clicks);
* var result = secondsBeforeClick.<span class="apidocCodeKeywordSpan">count</span>();
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Counts how many odd numbers are there between 1 and 7&lt;/caption&gt;
* var numbers = Rx.Observable.range(1, 7);
* var result = numbers.count(i =&gt; i % 2 === 1);
* result.subscribe(x =&gt; console.log(x));
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.debounce" id="apidoc.element.rxjs.Observable.prototype.debounce">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>debounce
        <span class="apidocSignatureSpan">(durationSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function debounce(durationSelector) {
    return this.lift(new DebounceOperator(durationSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Like {@link debounceTime}, this is a rate-limiting operator, and also a
* delay-like operator since output emissions do not necessarily occur at the
* same time as they did on the source Observable.
*
* @example &lt;caption&gt;Emit the most recent click after a burst of clicks&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">debounce</span>(() =&gt; Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link audit}
* @see {@link debounceTime}
* @see {@link delayWhen}
* @see {@link throttle}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.debounceTime" id="apidoc.element.rxjs.Observable.prototype.debounceTime">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>debounceTime
        <span class="apidocSignatureSpan">(dueTime, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* value to be emitted in any time window of duration `dueTime`, but it is also
* a delay-like operator since output emissions do not occur at the same time as
* they did on the source Observable. Optionally takes a {@link IScheduler} for
* managing timers.
*
* @example &lt;caption&gt;Emit the most recent click after a burst of clicks&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">debounceTime</span>(1000);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link auditTime}
* @see {@link debounce}
* @see {@link delay}
* @see {@link sampleTime}
* @see {@link throttleTime}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.defaultIfEmpty" id="apidoc.element.rxjs.Observable.prototype.defaultIfEmpty">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>defaultIfEmpty
        <span class="apidocSignatureSpan">(defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    return this.lift(new DefaultIfEmptyOperator(defaultValue));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `defaultIfEmpty` emits the values emitted by the source Observable or a
* specified default value if the source Observable is empty (completes without
* having emitted any `next` value).
*
* @example &lt;caption&gt;If no clicks happen in 5 seconds, then emit "no clicks"&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
* var result = clicksBeforeFive.<span class="apidocCodeKeywordSpan">defaultIfEmpty</span>('no clicks');
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link empty}
* @see {@link last}
*
* @param {any} [defaultValue=null] The default value used if the source
* Observable is empty.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.delay" id="apidoc.element.rxjs.Observable.prototype.delay">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>delay
        <span class="apidocSignatureSpan">(delay, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return this.lift(new DelayOperator(delayFor, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* // [1, 0] after 1s
* // [1, 1] after 1.5s
* // [2, 1] after 2s
*
*
* @example &lt;caption&gt;Combine an array of Observables&lt;/caption&gt;
* const observables = [1, 5, 10].map(
*   n =&gt; Rx.Observable.of(n).<span class="apidocCodeKeywordSpan">delay</span>(n * 1000).startWith(0) // emit 0 and then emit
 n after n seconds
* );
* const combined = Rx.Observable.combineLatest(observables);
* combined.subscribe(value =&gt; console.log(value));
* // Logs
* // [0, 0, 0] immediately
* // [1, 0, 0] after 1s
* // [1, 5, 0] after 5s
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.delayWhen" id="apidoc.element.rxjs.Observable.prototype.delayWhen">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>delayWhen
        <span class="apidocSignatureSpan">(delayDurationSelector, subscriptionDelay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return new SubscriptionDelayObservable(this, subscriptionDelay)
            .lift(new DelayWhenOperator(delayDurationSelector));
    }
    return this.lift(new DelayWhenOperator(delayDurationSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* completes, the source Observable is subscribed to and starts behaving like
* described in the previous paragraph. If `subscriptionDelay` is not provided,
* `delayWhen` will subscribe to the source Observable as soon as the output
* Observable is subscribed.
*
* @example &lt;caption&gt;Delay each click by a random amount of time, between 0 and 5 seconds&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var delayedClicks = clicks.<span class="apidocCodeKeywordSpan">delayWhen</span>(event =&gt;
*   Rx.Observable.interval(Math.random() * 5000)
* );
* delayedClicks.subscribe(x =&gt; console.log(x));
*
* @see {@link debounce}
* @see {@link delay}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.dematerialize" id="apidoc.element.rxjs.Observable.prototype.dematerialize">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>dematerialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dematerialize() {
    return this.lift(new DeMaterializeOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @example &lt;caption&gt;Convert an Observable of Notifications to an actual Observable&lt;/caption&gt;
* var notifA = new Rx.Notification('N', 'A');
* var notifB = new Rx.Notification('N', 'B');
* var notifE = new Rx.Notification('E', void 0,
*   new TypeError('x.toUpperCase is not a function')
* );
* var materialized = Rx.Observable.of(notifA, notifB, notifE);
* var upperCase = materialized.<span class="apidocCodeKeywordSpan">dematerialize</span>();
* upperCase.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
*
* // Results in:
* // A
* // B
* // TypeError: x.toUpperCase is not a function
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.distinct" id="apidoc.element.rxjs.Observable.prototype.distinct">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>distinct
        <span class="apidocSignatureSpan">(keySelector, flushes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function distinct(keySelector, flushes) {
    return this.lift(new DistinctOperator(keySelector, flushes));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
* hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct
`
* use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
* that the internal `Set` can be "flushed", basically clearing it of values.
*
* @example &lt;caption&gt;A simple example with numbers&lt;/caption&gt;
* Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
*   .<span class="apidocCodeKeywordSpan">distinct</span>()
*   .subscribe(x =&gt; console.log(x)); // 1, 2, 3, 4
*
* @example &lt;caption&gt;An example using a keySelector function&lt;/caption&gt;
* interface Person {
*    age: number,
*    name: string
* }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.distinctUntilChanged" id="apidoc.element.rxjs.Observable.prototype.distinctUntilChanged">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>distinctUntilChanged
        <span class="apidocSignatureSpan">(compare, keySelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function distinctUntilChanged(compare, keySelector) {
    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted
.
*
* If a comparator function is not provided, an equality check is used by default.
*
* @example &lt;caption&gt;A simple example with numbers&lt;/caption&gt;
* Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
*   .<span class="apidocCodeKeywordSpan">distinctUntilChanged</span>()
*   .subscribe(x =&gt; console.log(x)); // 1, 2, 1, 2, 3, 4
*
* @example &lt;caption&gt;An example using a compare function&lt;/caption&gt;
* interface Person {
*    age: number,
*    name: string
* }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.distinctUntilKeyChanged" id="apidoc.element.rxjs.Observable.prototype.distinctUntilKeyChanged">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>distinctUntilKeyChanged
        <span class="apidocSignatureSpan">(key, compare)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged.call(this, function (x, y) {
        if (compare) {
            return compare(x[key], y[key]);
        }
        return x[key] === y[key];
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*  }
*
* Observable.of&lt;Person&gt;(
*     { age: 4, name: 'Foo'},
*     { age: 7, name: 'Bar'},
*     { age: 5, name: 'Foo'},
*     { age: 6, name: 'Foo'})
*     .<span class="apidocCodeKeywordSpan">distinctUntilKeyChanged</span>('name')
*     .subscribe(x =&gt; console.log(x));
*
* // displays:
* // { age: 4, name: 'Foo' }
* // { age: 7, name: 'Bar' }
* // { age: 5, name: 'Foo' }
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.do" id="apidoc.element.rxjs.Observable.prototype.do">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>do
        <span class="apidocSignatureSpan">(nextOrObserver, error, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _do(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {any}
 */
Notification.prototype.accept = function (nextOrObserver, error, complete) {
    if (nextOrObserver &amp;&amp; typeof nextOrObserver.next === 'function') {
        return this.observe(nextOrObserver);
    }
    else {
        return this.<span class="apidocCodeKeywordSpan">do</span>(nextOrObserver, error, complete);
    }
};
/**
 * Returns a simple Observable that just delivers the notification represented
 * by this Notification instance.
 * @return {any}
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.elementAt" id="apidoc.element.rxjs.Observable.prototype.elementAt">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>elementAt
        <span class="apidocSignatureSpan">(index, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function elementAt(index, defaultValue) {
    return this.lift(new ElementAtOperator(index, defaultValue));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `index` in the source Observable, or a default value if that `index` is out
* of range and the `default` argument is provided. If the `default` argument is
* not given and the `index` is out of range, the output Observable will emit an
* `ArgumentOutOfRangeError` error.
*
* @example &lt;caption&gt;Emit only the third click event&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">elementAt</span>(2);
* result.subscribe(x =&gt; console.log(x));
*
* // Results in:
* // click 1 = nothing
* // click 2 = nothing
* // click 3 = MouseEvent object logged to console
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.every" id="apidoc.element.rxjs.Observable.prototype.every">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>every
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function every(predicate, thisArg) {
    return this.lift(new EveryOperator(predicate, thisArg, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
var Subscriber_1 = require('../Subscriber');
/**
* Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
*
* @example &lt;caption&gt;A simple example emitting true if all elements are less than 5, false otherwise&lt;/caption&gt;
;
*  Observable.of(1, 2, 3, 4, 5, 6)
*     .<span class="apidocCodeKeywordSpan">every</span>(x =&gt; x &lt; 5)
*     .subscribe(x =&gt; console.log(x)); // -&gt; false
*
* @param {function} predicate A function for determining if an item meets a specified condition.
* @param {any} [thisArg] Optional object to use for `this` in the callback.
* @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified
.
* @method every
* @owner Observable
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.exhaust" id="apidoc.element.rxjs.Observable.prototype.exhaust">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>exhaust
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exhaust() {
    return this.lift(new SwitchFirstOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `exhaust` ignores every new inner Observable if the previous Observable has
* not yet completed. Once that one completes, it will accept and flatten the
* next inner Observable and repeat this process.
*
* @example &lt;caption&gt;Run a finite timer for each click, only if there is no currently active timer&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var higherOrder = clicks.map((ev) =&gt; Rx.Observable.interval(1000));
* var result = higherOrder.<span class="apidocCodeKeywordSpan">exhaust</span>();
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link combineAll}
* @see {@link concatAll}
* @see {@link switch}
* @see {@link mergeAll}
* @see {@link exhaustMap}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.exhaustMap" id="apidoc.element.rxjs.Observable.prototype.exhaustMap">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>exhaustMap
        <span class="apidocSignatureSpan">(project, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exhaustMap(project, resultSelector) {
    return this.lift(new SwitchFirstMapOperator(project, resultSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* that projected Observable. However, `exhaustMap` ignores every new projected
* Observable if the previous projected Observable has not yet completed. Once
* that one completes, it will accept and flatten the next projected Observable
* and repeat this process.
*
* @example &lt;caption&gt;Run a finite timer for each click, only if there is no currently active timer&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">exhaustMap</span>((ev) =&gt; Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link concatMap}
* @see {@link exhaust}
* @see {@link mergeMap}
* @see {@link switchMap}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.expand" id="apidoc.element.rxjs.Observable.prototype.expand">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>expand
        <span class="apidocSignatureSpan">(project, concurrent, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (scheduler === void 0) { scheduler = undefined; }
    concurrent = (concurrent || 0) &lt; 1 ? Number.POSITIVE_INFINITY : concurrent;
    return this.lift(new ExpandOperator(project, concurrent, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* given to the `project` function to produce new output values. This is how
* *expand* behaves recursively.
*
* @example &lt;caption&gt;Start emitting the powers of two on every click, at most 10 of them&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var powersOfTwo = clicks
*   .mapTo(1)
*   .<span class="apidocCodeKeywordSpan">expand</span>(x =&gt; Rx.Observable.of(2 * x).delay(1000))
*   .take(10);
* powersOfTwo.subscribe(x =&gt; console.log(x));
*
* @see {@link mergeMap}
* @see {@link mergeScan}
*
* @param {function(value: T, index: number) =&gt; Observable} project A function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.filter" id="apidoc.element.rxjs.Observable.prototype.filter">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>filter
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(predicate, thisArg) {
    return this.lift(new FilterOperator(predicate, thisArg));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
* Filter items emitted by the source Observable by only emitting those that
* satisfy a specified predicate.
*
* &lt;span class="informal"&gt;Like
* [Array.prototype.<span class="apidocCodeKeywordSpan">filter</span>()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/
Reference/Global_Objects/Array/filter),
* it only emits a value from the source if it passes a criterion function.&lt;/span&gt;
*
* &lt;img src="./img/filter.png" width="100%"&gt;
*
* Similar to the well-known `Array.prototype.filter` method, this operator
* takes values from the source Observable, passes them through a `predicate`
* function and only emits those values that yielded `true`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.finally" id="apidoc.element.rxjs.Observable.prototype.finally">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>finally
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _finally(callback) {
    return this.lift(new FinallyOperator(callback));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.find" id="apidoc.element.rxjs.Observable.prototype.find">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>find
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return this.lift(new FindValueOperator(predicate, this, false, thisArg));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `find` searches for the first item in the source Observable that matches the
* specified condition embodied by the `predicate`, and returns the first
* occurrence in the source. Unlike {@link first}, the `predicate` is required
* in `find`, and does not emit an error if a valid value is not found.
*
* @example &lt;caption&gt;Find and emit the first click that happens on a DIV element&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">find</span>(ev =&gt; ev.target.tagName === 'DIV');
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link filter}
* @see {@link first}
* @see {@link findIndex}
* @see {@link take}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.findIndex" id="apidoc.element.rxjs.Observable.prototype.findIndex">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>findIndex
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findIndex(predicate, thisArg) {
    return this.lift(new find_1.FindValueOperator(predicate, this, true, thisArg));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the specified condition embodied by the `predicate`, and returns the
* (zero-based) index of the first occurrence in the source. Unlike
* {@link first}, the `predicate` is required in `findIndex`, and does not emit
* an error if a valid value is not found.
*
* @example &lt;caption&gt;Emit the index of first click that happens on a DIV element&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">findIndex</span>(ev =&gt; ev.target.tagName === 'DIV');
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link filter}
* @see {@link find}
* @see {@link first}
* @see {@link take}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.first" id="apidoc.element.rxjs.Observable.prototype.first">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>first
        <span class="apidocSignatureSpan">(predicate, resultSelector, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function first(predicate, resultSelector, defaultValue) {
    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* may also take a `resultSelector` function to produce the output value from
* the input value, and a `defaultValue` to emit in case the source completes
* before it is able to emit a valid value. Throws an error if `defaultValue`
* was not provided and a matching element is not found.
*
* @example &lt;caption&gt;Emit only the first click that happens on the DOM&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">first</span>();
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Emits the first click that happens on a DIV&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.first(ev =&gt; ev.target.tagName === 'DIV');
* result.subscribe(x =&gt; console.log(x));
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.flatMap" id="apidoc.element.rxjs.Observable.prototype.flatMap">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>flatMap
        <span class="apidocSignatureSpan">(project, resultSelector, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.flatMapTo" id="apidoc.element.rxjs.Observable.prototype.flatMapTo">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>flatMapTo
        <span class="apidocSignatureSpan">(innerObservable, resultSelector, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.forEach" id="apidoc.element.rxjs.Observable.prototype.forEach">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>forEach
        <span class="apidocSignatureSpan">(next, PromiseCtor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (next, PromiseCtor) {
    var _this = this;
    if (!PromiseCtor) {
        if (root_1.root.Rx &amp;&amp; root_1.root.Rx.config &amp;&amp; root_1.root.Rx.config.Promise) {
            PromiseCtor = root_1.root.Rx.config.Promise;
        }
        else if (root_1.root.Promise) {
            PromiseCtor = root_1.root.Promise;
        }
    }
    if (!PromiseCtor) {
        throw new Error('no Promise impl found');
    }
    return new PromiseCtor(function (resolve, reject) {
        var subscription = _this.subscribe(function (value) {
            if (subscription) {
                // if there is a subscription, then we can surmise
                // the next handling is asynchronous. Any errors thrown
                // need to be rejected explicitly and unsubscribe must be
                // called manually
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    subscription.unsubscribe();
                }
            }
            else {
                // if there is NO subscription, then we're getting a nexted
                // value synchronously during subscription. We can just call it.
                // If it errors, Observable's `subscribe` will ensure the
                // unsubscription logic is called, then synchronously rethrow the error.
                // After that, Promise will trap the error and send it
                // down the rejection path.
                next(value);
            }
        }, reject, resolve);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!group.closed) {
        group.next(element);
    }
};
GroupBySubscriber.prototype._error = function (err) {
    var groups = this.groups;
    if (groups) {
        groups.<span class="apidocCodeKeywordSpan">forEach</span>(function (group, key) {
            group.error(err);
        });
        groups.clear();
    }
    this.destination.error(err);
};
GroupBySubscriber.prototype._complete = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.groupBy" id="apidoc.element.rxjs.Observable.prototype.groupBy">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>groupBy
        <span class="apidocSignatureSpan">(keySelector, elementSelector, durationSelector, subjectSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return this.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.ignoreElements" id="apidoc.element.rxjs.Observable.prototype.ignoreElements">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>ignoreElements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ignoreElements() {
    return this.lift(new IgnoreElementsOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.isEmpty" id="apidoc.element.rxjs.Observable.prototype.isEmpty">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEmpty() {
    return this.lift(new IsEmptyOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.last" id="apidoc.element.rxjs.Observable.prototype.last">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>last
        <span class="apidocSignatureSpan">(predicate, resultSelector, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function last(predicate, resultSelector, defaultValue) {
    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.let" id="apidoc.element.rxjs.Observable.prototype.let">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>let
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function letProto(func) {
    return func(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.letBind" id="apidoc.element.rxjs.Observable.prototype.letBind">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>letBind
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function letProto(func) {
    return func(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.lift" id="apidoc.element.rxjs.Observable.prototype.lift">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>lift
        <span class="apidocSignatureSpan">(operator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lift = function (operator) {
    var observable = new Observable();
    observable.source = this;
    observable.operator = operator;
    return observable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        else {
            this._connection = connection;
        }
    }
    return connection;
};
ConnectableObservable.prototype.refCount = function () {
    return this.<span class="apidocCodeKeywordSpan">lift</span>(new RefCountOperator(this));
};
return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = {
operator: { value: null },
_refCount: { value: 0, writable: true },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.map" id="apidoc.element.rxjs.Observable.prototype.map">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>map
        <span class="apidocSignatureSpan">(project, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(project, thisArg) {
    if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
To import only what you need by patching (this is useful for size-sensitive bundling):

```js
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/map';

Observable.of(1,2,3).<span class="apidocCodeKeywordSpan">map</span>(x =&gt; x + '!!!'); // etc
```

To import what you need and use it with proposed [bind operator](https://github.com/tc39/proposal-bind-operator):

&gt; Note: This additional syntax requires [transpiler support](http://babeljs.io/docs/plugins/transform-function-bind/) and this
 syntax may be completely withdrawn from TC39 without notice! Use at your own risk.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.mapTo" id="apidoc.element.rxjs.Observable.prototype.mapTo">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>mapTo
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapTo(value) {
    return this.lift(new MapToOperator(value));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* output Observable. Those output values resulting from the projection are also
* given to the `project` function to produce new output values. This is how
* *expand* behaves recursively.
*
* @example &lt;caption&gt;Start emitting the powers of two on every click, at most 10 of them&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var powersOfTwo = clicks
*   .<span class="apidocCodeKeywordSpan">mapTo</span>(1)
*   .expand(x =&gt; Rx.Observable.of(2 * x).delay(1000))
*   .take(10);
* powersOfTwo.subscribe(x =&gt; console.log(x));
*
* @see {@link mergeMap}
* @see {@link mergeScan}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.materialize" id="apidoc.element.rxjs.Observable.prototype.materialize">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>materialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function materialize() {
    return this.lift(new MaterializeOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* This operator is useful for producing metadata of the source Observable, to
* be consumed as `next` emissions. Use it in conjunction with
* {@link dematerialize}.
*
* @example &lt;caption&gt;Convert a faulty Observable to an Observable of Notifications&lt;/caption&gt;
* var letters = Rx.Observable.of('a', 'b', 13, 'd');
* var upperCase = letters.map(x =&gt; x.toUpperCase());
* var materialized = upperCase.<span class="apidocCodeKeywordSpan">materialize</span>();
* materialized.subscribe(x =&gt; console.log(x));
*
* // Results in the following:
* // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
* // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
* // - Notification {kind: "E", value: undefined, error: TypeError:
* //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.max" id="apidoc.element.rxjs.Observable.prototype.max">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>max
        <span class="apidocSignatureSpan">(comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) &gt; 0 ? x : y; }
        : function (x, y) { return x &gt; y ? x : y; };
    return this.lift(new reduce_1.ReduceOperator(max));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    while (spliceCount &lt; eventsCount) {
        if ((now - _events[spliceCount].time) &lt; _windowTime) {
            break;
        }
        spliceCount++;
    }
    if (eventsCount &gt; _bufferSize) {
        spliceCount = Math.<span class="apidocCodeKeywordSpan">max</span>(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount &gt; 0) {
        _events.splice(0, spliceCount);
    }
    return _events;
};
return ReplaySubject;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.merge" id="apidoc.element.rxjs.Observable.prototype.merge">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.mergeAll" id="apidoc.element.rxjs.Observable.prototype.mergeAll">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>mergeAll
        <span class="apidocSignatureSpan">(concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return this.lift(new MergeAllOperator(concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* inner Observable on the output Observable. The output Observable only
* completes once all inner Observables have completed. Any error delivered by
* a inner Observable will be immediately emitted on the output Observable.
*
* @example &lt;caption&gt;Spawn a new interval Observable for each click event, and blend their outputs as one Observable&lt;
;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var higherOrder = clicks.map((ev) =&gt; Rx.Observable.interval(1000));
* var firstOrder = higherOrder.<span class="apidocCodeKeywordSpan">mergeAll</span>();
* firstOrder.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Count from 0 to 9 every second for each click, but only allow 2 concurrent timers&lt;/caption&gt;
;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var higherOrder = clicks.map((ev) =&gt; Rx.Observable.interval(1000).take(10));
* var firstOrder = higherOrder.mergeAll(2);
* firstOrder.subscribe(x =&gt; console.log(x));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.mergeMap" id="apidoc.element.rxjs.Observable.prototype.mergeMap">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>mergeMap
        <span class="apidocSignatureSpan">(project, resultSelector, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @example &lt;caption&gt;Emit the number 7, then complete.&lt;/caption&gt;
* var result = Rx.Observable.empty().startWith(7);
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Map and flatten only odd numbers to the sequence 'a', 'b', 'c'&lt;/
caption&gt;
* var interval = Rx.Observable.interval(1000);
* var result = interval.<span class="apidocCodeKeywordSpan">mergeMap</span>(x =&gt;
*   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
* );
* result.subscribe(x =&gt; console.log(x));
*
* // Results in the following to the console:
* // x is equal to the count on the interval eg(0,1,2,3,...)
* // x will occur every 1000ms
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.mergeMapTo" id="apidoc.element.rxjs.Observable.prototype.mergeMapTo">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>mergeMapTo
        <span class="apidocSignatureSpan">(innerObservable, resultSelector, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Maps each source value to the given Observable `innerObservable` regardless
* of the source value, and then merges those resulting Observables into one
* single Observable, which is the output Observable.
*
* @example &lt;caption&gt;For each click event, start an interval Observable ticking every 1 second&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">mergeMapTo</span>(Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link concatMapTo}
* @see {@link merge}
* @see {@link mergeAll}
* @see {@link mergeMap}
* @see {@link mergeScan}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.mergeScan" id="apidoc.element.rxjs.Observable.prototype.mergeScan">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>mergeScan
        <span class="apidocSignatureSpan">(accumulator, seed, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return this.lift(new MergeScanOperator(accumulator, seed, concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* &lt;span class="informal"&gt;It's like {@link scan}, but the Observables returned
* by the accumulator are merged into the outer Observable.&lt;/span&gt;
*
* @example &lt;caption&gt;Count the number of click events&lt;/caption&gt;
* const click$ = Rx.Observable.fromEvent(document, 'click');
* const one$ = click$.mapTo(1);
* const seed = 0;
* const count$ = one$.<span class="apidocCodeKeywordSpan">mergeScan</span>((acc, one) =&gt; Rx.Observable.of(acc + one), seed);
* count$.subscribe(x =&gt; console.log(x));
*
* // Results:
* 1
* 2
* 3
* 4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.min" id="apidoc.element.rxjs.Observable.prototype.min">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>min
        <span class="apidocSignatureSpan">(comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) &lt; 0 ? x : y; }
        : function (x, y) { return x &lt; y ? x : y; };
    return this.lift(new reduce_1.ReduceOperator(min));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.multicast" id="apidoc.element.rxjs.Observable.prototype.multicast">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>multicast
        <span class="apidocSignatureSpan">(subjectOrSubjectFactory, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === 'function') {
        subjectFactory = subjectOrSubjectFactory;
    }
    else {
        subjectFactory = function subjectFactory() {
            return subjectOrSubjectFactory;
        };
    }
    if (typeof selector === 'function') {
        return this.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
    connectable.source = this;
    connectable.subjectFactory = subjectFactory;
    return connectable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.observeOn" id="apidoc.element.rxjs.Observable.prototype.observeOn">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>observeOn
        <span class="apidocSignatureSpan">(scheduler, delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return this.lift(new ObserveOnOperator(scheduler, delay));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.onErrorResumeNext" id="apidoc.element.rxjs.Observable.prototype.onErrorResumeNext">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>onErrorResumeNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    if (nextSources.length === 1 &amp;&amp; isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return this.lift(new OnErrorResumeNextOperator(nextSources));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.pairwise" id="apidoc.element.rxjs.Observable.prototype.pairwise">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>pairwise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pairwise() {
    return this.lift(new PairwiseOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* to emit an array [(N-1)th, Nth] of the previous and the current value, as a
* pair. For this reason, `pairwise` emits on the second and subsequent
* emissions from the source Observable, but not on the first emission, because
* there is no previous value in that case.
*
* @example &lt;caption&gt;On every click (starting from the second), emit the relative distance to the previous click&lt;/
caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var pairs = clicks.<span class="apidocCodeKeywordSpan">pairwise</span>();
* var distance = pairs.map(pair =&gt; {
*   var x0 = pair[0].clientX;
*   var y0 = pair[0].clientY;
*   var x1 = pair[1].clientX;
*   var y1 = pair[1].clientY;
*   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.partition" id="apidoc.element.rxjs.Observable.prototype.partition">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>partition
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function partition(predicate, thisArg) {
    return [
        filter_1.filter.call(this, predicate, thisArg),
        filter_1.filter.call(this, not_1.not(predicate, thisArg))
    ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Observable in that array emits source values for which the predicate argument
* returns true. The second Observable emits source values for which the
* predicate returns false. The first behaves like {@link filter} and the second
* behaves like {@link filter} with the predicate negated.
*
* @example &lt;caption&gt;Partition click events into those on DIV elements and those elsewhere&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var parts = clicks.<span class="apidocCodeKeywordSpan">partition</span>(ev =&gt; ev.target.tagName === 'DIV');
* var clicksOnDivs = parts[0];
* var clicksElsewhere = parts[1];
* clicksOnDivs.subscribe(x =&gt; console.log('DIV clicked: ', x));
* clicksElsewhere.subscribe(x =&gt; console.log('Other clicked: ', x));
*
* @see {@link filter}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.pluck" id="apidoc.element.rxjs.Observable.prototype.pluck">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>pluck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pluck() {
    var properties = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        properties[_i - 0] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return map_1.map.call(this, plucker(properties, length));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Given a list of strings describing a path to an object property, retrieves
* the value of a specified nested property from all values in the source
* Observable. If a property can't be resolved, it will return `undefined` for
* that value.
*
* @example &lt;caption&gt;Map every every click to the tagName of the clicked target element&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var tagNames = clicks.<span class="apidocCodeKeywordSpan">pluck</span>('target', 'tagName');
* tagNames.subscribe(x =&gt; console.log(x));
*
* @see {@link map}
*
* @param {...string} properties The nested properties to pluck from each source
* value (an object).
* @return {Observable} A new Observable of property values from the source values.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.publish" id="apidoc.element.rxjs.Observable.prototype.publish">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>publish
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publish(selector) {
    return selector ? multicast_1.multicast.call(this, function () { return new Subject_1.Subject(); }, selector) :
        multicast_1.multicast.call(this, new Subject_1.Subject());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// where the ConnectableObservable source synchronously emits values, and
// the RefCountSubscriber's downstream Observers synchronously unsubscribe,
// execution continues to here before the RefCountOperator has a chance to
// supply the RefCountSubscriber with the shared connection Subscription.
// For example:
// ```
// Observable.range(0, 10)
//   .<span class="apidocCodeKeywordSpan">publish</span>()
//   .refCount()
//   .take(5)
//   .subscribe();
// ```
// In order to account for this case, RefCountSubscriber should only dispose
// the ConnectableObservable's shared connection Subscription if the
// connection Subscription exists, *and* either:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.publishBehavior" id="apidoc.element.rxjs.Observable.prototype.publishBehavior">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>publishBehavior
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publishBehavior(value) {
    return multicast_1.multicast.call(this, new BehaviorSubject_1.BehaviorSubject(value));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.publishLast" id="apidoc.element.rxjs.Observable.prototype.publishLast">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>publishLast
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publishLast() {
    return multicast_1.multicast.call(this, new AsyncSubject_1.AsyncSubject());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.publishReplay" id="apidoc.element.rxjs.Observable.prototype.publishReplay">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>publishReplay
        <span class="apidocSignatureSpan">(bufferSize, windowTime, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publishReplay(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
    return multicast_1.multicast.call(this, new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.race" id="apidoc.element.rxjs.Observable.prototype.race">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>race
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `pair([obs1, obs2, ...])`
    if (observables.length === 1 &amp;&amp; isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return this.lift.call(raceStatic.apply(void 0, [this].concat(observables)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.reduce" id="apidoc.element.rxjs.Observable.prototype.reduce">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>reduce
        <span class="apidocSignatureSpan">(accumulator, seed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length &gt;= 2) {
        hasSeed = true;
    }
    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.<span class="apidocCodeKeywordSpan">reduce</span>(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1
.UnsubscriptionError) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.repeat" id="apidoc.element.rxjs.Observable.prototype.repeat">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>repeat
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function repeat(count) {
    if (count === void 0) { count = -1; }
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    else if (count &lt; 0) {
        return this.lift(new RepeatOperator(-1, this));
    }
    else {
        return this.lift(new RepeatOperator(count - 1, this));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.repeatWhen" id="apidoc.element.rxjs.Observable.prototype.repeatWhen">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>repeatWhen
        <span class="apidocSignatureSpan">(notifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function repeatWhen(notifier) {
    return this.lift(new RepeatWhenOperator(notifier));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.retry" id="apidoc.element.rxjs.Observable.prototype.retry">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>retry
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry(count) {
    if (count === void 0) { count = -1; }
    return this.lift(new RetryOperator(count, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.retryWhen" id="apidoc.element.rxjs.Observable.prototype.retryWhen">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>retryWhen
        <span class="apidocSignatureSpan">(notifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retryWhen(notifier) {
    return this.lift(new RetryWhenOperator(notifier, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.sample" id="apidoc.element.rxjs.Observable.prototype.sample">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>sample
        <span class="apidocSignatureSpan">(notifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sample(notifier) {
    return this.lift(new SampleOperator(notifier));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* emitted since the previous sampling, unless the source has not emitted
* anything since the previous sampling. The `notifier` is subscribed to as soon
* as the output Observable is subscribed.
*
* @example &lt;caption&gt;On every click, sample the most recent "seconds" timer&lt;/caption&gt;
* var seconds = Rx.Observable.interval(1000);
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = seconds.<span class="apidocCodeKeywordSpan">sample</span>(clicks);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link audit}
* @see {@link debounce}
* @see {@link sampleTime}
* @see {@link throttle}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.sampleTime" id="apidoc.element.rxjs.Observable.prototype.sampleTime">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>sampleTime
        <span class="apidocSignatureSpan">(period, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sampleTime(period, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new SampleTimeOperator(period, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* source has not emitted anything since the previous sampling. The sampling
* happens periodically in time every `period` milliseconds (or the time unit
* defined by the optional `scheduler` argument). The sampling starts as soon as
* the output Observable is subscribed.
*
* @example &lt;caption&gt;Every second, emit the most recent click at most once&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">sampleTime</span>(1000);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link auditTime}
* @see {@link debounceTime}
* @see {@link delay}
* @see {@link sample}
* @see {@link throttleTime}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.scan" id="apidoc.element.rxjs.Observable.prototype.scan">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>scan
        <span class="apidocSignatureSpan">(accumulator, seed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scan(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length &gt;= 2) {
        hasSeed = true;
    }
    return this.lift(new ScanOperator(accumulator, seed, hasSeed));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* that value will be used as the initial value for the accumulator. If no seed
* value is specified, the first item of the source is used as the seed.
*
* @example &lt;caption&gt;Count the number of click events&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var ones = clicks.mapTo(1);
* var seed = 0;
* var count = ones.<span class="apidocCodeKeywordSpan">scan</span>((acc, one) =&gt; acc + one, seed);
* count.subscribe(x =&gt; console.log(x));
*
* @see {@link expand}
* @see {@link mergeScan}
* @see {@link reduce}
*
* @param {function(acc: R, value: T, index: number): R} accumulator
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.sequenceEqual" id="apidoc.element.rxjs.Observable.prototype.sequenceEqual">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>sequenceEqual
        <span class="apidocSignatureSpan">(compareTo, comparor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sequenceEqual(compareTo, comparor) {
    return this.lift(new SequenceEqualOperator(compareTo, comparor));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* var keys = Rx.Observable.fromEvent(document, 'keyup')
*  .map(e =&gt; e.code);
* var matches = keys.bufferCount(11, 1)
*  .mergeMap(
*    last11 =&gt;
*      Rx.Observable.from(last11)
*        .<span class="apidocCodeKeywordSpan">sequenceEqual</span>(code)
*   );
* matches.subscribe(matched =&gt; console.log('Successful cheat at Contra? ', matched));
*
* @see {@link combineLatest}
* @see {@link zip}
* @see {@link withLatestFrom}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.share" id="apidoc.element.rxjs.Observable.prototype.share">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>share
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function share() {
    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.single" id="apidoc.element.rxjs.Observable.prototype.single">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>single
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function single(predicate) {
    return this.lift(new SingleOperator(predicate, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.skip" id="apidoc.element.rxjs.Observable.prototype.skip">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>skip
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skip(count) {
    return this.lift(new SkipOperator(count));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Observable. If `startWindowEvery` is not provided, then new windows are
* started immediately at the start of the source and when each window completes
* with size `windowSize`.
*
* @example &lt;caption&gt;Ignore every 3rd click event, starting from the first one&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.windowCount(3)
*   .map(win =&gt; win.<span class="apidocCodeKeywordSpan">skip</span>(1)) // skip first of every 3 clicks
*   .mergeAll(); // flatten the Observable-of-Observables
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Ignore every 3rd click event, starting from the third one&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.windowCount(2, 3)
*   .mergeAll(); // flatten the Observable-of-Observables
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.skipUntil" id="apidoc.element.rxjs.Observable.prototype.skipUntil">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>skipUntil
        <span class="apidocSignatureSpan">(notifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipUntil(notifier) {
    return this.lift(new SkipUntilOperator(notifier));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.skipWhile" id="apidoc.element.rxjs.Observable.prototype.skipWhile">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>skipWhile
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipWhile(predicate) {
    return this.lift(new SkipWhileOperator(predicate));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.startWith" id="apidoc.element.rxjs.Observable.prototype.startWith">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>startWith
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startWith() {
    var array = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
    }
    else {
        scheduler = null;
    }
    var len = array.length;
    if (len === 1) {
        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
    }
    else if (len &gt; 1) {
        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
    }
    else {
        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* &lt;img src="./img/empty.png" width="100%"&gt;
*
* This static operator is useful for creating a simple Observable that only
* emits the complete notification. It can be used for composing with other
* Observables, such as in a {@link mergeMap}.
*
* @example &lt;caption&gt;Emit the number 7, then complete.&lt;/caption&gt;
* var result = Rx.Observable.empty().<span class="apidocCodeKeywordSpan">startWith</span>(7);
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Map and flatten only odd numbers to the sequence 'a', 'b', 'c'&lt;/
caption&gt;
* var interval = Rx.Observable.interval(1000);
* var result = interval.mergeMap(x =&gt;
*   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
* );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.subscribe" id="apidoc.element.rxjs.Observable.prototype.subscribe">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>subscribe
        <span class="apidocSignatureSpan">(observerOrNext, error, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribe = function (observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
    if (operator) {
        operator.call(sink, this.source);
    }
    else {
        sink.add(this._trySubscribe(sink));
    }
    if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
            throw sink.syncErrorValue;
        }
    }
    return sink;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Node.js Usage:

```js
var Rx = require('@reactivex/rxjs');

Rx.Observable.of('hello world')
  .<span class="apidocCodeKeywordSpan">subscribe</span>(function(x) { console.log(x); });
```

## Goals

- Provide better performance than preceding versions of RxJS
- To model/follow the [Observable Spec Proposal](https://github.com/zenparsing/es-observable) to the observable.
- Provide more modular file structure in a variety of formats
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.subscribeOn" id="apidoc.element.rxjs.Observable.prototype.subscribeOn">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>subscribeOn
        <span class="apidocSignatureSpan">(scheduler, delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subscribeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return this.lift(new SubscribeOnOperator(scheduler, delay));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.switch" id="apidoc.element.rxjs.Observable.prototype.switch">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>switch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _switch() {
    return this.lift(new SwitchOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* subscribes to the new inner Observable and begins emitting items from it. It
* continues to behave like this for subsequent inner Observables.
*
* @example &lt;caption&gt;Rerun an interval Observable on every click event&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* // Each click event is mapped to an Observable that ticks every second
* var higherOrder = clicks.map((ev) =&gt; Rx.Observable.interval(1000));
* var switched = higherOrder.<span class="apidocCodeKeywordSpan">switch</span>();
* // The outcome is that `switched` is essentially a timer that restarts
* // on every click. The interval Observables from older clicks do not merge
* // with the current interval Observable.
* switched.subscribe(x =&gt; console.log(x));
*
* @see {@link combineAll}
* @see {@link concatAll}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.switchMap" id="apidoc.element.rxjs.Observable.prototype.switchMap">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>switchMap
        <span class="apidocSignatureSpan">(project, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function switchMap(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* that inner Observable. When a new inner Observable is emitted, `switchMap`
* stops emitting items from the earlier-emitted inner Observable and begins
* emitting items from the new one. It continues to behave like this for
* subsequent inner Observables.
*
* @example &lt;caption&gt;Rerun an interval Observable on every click event&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">switchMap</span>((ev) =&gt; Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link concatMap}
* @see {@link exhaustMap}
* @see {@link mergeMap}
* @see {@link switch}
* @see {@link switchMapTo}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.switchMapTo" id="apidoc.element.rxjs.Observable.prototype.switchMapTo">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>switchMapTo
        <span class="apidocSignatureSpan">(innerObservable, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function switchMapTo(innerObservable, resultSelector) {
    return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* of the source value, and then flattens those resulting Observables into one
* single Observable, which is the output Observable. The output Observables
* emits values only from the most recently emitted instance of
* `innerObservable`.
*
* @example &lt;caption&gt;Rerun an interval Observable on every click event&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">switchMapTo</span>(Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link concatMapTo}
* @see {@link switch}
* @see {@link switchMap}
* @see {@link mergeMapTo}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.take" id="apidoc.element.rxjs.Observable.prototype.take">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>take
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function take(count) {
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    else {
        return this.lift(new TakeOperator(count));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// execution continues to here before the RefCountOperator has a chance to
// supply the RefCountSubscriber with the shared connection Subscription.
// For example:
// ```
// Observable.range(0, 10)
//   .publish()
//   .refCount()
//   .<span class="apidocCodeKeywordSpan">take</span>(5)
//   .subscribe();
// ```
// In order to account for this case, RefCountSubscriber should only dispose
// the ConnectableObservable's shared connection Subscription if the
// connection Subscription exists, *and* either:
//   a. RefCountSubscriber doesn't have a reference to the shared connection
//      Subscription yet, or,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.takeLast" id="apidoc.element.rxjs.Observable.prototype.takeLast">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>takeLast
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function takeLast(count) {
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    else {
        return this.lift(new TakeLastOperator(count));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `complete` notification emission from the source in order to emit the `next`
* values on the output Observable, because otherwise it is impossible to know
* whether or not more values will be emitted on the source. For this reason,
* all values are emitted synchronously, followed by the complete notification.
*
* @example &lt;caption&gt;Take the last 3 values of an Observable with many values&lt;/caption&gt;
* var many = Rx.Observable.range(1, 100);
* var lastThree = many.<span class="apidocCodeKeywordSpan">takeLast</span>(3);
* lastThree.subscribe(x =&gt; console.log(x));
*
* @see {@link take}
* @see {@link takeUntil}
* @see {@link takeWhile}
* @see {@link skip}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.takeUntil" id="apidoc.element.rxjs.Observable.prototype.takeUntil">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>takeUntil
        <span class="apidocSignatureSpan">(notifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function takeUntil(notifier) {
    return this.lift(new TakeUntilOperator(notifier));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* a value nor terminate. This operator takes an optional `predicate` function
* as argument, in which case the output emission will represent the number of
* source values that matched `true` with the `predicate`.
*
* @example &lt;caption&gt;Counts how many seconds have passed before the first click happened&lt;/caption&gt;
* var seconds = Rx.Observable.interval(1000);
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var secondsBeforeClick = seconds.<span class="apidocCodeKeywordSpan">takeUntil</span>(clicks);
* var result = secondsBeforeClick.count();
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Counts how many odd numbers are there between 1 and 7&lt;/caption&gt;
* var numbers = Rx.Observable.range(1, 7);
* var result = numbers.count(i =&gt; i % 2 === 1);
* result.subscribe(x =&gt; console.log(x));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.takeWhile" id="apidoc.element.rxjs.Observable.prototype.takeWhile">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>takeWhile
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function takeWhile(predicate) {
    return this.lift(new TakeWhileOperator(predicate));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* boolean, representing a condition to be satisfied by the source values. The
* output Observable emits the source values until such time as the `predicate`
* returns false, at which point `takeWhile` stops mirroring the source
* Observable and completes the output Observable.
*
* @example &lt;caption&gt;Emit click events only while the clientX property is greater than 200&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">takeWhile</span>(ev =&gt; ev.clientX &gt; 200);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link take}
* @see {@link takeLast}
* @see {@link takeUntil}
* @see {@link skip}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.throttle" id="apidoc.element.rxjs.Observable.prototype.throttle">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>throttle
        <span class="apidocSignatureSpan">(durationSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function throttle(durationSelector) {
    return this.lift(new ThrottleOperator(durationSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* is enabled by calling the `durationSelector` function with the source value,
* which returns the "duration" Observable. When the duration Observable emits a
* value or completes, the timer is disabled, and this process repeats for the
* next source value.
*
* @example &lt;caption&gt;Emit clicks at a rate of at most one click per second&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">throttle</span>(ev =&gt; Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link audit}
* @see {@link debounce}
* @see {@link delayWhen}
* @see {@link sample}
* @see {@link throttleTime}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.throttleTime" id="apidoc.element.rxjs.Observable.prototype.throttleTime">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>throttleTime
        <span class="apidocSignatureSpan">(duration, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function throttleTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new ThrottleTimeOperator(duration, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* is enabled. After `duration` milliseconds (or the time unit determined
* internally by the optional `scheduler`) has passed, the timer is disabled,
* and this process repeats for the next source value. Optionally takes a
* {@link IScheduler} for managing timers.
*
* @example &lt;caption&gt;Emit clicks at a rate of at most one click per second&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">throttleTime</span>(1000);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link auditTime}
* @see {@link debounceTime}
* @see {@link delay}
* @see {@link sampleTime}
* @see {@link throttle}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.timeInterval" id="apidoc.element.rxjs.Observable.prototype.timeInterval">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>timeInterval
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeInterval(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new TimeIntervalOperator(scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.timeout" id="apidoc.element.rxjs.Observable.prototype.timeout">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>timeout
        <span class="apidocSignatureSpan">(due, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteTimeout = isDate_1.isDate(due);
    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError()));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.timeoutWith" id="apidoc.element.rxjs.Observable.prototype.timeoutWith">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>timeoutWith
        <span class="apidocSignatureSpan">(due, withObservable, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteTimeout = isDate_1.isDate(due);
    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
    return this.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.timestamp" id="apidoc.element.rxjs.Observable.prototype.timestamp">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>timestamp
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timestamp(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new TimestampOperator(scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.toArray" id="apidoc.element.rxjs.Observable.prototype.toArray">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toArray() {
    return this.lift(new ToArrayOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.toPromise" id="apidoc.element.rxjs.Observable.prototype.toPromise">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>toPromise
        <span class="apidocSignatureSpan">(PromiseCtor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toPromise(PromiseCtor) {
    var _this = this;
    if (!PromiseCtor) {
        if (root_1.root.Rx &amp;&amp; root_1.root.Rx.config &amp;&amp; root_1.root.Rx.config.Promise) {
            PromiseCtor = root_1.root.Rx.config.Promise;
        }
        else if (root_1.root.Promise) {
            PromiseCtor = root_1.root.Promise;
        }
    }
    if (!PromiseCtor) {
        throw new Error('no Promise impl found');
    }
    return new PromiseCtor(function (resolve, reject) {
        var value;
        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve
(value); });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Converts an Observable sequence to a ES2015 compliant promise.
*
* @example
* // Using normal ES2015
* let source = Rx.Observable
*   .just(42)
*   .<span class="apidocCodeKeywordSpan">toPromise</span>();
*
* source.then((value) =&gt; console.log('Value: %s', value));
* // =&gt; Value: 42
*
* // Rejected Promise
* // Using normal ES2015
* let source = Rx.Observable
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.window" id="apidoc.element.rxjs.Observable.prototype.window">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>window
        <span class="apidocSignatureSpan">(windowBoundaries)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function window(windowBoundaries) {
    return this.lift(new WindowOperator(windowBoundaries));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* windows. It emits the current window and opens a new one whenever the
* Observable `windowBoundaries` emits an item. Because each window is an
* Observable, the output is a higher-order Observable.
*
* @example &lt;caption&gt;In every window of 1 second each, emit at most 2 click events&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var interval = Rx.Observable.interval(1000);
* var result = clicks.<span class="apidocCodeKeywordSpan">window</span>(interval)
*   .map(win =&gt; win.take(2)) // each window has at most 2 emissions
*   .mergeAll(); // flatten the Observable-of-Observables
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link windowCount}
* @see {@link windowTime}
* @see {@link windowToggle}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.windowCount" id="apidoc.element.rxjs.Observable.prototype.windowCount">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>windowCount
        <span class="apidocSignatureSpan">(windowSize, startWindowEvery)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) { startWindowEvery = 0; }
    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the current window and propagates the notification from the source
* Observable. If `startWindowEvery` is not provided, then new windows are
* started immediately at the start of the source and when each window completes
* with size `windowSize`.
*
* @example &lt;caption&gt;Ignore every 3rd click event, starting from the first one&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">windowCount</span>(3)
*   .map(win =&gt; win.skip(1)) // skip first of every 3 clicks
*   .mergeAll(); // flatten the Observable-of-Observables
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Ignore every 3rd click event, starting from the third one&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.windowCount(2, 3)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.windowTime" id="apidoc.element.rxjs.Observable.prototype.windowTime">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>windowTime
        <span class="apidocSignatureSpan">(windowTimeSpan)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function windowTime(windowTimeSpan) {
    var scheduler = async_1.async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler_1.isScheduler(arguments[3])) {
        scheduler = arguments[3];
    }
    if (isScheduler_1.isScheduler(arguments[2])) {
        scheduler = arguments[2];
    }
    else if (isNumeric_1.isNumeric(arguments[2])) {
        maxWindowSize = arguments[2];
    }
    if (isScheduler_1.isScheduler(arguments[1])) {
        scheduler = arguments[1];
    }
    else if (isNumeric_1.isNumeric(arguments[1])) {
        windowCreationInterval = arguments[1];
    }
    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.windowToggle" id="apidoc.element.rxjs.Observable.prototype.windowToggle">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>windowToggle
        <span class="apidocSignatureSpan">(openings, closingSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function windowToggle(openings, closingSelector) {
    return this.lift(new WindowToggleOperator(openings, closingSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* emitted by the source Observable between the time when the `openings`
* Observable emits an item and when the Observable returned by
* `closingSelector` emits an item.
*
* @example &lt;caption&gt;Every other second, emit the click events from the next 500ms&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var openings = Rx.Observable.interval(1000);
* var result = clicks.<span class="apidocCodeKeywordSpan">windowToggle</span>(openings, i =&gt;
*   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
* ).mergeAll();
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link window}
* @see {@link windowCount}
* @see {@link windowTime}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.windowWhen" id="apidoc.element.rxjs.Observable.prototype.windowWhen">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>windowWhen
        <span class="apidocSignatureSpan">(closingSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function windowWhen(closingSelector) {
    return this.lift(new WindowOperator(closingSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* It emits the current window and opens a new one whenever the Observable
* produced by the specified `closingSelector` function emits an item. The first
* window is opened immediately when subscribing to the output Observable.
*
* @example &lt;caption&gt;Emit only the first two clicks events in every window of [1-5] random seconds&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks
*   .<span class="apidocCodeKeywordSpan">windowWhen</span>(() =&gt; Rx.Observable.interval(1000 + Math.random() * 4000))
*   .map(win =&gt; win.take(2)) // each window has at most 2 emissions
*   .mergeAll(); // flatten the Observable-of-Observables
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link window}
* @see {@link windowCount}
* @see {@link windowTime}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.withLatestFrom" id="apidoc.element.rxjs.Observable.prototype.withLatestFrom">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>withLatestFrom
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var project;
    if (typeof args[args.length - 1] === 'function') {
        project = args.pop();
    }
    var observables = args;
    return this.lift(new WithLatestFromOperator(observables, project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the source emits a value, optionally using a `project` function to determine
* the value to be emitted on the output Observable. All input Observables must
* emit at least one value before the output Observable will emit a value.
*
* @example &lt;caption&gt;On every click event, emit an array with the latest timer event plus the click event&lt;/caption
&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var timer = Rx.Observable.interval(1000);
* var result = clicks.<span class="apidocCodeKeywordSpan">withLatestFrom</span>(timer);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link combineLatest}
*
* @param {ObservableInput} other An input Observable to combine with the source
* Observable. More than one input Observables may be given as argument.
* @param {Function} [project] Projection function for combining values
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.zip" id="apidoc.element.rxjs.Observable.prototype.zip">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>zip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zipProto() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Observable.prototype.zipAll" id="apidoc.element.rxjs.Observable.prototype.zipAll">
        function <span class="apidocSignatureSpan">rxjs.Observable.prototype.</span>zipAll
        <span class="apidocSignatureSpan">(project)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zipAll(project) {
    return this.lift(new zip_1.ZipOperator(project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.OuterSubscriber" id="apidoc.module.rxjs.OuterSubscriber">module rxjs.OuterSubscriber</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.OuterSubscriber.OuterSubscriber" id="apidoc.element.rxjs.OuterSubscriber.OuterSubscriber">
        function <span class="apidocSignatureSpan">rxjs.</span>OuterSubscriber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OuterSubscriber() {
    _super.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.PairsObservable" id="apidoc.module.rxjs.PairsObservable">module rxjs.PairsObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.PairsObservable.PairsObservable" id="apidoc.element.rxjs.PairsObservable.PairsObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>PairsObservable
        <span class="apidocSignatureSpan">(obj, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PairsObservable(obj, scheduler) {
    _super.call(this);
    this.obj = obj;
    this.scheduler = scheduler;
    this.keys = Object.keys(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.PromiseObservable" id="apidoc.module.rxjs.PromiseObservable">module rxjs.PromiseObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.PromiseObservable.PromiseObservable" id="apidoc.element.rxjs.PromiseObservable.PromiseObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>PromiseObservable
        <span class="apidocSignatureSpan">(promise, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PromiseObservable(promise, scheduler) {
    _super.call(this);
    this.promise = promise;
    this.scheduler = scheduler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    return new FromObservable(ish, scheduler);
}
else if (isArray_1.isArray(ish)) {
    return new ArrayObservable_1.ArrayObservable(ish, scheduler);
}
else if (isPromise_1.isPromise(ish)) {
    return new PromiseObservable_1.<span class="apidocCodeKeywordSpan">PromiseObservable</span>(ish, scheduler);
}
else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
    return new IteratorObservable_1.IteratorObservable(ish, scheduler);
}
else if (isArrayLike_1.isArrayLike(ish)) {
    return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.QueueAction" id="apidoc.module.rxjs.QueueAction">module rxjs.QueueAction</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.QueueAction.QueueAction" id="apidoc.element.rxjs.QueueAction.QueueAction">
        function <span class="apidocSignatureSpan">rxjs.</span>QueueAction
        <span class="apidocSignatureSpan">(scheduler, work)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueueAction(scheduler, work) {
    _super.call(this, scheduler, work);
    this.scheduler = scheduler;
    this.work = work;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.QueueScheduler" id="apidoc.module.rxjs.QueueScheduler">module rxjs.QueueScheduler</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.QueueScheduler.QueueScheduler" id="apidoc.element.rxjs.QueueScheduler.QueueScheduler">
        function <span class="apidocSignatureSpan">rxjs.</span>QueueScheduler
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueueScheduler() {
    _super.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
exports.queue = new QueueScheduler_1.<span class="apidocCodeKeywordSpan">QueueScheduler</span>(QueueAction_1.QueueAction);
//# sourceMappingURL=queue.js.map
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.RangeObservable" id="apidoc.module.rxjs.RangeObservable">module rxjs.RangeObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.RangeObservable.RangeObservable" id="apidoc.element.rxjs.RangeObservable.RangeObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>RangeObservable
        <span class="apidocSignatureSpan">(start, count, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RangeObservable(start, count, scheduler) {
    _super.call(this);
    this.start = start;
    this._count = count;
    this.scheduler = scheduler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ReplaySubject" id="apidoc.module.rxjs.ReplaySubject">module rxjs.ReplaySubject</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ReplaySubject.ReplaySubject" id="apidoc.element.rxjs.ReplaySubject.ReplaySubject">
        function <span class="apidocSignatureSpan">rxjs.</span>ReplaySubject
        <span class="apidocSignatureSpan">(bufferSize, windowTime, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReplaySubject(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
    _super.call(this);
    this.scheduler = scheduler;
    this._events = [];
    this._bufferSize = bufferSize &lt; 1 ? 1 : bufferSize;
    this._windowTime = windowTime &lt; 1 ? 1 : windowTime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {ConnectableObservable&lt;T&gt;}
 * @method publishReplay
 * @owner Observable
 */
function publishReplay(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
    return multicast_1.multicast.call(this, new ReplaySubject_1.<span class="apidocCodeKeywordSpan">ReplaySubject</span>(bufferSize
, windowTime, scheduler));
}
exports.publishReplay = publishReplay;
//# sourceMappingURL=publishReplay.js.map
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ReplaySubject.create" id="apidoc.element.rxjs.ReplaySubject.create">
        function <span class="apidocSignatureSpan">rxjs.ReplaySubject.</span>create
        <span class="apidocSignatureSpan">(destination, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (destination, source) {
    return new AnonymousSubject(destination, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



"use strict";
var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.<span class="apidocCodeKeywordSpan">create</span>(b) : (__.prototype = b.prototype, new __
());
};
var Subject_1 = require('./Subject');
var Subscription_1 = require('./Subscription');
/**
 * @class AsyncSubject&lt;T&gt;
 */
var AsyncSubject = (function (_super) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ReplaySubject.prototype" id="apidoc.module.rxjs.ReplaySubject.prototype">module rxjs.ReplaySubject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ReplaySubject.prototype._getNow" id="apidoc.element.rxjs.ReplaySubject.prototype._getNow">
        function <span class="apidocSignatureSpan">rxjs.ReplaySubject.prototype.</span>_getNow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getNow = function () {
    return (this.scheduler || queue_1.queue).now();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    _super.call(this);
    this.scheduler = scheduler;
    this._events = [];
    this._bufferSize = bufferSize &lt; 1 ? 1 : bufferSize;
    this._windowTime = windowTime &lt; 1 ? 1 : windowTime;
}
ReplaySubject.prototype.next = function (value) {
    var now = this.<span class="apidocCodeKeywordSpan">_getNow</span>();
    this._events.push(new ReplayEvent(now, value));
    this._trimBufferThenGetEvents();
    _super.prototype.next.call(this, value);
};
ReplaySubject.prototype._subscribe = function (subscriber) {
    var _events = this._trimBufferThenGetEvents();
    var scheduler = this.scheduler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ReplaySubject.prototype._subscribe" id="apidoc.element.rxjs.ReplaySubject.prototype._subscribe">
        function <span class="apidocSignatureSpan">rxjs.ReplaySubject.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(subscriber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (subscriber) {
    var _events = this._trimBufferThenGetEvents();
    var scheduler = this.scheduler;
    var subscription;
    if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
    }
    else if (this.hasError) {
        subscription = Subscription_1.Subscription.EMPTY;
    }
    else if (this.isStopped) {
        subscription = Subscription_1.Subscription.EMPTY;
    }
    else {
        this.observers.push(subscriber);
        subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
    }
    if (scheduler) {
        subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
    }
    var len = _events.length;
    for (var i = 0; i &lt; len &amp;&amp; !subscriber.closed; i++) {
        subscriber.next(_events[i].value);
    }
    if (this.hasError) {
        subscriber.error(this.thrownError);
    }
    else if (this.isStopped) {
        subscriber.complete();
    }
    return subscription;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            throw sink.syncErrorValue;
        }
    }
    return sink;
};
Observable.prototype._trySubscribe = function (sink) {
    try {
        return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(sink);
    }
    catch (err) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
        sink.error(err);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ReplaySubject.prototype._trimBufferThenGetEvents" id="apidoc.element.rxjs.ReplaySubject.prototype._trimBufferThenGetEvents">
        function <span class="apidocSignatureSpan">rxjs.ReplaySubject.prototype.</span>_trimBufferThenGetEvents
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_trimBufferThenGetEvents = function () {
    var now = this._getNow();
    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
    var spliceCount = 0;
    // Trim events that fall out of the time window.
    // Start at the front of the list. Break early once
    // we encounter an event that falls within the window.
    while (spliceCount &lt; eventsCount) {
        if ((now - _events[spliceCount].time) &lt; _windowTime) {
            break;
        }
        spliceCount++;
    }
    if (eventsCount &gt; _bufferSize) {
        spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount &gt; 0) {
        _events.splice(0, spliceCount);
    }
    return _events;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._events = [];
    this._bufferSize = bufferSize &lt; 1 ? 1 : bufferSize;
    this._windowTime = windowTime &lt; 1 ? 1 : windowTime;
}
ReplaySubject.prototype.next = function (value) {
    var now = this._getNow();
    this._events.push(new ReplayEvent(now, value));
    this.<span class="apidocCodeKeywordSpan">_trimBufferThenGetEvents</span>();
    _super.prototype.next.call(this, value);
};
ReplaySubject.prototype._subscribe = function (subscriber) {
    var _events = this._trimBufferThenGetEvents();
    var scheduler = this.scheduler;
    var subscription;
    if (this.closed) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ReplaySubject.prototype.constructor" id="apidoc.element.rxjs.ReplaySubject.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.ReplaySubject.prototype.</span>constructor
        <span class="apidocSignatureSpan">(bufferSize, windowTime, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReplaySubject(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
    _super.call(this);
    this.scheduler = scheduler;
    this._events = [];
    this._bufferSize = bufferSize &lt; 1 ? 1 : bufferSize;
    this._windowTime = windowTime &lt; 1 ? 1 : windowTime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.ReplaySubject.prototype.next" id="apidoc.element.rxjs.ReplaySubject.prototype.next">
        function <span class="apidocSignatureSpan">rxjs.ReplaySubject.prototype.</span>next
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (value) {
    var now = this._getNow();
    this._events.push(new ReplayEvent(now, value));
    this._trimBufferThenGetEvents();
    _super.prototype.next.call(this, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.<span class="apidocCodeKeywordSpan">next</span>(this.value);
        subscriber.complete();
        return Subscription_1.Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
};
AsyncSubject.prototype.next = function (value) {
    if (!this.hasCompleted) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ScalarObservable" id="apidoc.module.rxjs.ScalarObservable">module rxjs.ScalarObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ScalarObservable.ScalarObservable" id="apidoc.element.rxjs.ScalarObservable.ScalarObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>ScalarObservable
        <span class="apidocSignatureSpan">(value, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ScalarObservable(value, scheduler) {
    _super.call(this);
    this.value = value;
    this.scheduler = scheduler;
    this._isScalar = true;
    if (scheduler) {
        this._isScalar = false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
ArrayLikeObservable.create = function (arrayLike, scheduler) {
    var length = arrayLike.length;
    if (length === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    else if (length === 1) {
        return new ScalarObservable_1.<span class="apidocCodeKeywordSpan">ScalarObservable</span>(arrayLike[0], scheduler);
    }
    else {
        return new ArrayLikeObservable(arrayLike, scheduler);
    }
};
ArrayLikeObservable.dispatch = function (state) {
    var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Scheduler" id="apidoc.module.rxjs.Scheduler">module rxjs.Scheduler</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Scheduler.Scheduler" id="apidoc.element.rxjs.Scheduler.Scheduler">
        function <span class="apidocSignatureSpan">rxjs.</span>Scheduler
        <span class="apidocSignatureSpan">(SchedulerAction, now)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Scheduler(SchedulerAction, now) {
    if (now === void 0) { now = Scheduler.now; }
    this.SchedulerAction = SchedulerAction;
    this.now = now;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Set" id="apidoc.module.rxjs.Set">module rxjs.Set</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Set.Set" id="apidoc.element.rxjs.Set.Set">
        function <span class="apidocSignatureSpan">rxjs.</span>Set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Set() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @extends {Ignored}
 */
var DistinctSubscriber = (function (_super) {
__extends(DistinctSubscriber, _super);
function DistinctSubscriber(destination, keySelector, flushes) {
    _super.call(this, destination);
    this.keySelector = keySelector;
    this.values = new Set_1.<span class="apidocCodeKeywordSpan">Set</span>();
    if (flushes) {
        this.add(subscribeToResult_1.subscribeToResult(this, flushes));
    }
}
DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.values.clear();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Set.minimalSetImpl" id="apidoc.element.rxjs.Set.minimalSetImpl">
        function <span class="apidocSignatureSpan">rxjs.Set.</span>minimalSetImpl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minimalSetImpl() {
    // THIS IS NOT a full impl of Set, this is just the minimum
    // bits of functionality we need for this library.
    return (function () {
        function MinimalSet() {
            this._values = [];
        }
        MinimalSet.prototype.add = function (value) {
            if (!this.has(value)) {
                this._values.push(value);
            }
        };
        MinimalSet.prototype.has = function (value) {
            return this._values.indexOf(value) !== -1;
        };
        Object.defineProperty(MinimalSet.prototype, "size", {
            get: function () {
                return this._values.length;
            },
            enumerable: true,
            configurable: true
        });
        MinimalSet.prototype.clear = function () {
            this._values.length = 0;
        };
        return MinimalSet;
    }());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Subject" id="apidoc.module.rxjs.Subject">module rxjs.Subject</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Subject.Subject" id="apidoc.element.rxjs.Subject.Subject">
        function <span class="apidocSignatureSpan">rxjs.</span>Subject
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subject() {
    _super.call(this);
    this.observers = [];
    this.closed = false;
    this.isStopped = false;
    this.hasError = false;
    this.thrownError = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.error(err);
    }
}
else {
    element = value;
}
if (!group) {
    group = this.subjectSelector ? this.subjectSelector() : new Subject_1.<span class="apidocCodeKeywordSpan">Subject</span>();
    groups.set(key, group);
    var groupedObservable = new GroupedObservable(key, group, this);
    this.destination.next(groupedObservable);
    if (this.durationSelector) {
        var duration = void 0;
        try {
            duration = this.durationSelector(new GroupedObservable(key, group));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subject.create" id="apidoc.element.rxjs.Subject.create">
        function <span class="apidocSignatureSpan">rxjs.Subject.</span>create
        <span class="apidocSignatureSpan">(destination, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (destination, source) {
    return new AnonymousSubject(destination, source);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



"use strict";
var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.<span class="apidocCodeKeywordSpan">create</span>(b) : (__.prototype = b.prototype, new __
());
};
var Subject_1 = require('./Subject');
var Subscription_1 = require('./Subscription');
/**
 * @class AsyncSubject&lt;T&gt;
 */
var AsyncSubject = (function (_super) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Subject.prototype" id="apidoc.module.rxjs.Subject.prototype">module rxjs.Subject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Subject.prototype._subscribe" id="apidoc.element.rxjs.Subject.prototype._subscribe">
        function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>_subscribe
        <span class="apidocSignatureSpan">(subscriber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_subscribe = function (subscriber) {
    if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
    }
    else if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.isStopped) {
        subscriber.complete();
        return Subscription_1.Subscription.EMPTY;
    }
    else {
        this.observers.push(subscriber);
        return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            throw sink.syncErrorValue;
        }
    }
    return sink;
};
Observable.prototype._trySubscribe = function (sink) {
    try {
        return this.<span class="apidocCodeKeywordSpan">_subscribe</span>(sink);
    }
    catch (err) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
        sink.error(err);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subject.prototype._trySubscribe" id="apidoc.element.rxjs.Subject.prototype._trySubscribe">
        function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>_trySubscribe
        <span class="apidocSignatureSpan">(subscriber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_trySubscribe = function (subscriber) {
    if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
    }
    else {
        return _super.prototype._trySubscribe.call(this, subscriber);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
var operator = this.operator;
var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
if (operator) {
    operator.call(sink, this.source);
}
else {
    sink.add(this.<span class="apidocCodeKeywordSpan">_trySubscribe</span>(sink));
}
if (sink.syncErrorThrowable) {
    sink.syncErrorThrowable = false;
    if (sink.syncErrorThrown) {
        throw sink.syncErrorValue;
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subject.prototype.asObservable" id="apidoc.element.rxjs.Subject.prototype.asObservable">
        function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>asObservable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asObservable = function () {
    var observable = new Observable_1.Observable();
    observable.source = this;
    return observable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subject.prototype.complete" id="apidoc.element.rxjs.Subject.prototype.complete">
        function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>complete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">complete = function () {
    if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
    }
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();
    for (var i = 0; i &lt; len; i++) {
        copy[i].complete();
    }
    this.observers.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.next(this.value);
        subscriber.<span class="apidocCodeKeywordSpan">complete</span>();
        return Subscription_1.Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
};
AsyncSubject.prototype.next = function (value) {
    if (!this.hasCompleted) {
        this.value = value;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subject.prototype.constructor" id="apidoc.element.rxjs.Subject.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subject() {
    _super.call(this);
    this.observers = [];
    this.closed = false;
    this.isStopped = false;
    this.hasError = false;
    this.thrownError = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subject.prototype.error" id="apidoc.element.rxjs.Subject.prototype.error">
        function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>error
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (err) {
    if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
    }
    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();
    for (var i = 0; i &lt; len; i++) {
        copy[i].error(err);
    }
    this.observers.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    _super.apply(this, arguments);
    this.value = null;
    this.hasNext = false;
    this.hasCompleted = false;
}
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.<span class="apidocCodeKeywordSpan">error</span>(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.next(this.value);
        subscriber.complete();
        return Subscription_1.Subscription.EMPTY;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subject.prototype.lift" id="apidoc.element.rxjs.Subject.prototype.lift">
        function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>lift
        <span class="apidocSignatureSpan">(operator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lift = function (operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        else {
            this._connection = connection;
        }
    }
    return connection;
};
ConnectableObservable.prototype.refCount = function () {
    return this.<span class="apidocCodeKeywordSpan">lift</span>(new RefCountOperator(this));
};
return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = {
operator: { value: null },
_refCount: { value: 0, writable: true },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subject.prototype.next" id="apidoc.element.rxjs.Subject.prototype.next">
        function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>next
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (value) {
    if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
    }
    if (!this.isStopped) {
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i &lt; len; i++) {
            copy[i].next(value);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.<span class="apidocCodeKeywordSpan">next</span>(this.value);
        subscriber.complete();
        return Subscription_1.Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
};
AsyncSubject.prototype.next = function (value) {
    if (!this.hasCompleted) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subject.prototype.unsubscribe" id="apidoc.element.rxjs.Subject.prototype.unsubscribe">
        function <span class="apidocSignatureSpan">rxjs.Subject.prototype.</span>unsubscribe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function () {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.<span class="apidocCodeKeywordSpan">unsubscribe</span>();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.SubjectSubscription" id="apidoc.module.rxjs.SubjectSubscription">module rxjs.SubjectSubscription</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.SubjectSubscription.SubjectSubscription" id="apidoc.element.rxjs.SubjectSubscription.SubjectSubscription">
        function <span class="apidocSignatureSpan">rxjs.</span>SubjectSubscription
        <span class="apidocSignatureSpan">(subject, subscriber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SubjectSubscription(subject, subscriber) {
    _super.call(this);
    this.subject = subject;
    this.subscriber = subscriber;
    this.closed = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    subscription = Subscription_1.Subscription.EMPTY;
}
else if (this.isStopped) {
    subscription = Subscription_1.Subscription.EMPTY;
}
else {
    this.observers.push(subscriber);
    subscription = new SubjectSubscription_1.<span class="apidocCodeKeywordSpan">SubjectSubscription</span>(this, subscriber);
}
if (scheduler) {
    subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
}
var len = _events.length;
for (var i = 0; i &lt; len &amp;&amp; !subscriber.closed; i++) {
    subscriber.next(_events[i].value);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.SubscribeOnObservable" id="apidoc.module.rxjs.SubscribeOnObservable">module rxjs.SubscribeOnObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.SubscribeOnObservable.SubscribeOnObservable" id="apidoc.element.rxjs.SubscribeOnObservable.SubscribeOnObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>SubscribeOnObservable
        <span class="apidocSignatureSpan">(source, delayTime, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SubscribeOnObservable(source, delayTime, scheduler) {
    if (delayTime === void 0) { delayTime = 0; }
    if (scheduler === void 0) { scheduler = asap_1.asap; }
    _super.call(this);
    this.source = source;
    this.delayTime = delayTime;
    this.scheduler = scheduler;
    if (!isNumeric_1.isNumeric(delayTime) || delayTime &lt; 0) {
        this.delayTime = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        this.scheduler = asap_1.asap;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.subscribeOn = subscribeOn;
var SubscribeOnOperator = (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable_1.<span class="apidocCodeKeywordSpan">SubscribeOnObservable</span>(source, this.delay,
this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());
//# sourceMappingURL=subscribeOn.js.map
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Subscriber" id="apidoc.module.rxjs.Subscriber">module rxjs.Subscriber</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Subscriber.Subscriber" id="apidoc.element.rxjs.Subscriber.Subscriber">
        function <span class="apidocSignatureSpan">rxjs.</span>Subscriber
        <span class="apidocSignatureSpan">(destinationOrNext, error, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subscriber(destinationOrNext, error, complete) {
    _super.call(this);
    this.syncErrorValue = null;
    this.syncErrorThrown = false;
    this.syncErrorThrowable = false;
    this.isStopped = false;
    switch (arguments.length) {
        case 0:
            this.destination = Observer_1.empty;
            break;
        case 1:
            if (!destinationOrNext) {
                this.destination = Observer_1.empty;
                break;
            }
            if (typeof destinationOrNext === 'object') {
                if (destinationOrNext instanceof Subscriber) {
                    this.destination = destinationOrNext;
                    this.destination.add(this);
                }
                else {
                    this.syncErrorThrowable = true;
                    this.destination = new SafeSubscriber(this, destinationOrNext);
                }
                break;
            }
        default:
            this.syncErrorThrowable = true;
            this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
            break;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = (function (_super) {
__extends(DoSubscriber, _super);
function DoSubscriber(destination, nextOrObserver, error, complete) {
    _super.call(this, destination);
    var safeSubscriber = new Subscriber_1.<span class="apidocCodeKeywordSpan">Subscriber</span>(nextOrObserver, error, complete);
    safeSubscriber.syncErrorThrowable = true;
    this.add(safeSubscriber);
    this.safeSubscriber = safeSubscriber;
}
DoSubscriber.prototype._next = function (value) {
    var safeSubscriber = this.safeSubscriber;
    safeSubscriber.next(value);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscriber.create" id="apidoc.element.rxjs.Subscriber.create">
        function <span class="apidocSignatureSpan">rxjs.Subscriber.</span>create
        <span class="apidocSignatureSpan">(next, error, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (next, error, complete) {
    var subscriber = new Subscriber(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



"use strict";
var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.<span class="apidocCodeKeywordSpan">create</span>(b) : (__.prototype = b.prototype, new __
());
};
var Subject_1 = require('./Subject');
var Subscription_1 = require('./Subscription');
/**
 * @class AsyncSubject&lt;T&gt;
 */
var AsyncSubject = (function (_super) {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Subscriber.prototype" id="apidoc.module.rxjs.Subscriber.prototype">module rxjs.Subscriber.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Subscriber.prototype._complete" id="apidoc.element.rxjs.Subscriber.prototype._complete">
        function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>_complete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_complete = function () {
    this.destination.complete();
    this.unsubscribe();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * `complete` from the Observable. Notifies the Observer that the Observable
 * has finished sending push-based notifications.
 * @return {void}
 */
Subscriber.prototype.complete = function () {
    if (!this.isStopped) {
        this.isStopped = true;
        this.<span class="apidocCodeKeywordSpan">_complete</span>();
    }
};
Subscriber.prototype.unsubscribe = function () {
    if (this.closed) {
        return;
    }
    this.isStopped = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscriber.prototype._error" id="apidoc.element.rxjs.Subscriber.prototype._error">
        function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>_error
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_error = function (err) {
    this.destination.error(err);
    this.unsubscribe();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * the Observable has experienced an error condition.
 * @param {any} [err] The `error` exception.
 * @return {void}
 */
Subscriber.prototype.error = function (err) {
    if (!this.isStopped) {
        this.isStopped = true;
        this.<span class="apidocCodeKeywordSpan">_error</span>(err);
    }
};
/**
 * The {@link Observer} callback to receive a valueless notification of type
 * `complete` from the Observable. Notifies the Observer that the Observable
 * has finished sending push-based notifications.
 * @return {void}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscriber.prototype._next" id="apidoc.element.rxjs.Subscriber.prototype._next">
        function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>_next
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_next = function (value) {
    this.destination.next(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * the Observable, with a value. The Observable may call this method 0 or more
 * times.
 * @param {T} [value] The `next` value.
 * @return {void}
 */
Subscriber.prototype.next = function (value) {
    if (!this.isStopped) {
        this.<span class="apidocCodeKeywordSpan">_next</span>(value);
    }
};
/**
 * The {@link Observer} callback to receive notifications of type `error` from
 * the Observable, with an attached {@link Error}. Notifies the Observer that
 * the Observable has experienced an error condition.
 * @param {any} [err] The `error` exception.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscriber.prototype._unsubscribeAndRecycle" id="apidoc.element.rxjs.Subscriber.prototype._unsubscribeAndRecycle">
        function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>_unsubscribeAndRecycle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_unsubscribeAndRecycle = function () {
    var _a = this, _parent = _a._parent, _parents = _a._parents;
    this._parent = null;
    this._parents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parent = _parent;
    this._parents = _parents;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this.<span class="apidocCodeKeywordSpan">_unsubscribeAndRecycle</span>();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=catch.js.map
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscriber.prototype.complete" id="apidoc.element.rxjs.Subscriber.prototype.complete">
        function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>complete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">complete = function () {
    if (!this.isStopped) {
        this.isStopped = true;
        this._complete();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.next(this.value);
        subscriber.<span class="apidocCodeKeywordSpan">complete</span>();
        return Subscription_1.Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
};
AsyncSubject.prototype.next = function (value) {
    if (!this.hasCompleted) {
        this.value = value;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscriber.prototype.constructor" id="apidoc.element.rxjs.Subscriber.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>constructor
        <span class="apidocSignatureSpan">(destinationOrNext, error, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subscriber(destinationOrNext, error, complete) {
    _super.call(this);
    this.syncErrorValue = null;
    this.syncErrorThrown = false;
    this.syncErrorThrowable = false;
    this.isStopped = false;
    switch (arguments.length) {
        case 0:
            this.destination = Observer_1.empty;
            break;
        case 1:
            if (!destinationOrNext) {
                this.destination = Observer_1.empty;
                break;
            }
            if (typeof destinationOrNext === 'object') {
                if (destinationOrNext instanceof Subscriber) {
                    this.destination = destinationOrNext;
                    this.destination.add(this);
                }
                else {
                    this.syncErrorThrowable = true;
                    this.destination = new SafeSubscriber(this, destinationOrNext);
                }
                break;
            }
        default:
            this.syncErrorThrowable = true;
            this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
            break;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscriber.prototype.error" id="apidoc.element.rxjs.Subscriber.prototype.error">
        function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>error
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (err) {
    if (!this.isStopped) {
        this.isStopped = true;
        this._error(err);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    _super.apply(this, arguments);
    this.value = null;
    this.hasNext = false;
    this.hasCompleted = false;
}
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.<span class="apidocCodeKeywordSpan">error</span>(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.next(this.value);
        subscriber.complete();
        return Subscription_1.Subscription.EMPTY;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscriber.prototype.next" id="apidoc.element.rxjs.Subscriber.prototype.next">
        function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>next
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (value) {
    if (!this.isStopped) {
        this._next(value);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
AsyncSubject.prototype._subscribe = function (subscriber) {
    if (this.hasError) {
        subscriber.error(this.thrownError);
        return Subscription_1.Subscription.EMPTY;
    }
    else if (this.hasCompleted &amp;&amp; this.hasNext) {
        subscriber.<span class="apidocCodeKeywordSpan">next</span>(this.value);
        subscriber.complete();
        return Subscription_1.Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
};
AsyncSubject.prototype.next = function (value) {
    if (!this.hasCompleted) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscriber.prototype.unsubscribe" id="apidoc.element.rxjs.Subscriber.prototype.unsubscribe">
        function <span class="apidocSignatureSpan">rxjs.Subscriber.prototype.</span>unsubscribe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function () {
    if (this.closed) {
        return;
    }
    this.isStopped = true;
    _super.prototype.unsubscribe.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.<span class="apidocCodeKeywordSpan">unsubscribe</span>();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Subscription" id="apidoc.module.rxjs.Subscription">module rxjs.Subscription</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Subscription.Subscription" id="apidoc.element.rxjs.Subscription.Subscription">
        function <span class="apidocSignatureSpan">rxjs.</span>Subscription
        <span class="apidocSignatureSpan">(unsubscribe)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Subscription(unsubscribe) {
<span class="apidocCodeCommentSpan">    /**
     * A flag to indicate whether this Subscription has already been unsubscribed.
     * @type {boolean}
     */
</span>    this.closed = false;
    this._parent = null;
    this._parents = null;
    this._subscriptions = null;
    if (unsubscribe) {
        this._unsubscribe = unsubscribe;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this._subject = this.subjectFactory();
    }
    return this._subject;
};
ConnectableObservable.prototype.connect = function () {
    var connection = this._connection;
    if (!connection) {
        connection = this._connection = new Subscription_1.<span class="apidocCodeKeywordSpan">Subscription</span>();
        connection.add(this.source
            .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
        if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
        }
        else {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.Subscription.prototype" id="apidoc.module.rxjs.Subscription.prototype">module rxjs.Subscription.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.Subscription.prototype._addParent" id="apidoc.element.rxjs.Subscription.prototype._addParent">
        function <span class="apidocSignatureSpan">rxjs.Subscription.prototype.</span>_addParent
        <span class="apidocSignatureSpan">(parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addParent = function (parent) {
    var _a = this, _parent = _a._parent, _parents = _a._parents;
    if (!_parent || _parent === parent) {
        // If we don't have a parent, or the new parent is the same as the
        // current parent, then set this._parent to the new parent.
        this._parent = parent;
    }
    else if (!_parents) {
        // If there's already one parent, but not multiple, allocate an Array to
        // store the rest of the parent Subscriptions.
        this._parents = [parent];
    }
    else if (_parents.indexOf(parent) === -1) {
        // Only add the new parent to the _parents list if it's not already there.
        _parents.push(parent);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }
            break;
        default:
            throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
    }
    var subscriptions = this._subscriptions || (this._subscriptions = []);
    subscriptions.push(subscription);
    subscription.<span class="apidocCodeKeywordSpan">_addParent</span>(this);
    return subscription;
};
/**
 * Removes a Subscription from the internal list of subscriptions that will
 * unsubscribe during the unsubscribe process of this Subscription.
 * @param {Subscription} subscription The subscription to remove.
 * @return {void}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscription.prototype.add" id="apidoc.element.rxjs.Subscription.prototype.add">
        function <span class="apidocSignatureSpan">rxjs.Subscription.prototype.</span>add
        <span class="apidocSignatureSpan">(teardown)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (teardown) {
    if (!teardown || (teardown === Subscription.EMPTY)) {
        return Subscription.EMPTY;
    }
    if (teardown === this) {
        return this;
    }
    var subscription = teardown;
    switch (typeof teardown) {
        case 'function':
            subscription = new Subscription(teardown);
        case 'object':
            if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                return subscription;
            }
            else if (this.closed) {
                subscription.unsubscribe();
                return subscription;
            }
            else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                var tmp = subscription;
                subscription = new Subscription();
                subscription._subscriptions = [tmp];
            }
            break;
        default:
            throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
    }
    var subscriptions = this._subscriptions || (this._subscriptions = []);
    subscriptions.push(subscription);
    subscription._addParent(this);
    return subscription;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
var operator = this.operator;
var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
if (operator) {
    operator.call(sink, this.source);
}
else {
    sink.<span class="apidocCodeKeywordSpan">add</span>(this._trySubscribe(sink));
}
if (sink.syncErrorThrowable) {
    sink.syncErrorThrowable = false;
    if (sink.syncErrorThrown) {
        throw sink.syncErrorValue;
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscription.prototype.remove" id="apidoc.element.rxjs.Subscription.prototype.remove">
        function <span class="apidocSignatureSpan">rxjs.Subscription.prototype.</span>remove
        <span class="apidocSignatureSpan">(subscription)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (subscription) {
    var subscriptions = this._subscriptions;
    if (subscriptions) {
        var subscriptionIndex = subscriptions.indexOf(subscription);
        if (subscriptionIndex !== -1) {
            subscriptions.splice(subscriptionIndex, 1);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// to remove themselves from this subscription will noop
this._subscriptions = null;
var index = -1;
var len = _parents ? _parents.length : 0;
// if this._parent is null, then so is this._parents, and we
// don't have to remove ourselves from any parent subscriptions.
while (_parent) {
    _parent.<span class="apidocCodeKeywordSpan">remove</span>(this);
    // if this._parents is null or index &gt;= len,
    // then _parent is set to null, and the loop exits
    _parent = ++index &lt; len &amp;&amp; _parents[index] || null;
}
if (isFunction_1.isFunction(_unsubscribe)) {
    var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
    if (trial === errorObject_1.errorObject) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.Subscription.prototype.unsubscribe" id="apidoc.element.rxjs.Subscription.prototype.unsubscribe">
        function <span class="apidocSignatureSpan">rxjs.Subscription.prototype.</span>unsubscribe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unsubscribe = function () {
    var hasErrors = false;
    var errors;
    if (this.closed) {
        return;
    }
    var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions
;
    this.closed = true;
    this._parent = null;
    this._parents = null;
    // null out _subscriptions first so any child subscriptions that attempt
    // to remove themselves from this subscription will noop
    this._subscriptions = null;
    var index = -1;
    var len = _parents ? _parents.length : 0;
    // if this._parent is null, then so is this._parents, and we
    // don't have to remove ourselves from any parent subscriptions.
    while (_parent) {
        _parent.remove(this);
        // if this._parents is null or index &gt;= len,
        // then _parent is set to null, and the loop exits
        _parent = ++index &lt; len &amp;&amp; _parents[index] || null;
    }
    if (isFunction_1.isFunction(_unsubscribe)) {
        var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
        if (trial === errorObject_1.errorObject) {
            hasErrors = true;
            errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
        }
    }
    if (isArray_1.isArray(_subscriptions)) {
        index = -1;
        len = _subscriptions.length;
        while (++index &lt; len) {
            var sub = _subscriptions[index];
            if (isObject_1.isObject(sub)) {
                var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                if (trial === errorObject_1.errorObject) {
                    hasErrors = true;
                    errors = errors || [];
                    var err = errorObject_1.errorObject.e;
                    if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                        errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                    }
                    else {
                        errors.push(err);
                    }
                }
            }
        }
    }
    if (hasErrors) {
        throw new UnsubscriptionError_1.UnsubscriptionError(errors);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.<span class="apidocCodeKeywordSpan">unsubscribe</span>();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.SubscriptionLog" id="apidoc.module.rxjs.SubscriptionLog">module rxjs.SubscriptionLog</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.SubscriptionLog.SubscriptionLog" id="apidoc.element.rxjs.SubscriptionLog.SubscriptionLog">
        function <span class="apidocSignatureSpan">rxjs.</span>SubscriptionLog
        <span class="apidocSignatureSpan">(subscribedFrame, unsubscribedFrame)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SubscriptionLog(subscribedFrame, unsubscribedFrame) {
    if (unsubscribedFrame === void 0) { unsubscribedFrame = Number.POSITIVE_INFINITY; }
    this.subscribedFrame = subscribedFrame;
    this.unsubscribedFrame = unsubscribedFrame;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
"use strict";
var SubscriptionLog_1 = require('./SubscriptionLog');
var SubscriptionLoggable = (function () {
function SubscriptionLoggable() {
    this.subscriptions = [];
}
SubscriptionLoggable.prototype.logSubscribedFrame = function () {
    this.subscriptions.push(new SubscriptionLog_1.<span class="apidocCodeKeywordSpan">SubscriptionLog</span>(this.scheduler.now()));
    return this.subscriptions.length - 1;
};
SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {
    var subscriptionLogs = this.subscriptions;
    var oldSubscriptionLog = subscriptionLogs[index];
    subscriptionLogs[index] = new SubscriptionLog_1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.SubscriptionLoggable" id="apidoc.module.rxjs.SubscriptionLoggable">module rxjs.SubscriptionLoggable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.SubscriptionLoggable.SubscriptionLoggable" id="apidoc.element.rxjs.SubscriptionLoggable.SubscriptionLoggable">
        function <span class="apidocSignatureSpan">rxjs.</span>SubscriptionLoggable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SubscriptionLoggable() {
    this.subscriptions = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.TestScheduler" id="apidoc.module.rxjs.TestScheduler">module rxjs.TestScheduler</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler.TestScheduler" id="apidoc.element.rxjs.TestScheduler.TestScheduler">
        function <span class="apidocSignatureSpan">rxjs.</span>TestScheduler
        <span class="apidocSignatureSpan">(assertDeepEqual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TestScheduler(assertDeepEqual) {
    _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame);
    this.assertDeepEqual = assertDeepEqual;
    this.hotObservables = [];
    this.coldObservables = [];
    this.flushTests = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler.now" id="apidoc.element.rxjs.TestScheduler.now">
        function <span class="apidocSignatureSpan">rxjs.TestScheduler.</span>now
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function now() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    else if (this.isStopped) {
        subscriber.complete();
    }
    return subscription;
};
ReplaySubject.prototype._getNow = function () {
    return (this.scheduler || queue_1.queue).<span class="apidocCodeKeywordSpan">now</span>();
};
ReplaySubject.prototype._trimBufferThenGetEvents = function () {
    var now = this._getNow();
    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler.parseMarbles" id="apidoc.element.rxjs.TestScheduler.parseMarbles">
        function <span class="apidocSignatureSpan">rxjs.TestScheduler.</span>parseMarbles
        <span class="apidocSignatureSpan">(marbles, values, errorValue, materializeInnerObservables)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {
    if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }
    if (marbles.indexOf('!') !== -1) {
        throw new Error('conventional marble diagrams cannot have the ' +
            'unsubscription marker "!"');
    }
    var len = marbles.length;
    var testMessages = [];
    var subIndex = marbles.indexOf('^');
    var frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);
    var getValue = typeof values !== 'object' ?
        function (x) { return x; } :
        function (x) {
            // Support Observable-of-Observables
            if (materializeInnerObservables &amp;&amp; values[x] instanceof ColdObservable_1.ColdObservable) {
                return values[x].messages;
            }
            return values[x];
        };
    var groupStart = -1;
    for (var i = 0; i &lt; len; i++) {
        var frame = i * this.frameTimeFactor + frameOffset;
        var notification = void 0;
        var c = marbles[i];
        switch (c) {
            case '-':
            case ' ':
                break;
            case '(':
                groupStart = frame;
                break;
            case ')':
                groupStart = -1;
                break;
            case '|':
                notification = Notification_1.Notification.createComplete();
                break;
            case '^':
                break;
            case '#':
                notification = Notification_1.Notification.createError(errorValue || 'error');
                break;
            default:
                notification = Notification_1.Notification.createNext(getValue(c));
                break;
        }
        if (notification) {
            testMessages.push({ frame: groupStart &gt; -1 ? groupStart : frame, notification: notification });
        }
    }
    return testMessages;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
TestScheduler.prototype.createColdObservable = function (marbles, values, error) {
    if (marbles.indexOf('^') !== -1) {
        throw new Error('cold observable cannot have subscription offset "^"');
    }
    if (marbles.indexOf('!') !== -1) {
        throw new Error('cold observable cannot have unsubscription marker "!"');
    }
    var messages = TestScheduler.<span class="apidocCodeKeywordSpan">parseMarbles</span>(marbles, values, error);
    var cold = new ColdObservable_1.ColdObservable(messages, this);
    this.coldObservables.push(cold);
    return cold;
};
TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
    if (marbles.indexOf('!') !== -1) {
        throw new Error('hot observable cannot have unsubscription marker "!"');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler.parseMarblesAsSubscriptions" id="apidoc.element.rxjs.TestScheduler.parseMarblesAsSubscriptions">
        function <span class="apidocSignatureSpan">rxjs.TestScheduler.</span>parseMarblesAsSubscriptions
        <span class="apidocSignatureSpan">(marbles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMarblesAsSubscriptions = function (marbles) {
    if (typeof marbles !== 'string') {
        return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);
    }
    var len = marbles.length;
    var groupStart = -1;
    var subscriptionFrame = Number.POSITIVE_INFINITY;
    var unsubscriptionFrame = Number.POSITIVE_INFINITY;
    for (var i = 0; i &lt; len; i++) {
        var frame = i * this.frameTimeFactor;
        var c = marbles[i];
        switch (c) {
            case '-':
            case ' ':
                break;
            case '(':
                groupStart = frame;
                break;
            case ')':
                groupStart = -1;
                break;
            case '^':
                if (subscriptionFrame !== Number.POSITIVE_INFINITY) {
                    throw new Error('found a second subscription point \'^\' in a ' +
                        'subscription marble diagram. There can only be one.');
                }
                subscriptionFrame = groupStart &gt; -1 ? groupStart : frame;
                break;
            case '!':
                if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
                    throw new Error('found a second subscription point \'^\' in a ' +
                        'subscription marble diagram. There can only be one.');
                }
                unsubscriptionFrame = groupStart &gt; -1 ? groupStart : frame;
                break;
            default:
                throw new Error('there can only be \'^\' and \'!\' markers in a ' +
                    'subscription marble diagram. Found instead \'' + c + '\'.');
        }
    }
    if (unsubscriptionFrame &lt; 0) {
        return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);
    }
    else {
        return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {
    var _this = this;
    if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }
    var actual = [];
    var flushTest = { actual: actual, ready: false };
    var unsubscriptionFrame = TestScheduler
        .<span class="apidocCodeKeywordSpan">parseMarblesAsSubscriptions</span>(unsubscriptionMarbles).unsubscribedFrame;
    var subscription;
    this.schedule(function () {
        subscription = observable.subscribe(function (x) {
            var value = x;
            // Support Observable-of-Observables
            if (x instanceof Observable_1.Observable) {
                value = _this.materializeInnerObservable(value, _this.frame);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.TestScheduler.prototype" id="apidoc.module.rxjs.TestScheduler.prototype">module rxjs.TestScheduler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler.prototype.constructor" id="apidoc.element.rxjs.TestScheduler.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>constructor
        <span class="apidocSignatureSpan">(assertDeepEqual)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TestScheduler(assertDeepEqual) {
    _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame);
    this.assertDeepEqual = assertDeepEqual;
    this.hotObservables = [];
    this.coldObservables = [];
    this.flushTests = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler.prototype.createColdObservable" id="apidoc.element.rxjs.TestScheduler.prototype.createColdObservable">
        function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>createColdObservable
        <span class="apidocSignatureSpan">(marbles, values, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createColdObservable = function (marbles, values, error) {
    if (marbles.indexOf('^') !== -1) {
        throw new Error('cold observable cannot have subscription offset "^"');
    }
    if (marbles.indexOf('!') !== -1) {
        throw new Error('cold observable cannot have unsubscription marker "!"');
    }
    var messages = TestScheduler.parseMarbles(marbles, values, error);
    var cold = new ColdObservable_1.ColdObservable(messages, this);
    this.coldObservables.push(cold);
    return cold;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler.prototype.createHotObservable" id="apidoc.element.rxjs.TestScheduler.prototype.createHotObservable">
        function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>createHotObservable
        <span class="apidocSignatureSpan">(marbles, values, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createHotObservable = function (marbles, values, error) {
    if (marbles.indexOf('!') !== -1) {
        throw new Error('hot observable cannot have unsubscription marker "!"');
    }
    var messages = TestScheduler.parseMarbles(marbles, values, error);
    var subject = new HotObservable_1.HotObservable(messages, this);
    this.hotObservables.push(subject);
    return subject;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler.prototype.createTime" id="apidoc.element.rxjs.TestScheduler.prototype.createTime">
        function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>createTime
        <span class="apidocSignatureSpan">(marbles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTime = function (marbles) {
    var indexOf = marbles.indexOf('|');
    if (indexOf === -1) {
        throw new Error('marble diagram for time should have a completion marker "|"');
    }
    return indexOf * TestScheduler.frameTimeFactor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler.prototype.expectObservable" id="apidoc.element.rxjs.TestScheduler.prototype.expectObservable">
        function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>expectObservable
        <span class="apidocSignatureSpan">(observable, unsubscriptionMarbles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expectObservable = function (observable, unsubscriptionMarbles) {
    var _this = this;
    if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }
    var actual = [];
    var flushTest = { actual: actual, ready: false };
    var unsubscriptionFrame = TestScheduler
        .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;
    var subscription;
    this.schedule(function () {
        subscription = observable.subscribe(function (x) {
            var value = x;
            // Support Observable-of-Observables
            if (x instanceof Observable_1.Observable) {
                value = _this.materializeInnerObservable(value, _this.frame);
            }
            actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });
        }, function (err) {
            actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(err) });
        }, function () {
            actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });
        });
    }, 0);
    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
        this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);
    }
    this.flushTests.push(flushTest);
    return {
        toBe: function (marbles, values, errorValue) {
            flushTest.ready = true;
            flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler.prototype.expectSubscriptions" id="apidoc.element.rxjs.TestScheduler.prototype.expectSubscriptions">
        function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>expectSubscriptions
        <span class="apidocSignatureSpan">(actualSubscriptionLogs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expectSubscriptions = function (actualSubscriptionLogs) {
    var flushTest = { actual: actualSubscriptionLogs, ready: false };
    this.flushTests.push(flushTest);
    return {
        toBe: function (marbles) {
            var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;
            flushTest.ready = true;
            flushTest.expected = marblesArray.map(function (marbles) {
                return TestScheduler.parseMarblesAsSubscriptions(marbles);
            });
        }
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler.prototype.flush" id="apidoc.element.rxjs.TestScheduler.prototype.flush">
        function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {
    var hotObservables = this.hotObservables;
    while (hotObservables.length &gt; 0) {
        hotObservables.shift().setup();
    }
    _super.prototype.flush.call(this);
    var readyFlushTests = this.flushTests.filter(function (test) { return test.ready; });
    while (readyFlushTests.length &gt; 0) {
        var test = readyFlushTests.shift();
        this.assertDeepEqual(test.actual, test.expected);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
QueueAction.prototype.schedule = function (state, delay) {
    if (delay === void 0) { delay = 0; }
    if (delay &gt; 0) {
        return _super.prototype.schedule.call(this, state, delay);
    }
    this.delay = delay;
    this.state = state;
    this.scheduler.<span class="apidocCodeKeywordSpan">flush</span>(this);
    return this;
};
QueueAction.prototype.execute = function (state, delay) {
    return (delay &gt; 0 || this.closed) ?
        _super.prototype.execute.call(this, state, delay) :
        this._execute(state, delay);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TestScheduler.prototype.materializeInnerObservable" id="apidoc.element.rxjs.TestScheduler.prototype.materializeInnerObservable">
        function <span class="apidocSignatureSpan">rxjs.TestScheduler.prototype.</span>materializeInnerObservable
        <span class="apidocSignatureSpan">(observable, outerFrame)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">materializeInnerObservable = function (observable, outerFrame) {
    var _this = this;
    var messages = [];
    observable.subscribe(function (value) {
        messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createNext(value) });
    }, function (err) {
        messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createError(err) });
    }, function () {
        messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createComplete() });
    });
    return messages;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;
var subscription;
this.schedule(function () {
    subscription = observable.subscribe(function (x) {
        var value = x;
        // Support Observable-of-Observables
        if (x instanceof Observable_1.Observable) {
            value = _this.<span class="apidocCodeKeywordSpan">materializeInnerObservable</span>(value, _this.frame);
        }
        actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });
    }, function (err) {
        actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(err) });
    }, function () {
        actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });
    });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.TimeoutError" id="apidoc.module.rxjs.TimeoutError">module rxjs.TimeoutError</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.TimeoutError.TimeoutError" id="apidoc.element.rxjs.TimeoutError.TimeoutError">
        function <span class="apidocSignatureSpan">rxjs.</span>TimeoutError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError() {
    var err = _super.call(this, 'Timeout has occurred');
    this.name = err.name = 'TimeoutError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @method timeout
 * @owner Observable
 */
function timeout(due, scheduler) {
if (scheduler === void 0) { scheduler = async_1.async; }
var absoluteTimeout = isDate_1.isDate(due);
var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.<span class="apidocCodeKeywordSpan">
TimeoutError</span>()));
}
exports.timeout = timeout;
var TimeoutOperator = (function () {
function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
    this.waitFor = waitFor;
    this.absoluteTimeout = absoluteTimeout;
    this.scheduler = scheduler;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.TimeoutError.captureStackTrace" id="apidoc.element.rxjs.TimeoutError.captureStackTrace">
        function <span class="apidocSignatureSpan">rxjs.TimeoutError.</span>captureStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureStackTrace() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.TimeoutError.prototype" id="apidoc.module.rxjs.TimeoutError.prototype">module rxjs.TimeoutError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.TimeoutError.prototype.constructor" id="apidoc.element.rxjs.TimeoutError.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.TimeoutError.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError() {
    var err = _super.call(this, 'Timeout has occurred');
    this.name = err.name = 'TimeoutError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.TimerObservable" id="apidoc.module.rxjs.TimerObservable">module rxjs.TimerObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.TimerObservable.TimerObservable" id="apidoc.element.rxjs.TimerObservable.TimerObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>TimerObservable
        <span class="apidocSignatureSpan">(dueTime, period, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimerObservable(dueTime, period, scheduler) {
    if (dueTime === void 0) { dueTime = 0; }
    _super.call(this);
    this.period = -1;
    this.dueTime = 0;
    if (isNumeric_1.isNumeric(period)) {
        this.period = Number(period) &lt; 1 &amp;&amp; 1 || Number(period);
    }
    else if (isScheduler_1.isScheduler(period)) {
        scheduler = period;
    }
    if (!isScheduler_1.isScheduler(scheduler)) {
        scheduler = async_1.async;
    }
    this.scheduler = scheduler;
    this.dueTime = isDate_1.isDate(dueTime) ?
        (+dueTime - this.scheduler.now()) :
        dueTime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.UnsubscriptionError" id="apidoc.module.rxjs.UnsubscriptionError">module rxjs.UnsubscriptionError</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.UnsubscriptionError.UnsubscriptionError" id="apidoc.element.rxjs.UnsubscriptionError.UnsubscriptionError">
        function <span class="apidocSignatureSpan">rxjs.</span>UnsubscriptionError
        <span class="apidocSignatureSpan">(errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UnsubscriptionError(errors) {
    _super.call(this);
    this.errors = errors;
    var err = Error.call(this, errors ?
        errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " +
err.toString()); }).join('\n  ') : '');
    this.name = err.name = 'UnsubscriptionError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                        errors.push(err);
                    }
                }
            }
        }
    }
    if (hasErrors) {
        throw new UnsubscriptionError_1.<span class="apidocCodeKeywordSpan">UnsubscriptionError</span>(errors);
    }
};
/**
 * Adds a tear down to be called during the unsubscribe() of this
 * Subscription.
 *
 * If the tear down being added is a subscription that is already
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.UnsubscriptionError.captureStackTrace" id="apidoc.element.rxjs.UnsubscriptionError.captureStackTrace">
        function <span class="apidocSignatureSpan">rxjs.UnsubscriptionError.</span>captureStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureStackTrace() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.UnsubscriptionError.prototype" id="apidoc.module.rxjs.UnsubscriptionError.prototype">module rxjs.UnsubscriptionError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.UnsubscriptionError.prototype.constructor" id="apidoc.element.rxjs.UnsubscriptionError.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.UnsubscriptionError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UnsubscriptionError(errors) {
    _super.call(this);
    this.errors = errors;
    var err = Error.call(this, errors ?
        errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " +
err.toString()); }).join('\n  ') : '');
    this.name = err.name = 'UnsubscriptionError';
    this.stack = err.stack;
    this.message = err.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.UsingObservable" id="apidoc.module.rxjs.UsingObservable">module rxjs.UsingObservable</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.UsingObservable.UsingObservable" id="apidoc.element.rxjs.UsingObservable.UsingObservable">
        function <span class="apidocSignatureSpan">rxjs.</span>UsingObservable
        <span class="apidocSignatureSpan">(resourceFactory, observableFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UsingObservable(resourceFactory, observableFactory) {
    _super.call(this);
    this.resourceFactory = resourceFactory;
    this.observableFactory = observableFactory;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.VirtualTimeScheduler" id="apidoc.module.rxjs.VirtualTimeScheduler">module rxjs.VirtualTimeScheduler</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.VirtualTimeScheduler.VirtualTimeScheduler" id="apidoc.element.rxjs.VirtualTimeScheduler.VirtualTimeScheduler">
        function <span class="apidocSignatureSpan">rxjs.</span>VirtualTimeScheduler
        <span class="apidocSignatureSpan">(SchedulerAction, maxFrames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VirtualTimeScheduler(SchedulerAction, maxFrames) {
    var _this = this;
    if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
    if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
    _super.call(this, SchedulerAction, function () { return _this.frame; });
    this.maxFrames = maxFrames;
    this.frame = 0;
    this.index = -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.VirtualTimeScheduler.now" id="apidoc.element.rxjs.VirtualTimeScheduler.now">
        function <span class="apidocSignatureSpan">rxjs.VirtualTimeScheduler.</span>now
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function now() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    else if (this.isStopped) {
        subscriber.complete();
    }
    return subscription;
};
ReplaySubject.prototype._getNow = function () {
    return (this.scheduler || queue_1.queue).<span class="apidocCodeKeywordSpan">now</span>();
};
ReplaySubject.prototype._trimBufferThenGetEvents = function () {
    var now = this._getNow();
    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.VirtualTimeScheduler.prototype" id="apidoc.module.rxjs.VirtualTimeScheduler.prototype">module rxjs.VirtualTimeScheduler.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.VirtualTimeScheduler.prototype.constructor" id="apidoc.element.rxjs.VirtualTimeScheduler.prototype.constructor">
        function <span class="apidocSignatureSpan">rxjs.VirtualTimeScheduler.prototype.</span>constructor
        <span class="apidocSignatureSpan">(SchedulerAction, maxFrames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VirtualTimeScheduler(SchedulerAction, maxFrames) {
    var _this = this;
    if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
    if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
    _super.call(this, SchedulerAction, function () { return _this.frame; });
    this.maxFrames = maxFrames;
    this.frame = 0;
    this.index = -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.VirtualTimeScheduler.prototype.flush" id="apidoc.element.rxjs.VirtualTimeScheduler.prototype.flush">
        function <span class="apidocSignatureSpan">rxjs.VirtualTimeScheduler.prototype.</span>flush
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flush = function () {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error, action;
    while ((action = actions.shift()) &amp;&amp; (this.frame = action.delay) &lt;= maxFrames) {
        if (error = action.execute(action.state, action.delay)) {
            break;
        }
    }
    if (error) {
        while (action = actions.shift()) {
            action.unsubscribe();
        }
        throw error;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
QueueAction.prototype.schedule = function (state, delay) {
    if (delay === void 0) { delay = 0; }
    if (delay &gt; 0) {
        return _super.prototype.schedule.call(this, state, delay);
    }
    this.delay = delay;
    this.state = state;
    this.scheduler.<span class="apidocCodeKeywordSpan">flush</span>(this);
    return this;
};
QueueAction.prototype.execute = function (state, delay) {
    return (delay &gt; 0 || this.closed) ?
        _super.prototype.execute.call(this, state, delay) :
        this._execute(state, delay);
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.applyMixins" id="apidoc.module.rxjs.applyMixins">module rxjs.applyMixins</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.applyMixins.applyMixins" id="apidoc.element.rxjs.applyMixins.applyMixins">
        function <span class="apidocSignatureSpan">rxjs.</span>applyMixins
        <span class="apidocSignatureSpan">(derivedCtor, baseCtors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyMixins(derivedCtor, baseCtors) {
    for (var i = 0, len = baseCtors.length; i &lt; len; i++) {
        var baseCtor = baseCtors[i];
        var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);
        for (var j = 0, len2 = propertyKeys.length; j &lt; len2; j++) {
            var name_1 = propertyKeys[j];
            derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                message.notification.observe(subscriber);
            }, message.frame, { message: message, subscriber: subscriber }));
        }
    };
    return ColdObservable;
}(Observable_1.Observable));
exports.ColdObservable = ColdObservable;
applyMixins_1.<span class="apidocCodeKeywordSpan">applyMixins</span>(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable
]);
//# sourceMappingURL=ColdObservable.js.map
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.assign" id="apidoc.module.rxjs.assign">module rxjs.assign</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.assign.assign" id="apidoc.element.rxjs.assign.assign">
        function <span class="apidocSignatureSpan">rxjs.</span>assign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assign() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.assign.assignImpl" id="apidoc.element.rxjs.assign.assignImpl">
        function <span class="apidocSignatureSpan">rxjs.assign.</span>assignImpl
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function assignImpl(target) {
    var sources = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    var len = sources.length;
    for (var i = 0; i &lt; len; i++) {
        var source = sources[i];
        for (var k in source) {
            if (source.hasOwnProperty(k)) {
                target[k] = source[k];
            }
        }
    }
    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.assign.getAssign" id="apidoc.element.rxjs.assign.getAssign">
        function <span class="apidocSignatureSpan">rxjs.assign.</span>getAssign
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAssign(root) {
    return root.Object.assign || assignImpl;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.audit" id="apidoc.module.rxjs.audit">module rxjs.audit</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.audit.audit" id="apidoc.element.rxjs.audit.audit">
        function <span class="apidocSignatureSpan">rxjs.</span>audit
        <span class="apidocSignatureSpan">(durationSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function audit(durationSelector) {
    return this.lift(new AuditOperator(durationSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* source value, which returns the "duration" Observable. When the duration
* Observable emits a value or completes, the timer is disabled, then the most
* recent source value is emitted on the output Observable, and this process
* repeats for the next source value.
*
* @example &lt;caption&gt;Emit clicks at a rate of at most one click per second&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">audit</span>(ev =&gt; Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link auditTime}
* @see {@link debounce}
* @see {@link delayWhen}
* @see {@link sample}
* @see {@link throttle}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.auditTime" id="apidoc.module.rxjs.auditTime">module rxjs.auditTime</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.auditTime.auditTime" id="apidoc.element.rxjs.auditTime.auditTime">
        function <span class="apidocSignatureSpan">rxjs.</span>auditTime
        <span class="apidocSignatureSpan">(duration, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function auditTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new AuditTimeOperator(duration, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the time unit determined internally by the optional `scheduler`) has passed,
* the timer is disabled, then the most recent source value is emitted on the
* output Observable, and this process repeats for the next source value.
* Optionally takes a {@link IScheduler} for managing timers.
*
* @example &lt;caption&gt;Emit clicks at a rate of at most one click per second&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">auditTime</span>(1000);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link audit}
* @see {@link debounceTime}
* @see {@link delay}
* @see {@link sampleTime}
* @see {@link throttleTime}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.bindCallback" id="apidoc.module.rxjs.bindCallback">module rxjs.bindCallback</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.bindCallback.bindCallback" id="apidoc.element.rxjs.bindCallback.bindCallback">
        function <span class="apidocSignatureSpan">rxjs.</span>bindCallback
        <span class="apidocSignatureSpan">(func, selector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindCallback = function (func, selector, scheduler) {
    if (selector === void 0) { selector = undefined; }
    return function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        return new BoundCallbackObservable(func, selector, args, this, scheduler);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* provides convenient error handling and probably is a better choice.
* `bindCallback` will treat such functions without any difference and error parameter
* (whether passed or not) will always be interpreted as regular callback argument.
*
*
* @example &lt;caption&gt;Convert jQuery's getJSON to an Observable API&lt;/caption&gt;
* // Suppose we have jQuery.getJSON('/my/url', callback)
* var getJSONAsObservable = Rx.Observable.<span class="apidocCodeKeywordSpan">bindCallback</span>(jQuery.getJSON);
* var result = getJSONAsObservable('/my/url');
* result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
*
*
* @example &lt;caption&gt;Receive array of arguments passed to callback&lt;/caption&gt;
* someFunction((a, b, c) =&gt; {
*   console.log(a); // 5
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.bindNodeCallback" id="apidoc.module.rxjs.bindNodeCallback">module rxjs.bindNodeCallback</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.bindNodeCallback.bindNodeCallback" id="apidoc.element.rxjs.bindNodeCallback.bindNodeCallback">
        function <span class="apidocSignatureSpan">rxjs.</span>bindNodeCallback
        <span class="apidocSignatureSpan">(func, selector, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindNodeCallback = function (func, selector, scheduler) {
    if (selector === void 0) { selector = undefined; }
    return function () {
        var args = [];
        for (var _i = 0; _i &lt; arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Note that even if error parameter is technically present in callback, but its value
* is falsy, it still won't appear in array emitted by Observable or in selector function.
*
*
* @example &lt;caption&gt;Read a file from the filesystem and get the data as an Observable&lt;/caption&gt;
* import * as fs from 'fs';
* var readFileAsObservable = Rx.Observable.<span class="apidocCodeKeywordSpan">bindNodeCallback</span>(fs.readFile);
* var result = readFileAsObservable('./roadNames.txt', 'utf8');
* result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
*
*
* @example &lt;caption&gt;Use on function calling callback with multiple arguments&lt;/caption&gt;
* someFunction((err, a, b) =&gt; {
*   console.log(err); // null
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.buffer" id="apidoc.module.rxjs.buffer">module rxjs.buffer</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.buffer.buffer" id="apidoc.element.rxjs.buffer.buffer">
        function <span class="apidocSignatureSpan">rxjs.</span>buffer
        <span class="apidocSignatureSpan">(closingNotifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function buffer(closingNotifier) {
    return this.lift(new BufferOperator(closingNotifier));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Observable emits a value, at which point it emits the buffer on the output
* Observable and starts a new buffer internally, awaiting the next time
* `closingNotifier` emits.
*
* @example &lt;caption&gt;On every click, emit array of most recent interval events&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var interval = Rx.Observable.interval(1000);
* var buffered = interval.<span class="apidocCodeKeywordSpan">buffer</span>(clicks);
* buffered.subscribe(x =&gt; console.log(x));
*
* @see {@link bufferCount}
* @see {@link bufferTime}
* @see {@link bufferToggle}
* @see {@link bufferWhen}
* @see {@link window}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.bufferCount" id="apidoc.module.rxjs.bufferCount">module rxjs.bufferCount</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.bufferCount.bufferCount" id="apidoc.element.rxjs.bufferCount.bufferCount">
        function <span class="apidocSignatureSpan">rxjs.</span>bufferCount
        <span class="apidocSignatureSpan">(bufferSize, startBufferEvery)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) { startBufferEvery = null; }
    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* emits the buffer and clears it, and starts a new buffer each
* `startBufferEvery` values. If `startBufferEvery` is not provided or is
* `null`, then new buffers are started immediately at the start of the source
* and when each buffer closes and is emitted.
*
* @example &lt;caption&gt;Emit the last two click events as an array&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var buffered = clicks.<span class="apidocCodeKeywordSpan">bufferCount</span>(2);
* buffered.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;On every click, emit the last two click events as an array&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var buffered = clicks.bufferCount(2, 1);
* buffered.subscribe(x =&gt; console.log(x));
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.bufferTime" id="apidoc.module.rxjs.bufferTime">module rxjs.bufferTime</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.bufferTime.bufferTime" id="apidoc.element.rxjs.bufferTime.bufferTime">
        function <span class="apidocSignatureSpan">rxjs.</span>bufferTime
        <span class="apidocSignatureSpan">(bufferTimeSpan)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = async_1.async;
    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length &gt;= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length &gt;= 3) {
        maxBufferSize = arguments[2];
    }
    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `bufferCreationInterval` milliseconds and closes (emits and resets) the
* buffer every `bufferTimeSpan` milliseconds. When the optional argument
* `maxBufferSize` is specified, the buffer will be closed either after
* `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
*
* @example &lt;caption&gt;Every second, emit an array of the recent click events&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var buffered = clicks.<span class="apidocCodeKeywordSpan">bufferTime</span>(1000);
* buffered.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Every 5 seconds, emit the click events from the next 2 seconds&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var buffered = clicks.bufferTime(2000, 5000);
* buffered.subscribe(x =&gt; console.log(x));
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.bufferToggle" id="apidoc.module.rxjs.bufferToggle">module rxjs.bufferToggle</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.bufferToggle.bufferToggle" id="apidoc.element.rxjs.bufferToggle.bufferToggle">
        function <span class="apidocSignatureSpan">rxjs.</span>bufferToggle
        <span class="apidocSignatureSpan">(openings, closingSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bufferToggle(openings, closingSelector) {
    return this.lift(new BufferToggleOperator(openings, closingSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Buffers values from the source by opening the buffer via signals from an
* Observable provided to `openings`, and closing and sending the buffers when
* a Subscribable or Promise returned by the `closingSelector` function emits.
*
* @example &lt;caption&gt;Every other second, emit the click events from the next 500ms&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var openings = Rx.Observable.interval(1000);
* var buffered = clicks.<span class="apidocCodeKeywordSpan">bufferToggle</span>(openings, i =&gt;
*   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
* );
* buffered.subscribe(x =&gt; console.log(x));
*
* @see {@link buffer}
* @see {@link bufferCount}
* @see {@link bufferTime}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.bufferWhen" id="apidoc.module.rxjs.bufferWhen">module rxjs.bufferWhen</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.bufferWhen.bufferWhen" id="apidoc.element.rxjs.bufferWhen.bufferWhen">
        function <span class="apidocSignatureSpan">rxjs.</span>bufferWhen
        <span class="apidocSignatureSpan">(closingSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bufferWhen(closingSelector) {
    return this.lift(new BufferWhenOperator(closingSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Opens a buffer immediately, then closes the buffer when the observable
* returned by calling `closingSelector` function emits a value. When it closes
* the buffer, it immediately opens a new buffer and repeats the process.
*
* @example &lt;caption&gt;Emit an array of the last clicks every [1-5] random seconds&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var buffered = clicks.<span class="apidocCodeKeywordSpan">bufferWhen</span>(() =&gt;
*   Rx.Observable.interval(1000 + Math.random() * 4000)
* );
* buffered.subscribe(x =&gt; console.log(x));
*
* @see {@link buffer}
* @see {@link bufferCount}
* @see {@link bufferTime}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.catch" id="apidoc.module.rxjs.catch">module rxjs.catch</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.catch._catch" id="apidoc.element.rxjs.catch._catch">
        function <span class="apidocSignatureSpan">rxjs.catch.</span>_catch
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _catch(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return (operator.caught = caught);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.combineAll" id="apidoc.module.rxjs.combineAll">module rxjs.combineAll</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.combineAll.combineAll" id="apidoc.element.rxjs.combineAll.combineAll">
        function <span class="apidocSignatureSpan">rxjs.</span>combineAll
        <span class="apidocSignatureSpan">(project)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function combineAll(project) {
    return this.lift(new combineLatest_1.CombineLatestOperator(project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     values is emitted by the output Observable.
*
* @example &lt;caption&gt;Map two click events to a finite interval Observable, then apply combineAll&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var higherOrder = clicks.map(ev =&gt;
*   Rx.Observable.interval(Math.random()*2000).take(3)
* ).take(2);
* var result = higherOrder.<span class="apidocCodeKeywordSpan">combineAll</span>();
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link combineLatest}
* @see {@link mergeAll}
*
* @param {function} [project] An optional function to map the most recent
* values from each inner Observable into a new result. Takes each of the most
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.combineLatest" id="apidoc.module.rxjs.combineLatest">module rxjs.combineLatest</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.combineLatest.combineLatest" id="apidoc.element.rxjs.combineLatest.combineLatest">
        function <span class="apidocSignatureSpan">rxjs.</span>combineLatest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function combineLatest() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
    if (observables.length === 1 &amp;&amp; isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* of values, but values themselves. That means default `project` can be imagined
* as function that takes all its arguments and puts them into an array.
*
*
* @example &lt;caption&gt;Combine two timer Observables&lt;/caption&gt;
* const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
* const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
* const combinedTimers = Rx.Observable.<span class="apidocCodeKeywordSpan">combineLatest</span>(firstTimer, secondTimer);
* combinedTimers.subscribe(value =&gt; console.log(value));
* // Logs
* // [0, 0] after 0.5s
* // [1, 0] after 1s
* // [1, 1] after 1.5s
* // [2, 1] after 2s
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.concat" id="apidoc.module.rxjs.concat">module rxjs.concat</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.concat.concat" id="apidoc.element.rxjs.concat.concat">
        function <span class="apidocSignatureSpan">rxjs.</span>concat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatStatic() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var scheduler = null;
    var args = observables;
    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
        scheduler = args.pop();
    }
    if (scheduler === null &amp;&amp; observables.length === 1 &amp;&amp; observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (isObject_1.isObject(sub)) {
        var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
        if (trial === errorObject_1.errorObject) {
            hasErrors = true;
            errors = errors || [];
            var err = errorObject_1.errorObject.e;
            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                errors = errors.<span class="apidocCodeKeywordSpan">concat</span>(flattenUnsubscriptionErrors(err.errors));
            }
            else {
                errors.push(err);
            }
        }
    }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.concatAll" id="apidoc.module.rxjs.concatAll">module rxjs.concatAll</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.concatAll.concatAll" id="apidoc.element.rxjs.concatAll.concatAll">
        function <span class="apidocSignatureSpan">rxjs.</span>concatAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatAll() {
    return this.lift(new mergeAll_1.MergeAllOperator(1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
* to `1`.
*
* @example &lt;caption&gt;For each click event, tick every second from 0 to 3, with no concurrency&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var higherOrder = clicks.map(ev =&gt; Rx.Observable.interval(1000).take(4));
* var firstOrder = higherOrder.<span class="apidocCodeKeywordSpan">concatAll</span>();
* firstOrder.subscribe(x =&gt; console.log(x));
*
* // Results in the following:
* // (results are not concurrent)
* // For every click on the "document" it will emit values 0 to 3 spaced
* // on a 1000ms interval
* // one click = 1000ms-&gt; 0 -1000ms-&gt; 1 -1000ms-&gt; 2 -1000ms-&gt; 3
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.concatMap" id="apidoc.module.rxjs.concatMap">module rxjs.concatMap</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.concatMap.concatMap" id="apidoc.element.rxjs.concatMap.concatMap">
        function <span class="apidocSignatureSpan">rxjs.</span>concatMap
        <span class="apidocSignatureSpan">(project, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatMap(project, resultSelector) {
    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* be subscribed to.
*
* Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
* to `1`.
*
* @example &lt;caption&gt;For each click event, tick every second from 0 to 3, with no concurrency&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">concatMap</span>(ev =&gt; Rx.Observable.interval(1000).take(4));
* result.subscribe(x =&gt; console.log(x));
*
* // Results in the following:
* // (results are not concurrent)
* // For every click on the "document" it will emit values 0 to 3 spaced
* // on a 1000ms interval
* // one click = 1000ms-&gt; 0 -1000ms-&gt; 1 -1000ms-&gt; 2 -1000ms-&gt; 3
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.concatMapTo" id="apidoc.module.rxjs.concatMapTo">module rxjs.concatMapTo</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.concatMapTo.concatMapTo" id="apidoc.element.rxjs.concatMapTo.concatMapTo">
        function <span class="apidocSignatureSpan">rxjs.</span>concatMapTo
        <span class="apidocSignatureSpan">(innerObservable, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatMapTo(innerObservable, resultSelector) {
    return this.lift(new mergeMapTo_1.MergeMapToOperator(innerObservable, resultSelector, 1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* be subscribed to.
*
* Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
* set to `1`.
*
* @example &lt;caption&gt;For each click event, tick every second from 0 to 3, with no concurrency&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">concatMapTo</span>(Rx.Observable.interval(1000).take(4));
* result.subscribe(x =&gt; console.log(x));
*
* // Results in the following:
* // (results are not concurrent)
* // For every click on the "document" it will emit values 0 to 3 spaced
* // on a 1000ms interval
* // one click = 1000ms-&gt; 0 -1000ms-&gt; 1 -1000ms-&gt; 2 -1000ms-&gt; 3
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.count" id="apidoc.module.rxjs.count">module rxjs.count</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.count.count" id="apidoc.element.rxjs.count.count">
        function <span class="apidocSignatureSpan">rxjs.</span>count
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function count(predicate) {
    return this.lift(new CountOperator(predicate, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* as argument, in which case the output emission will represent the number of
* source values that matched `true` with the `predicate`.
*
* @example &lt;caption&gt;Counts how many seconds have passed before the first click happened&lt;/caption&gt;
* var seconds = Rx.Observable.interval(1000);
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var secondsBeforeClick = seconds.takeUntil(clicks);
* var result = secondsBeforeClick.<span class="apidocCodeKeywordSpan">count</span>();
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Counts how many odd numbers are there between 1 and 7&lt;/caption&gt;
* var numbers = Rx.Observable.range(1, 7);
* var result = numbers.count(i =&gt; i % 2 === 1);
* result.subscribe(x =&gt; console.log(x));
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.debounce" id="apidoc.module.rxjs.debounce">module rxjs.debounce</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.debounce.debounce" id="apidoc.element.rxjs.debounce.debounce">
        function <span class="apidocSignatureSpan">rxjs.</span>debounce
        <span class="apidocSignatureSpan">(durationSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function debounce(durationSelector) {
    return this.lift(new DebounceOperator(durationSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Like {@link debounceTime}, this is a rate-limiting operator, and also a
* delay-like operator since output emissions do not necessarily occur at the
* same time as they did on the source Observable.
*
* @example &lt;caption&gt;Emit the most recent click after a burst of clicks&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">debounce</span>(() =&gt; Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link audit}
* @see {@link debounceTime}
* @see {@link delayWhen}
* @see {@link throttle}
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.debounceTime" id="apidoc.module.rxjs.debounceTime">module rxjs.debounceTime</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.debounceTime.debounceTime" id="apidoc.element.rxjs.debounceTime.debounceTime">
        function <span class="apidocSignatureSpan">rxjs.</span>debounceTime
        <span class="apidocSignatureSpan">(dueTime, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* value to be emitted in any time window of duration `dueTime`, but it is also
* a delay-like operator since output emissions do not occur at the same time as
* they did on the source Observable. Optionally takes a {@link IScheduler} for
* managing timers.
*
* @example &lt;caption&gt;Emit the most recent click after a burst of clicks&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">debounceTime</span>(1000);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link auditTime}
* @see {@link debounce}
* @see {@link delay}
* @see {@link sampleTime}
* @see {@link throttleTime}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.defaultIfEmpty" id="apidoc.module.rxjs.defaultIfEmpty">module rxjs.defaultIfEmpty</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.defaultIfEmpty.defaultIfEmpty" id="apidoc.element.rxjs.defaultIfEmpty.defaultIfEmpty">
        function <span class="apidocSignatureSpan">rxjs.</span>defaultIfEmpty
        <span class="apidocSignatureSpan">(defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) { defaultValue = null; }
    return this.lift(new DefaultIfEmptyOperator(defaultValue));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `defaultIfEmpty` emits the values emitted by the source Observable or a
* specified default value if the source Observable is empty (completes without
* having emitted any `next` value).
*
* @example &lt;caption&gt;If no clicks happen in 5 seconds, then emit "no clicks"&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
* var result = clicksBeforeFive.<span class="apidocCodeKeywordSpan">defaultIfEmpty</span>('no clicks');
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link empty}
* @see {@link last}
*
* @param {any} [defaultValue=null] The default value used if the source
* Observable is empty.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.defer" id="apidoc.module.rxjs.defer">module rxjs.defer</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.defer.defer" id="apidoc.element.rxjs.defer.defer">
        function <span class="apidocSignatureSpan">rxjs.</span>defer
        <span class="apidocSignatureSpan">(observableFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defer = function (observableFactory) {
    return new DeferObservable(observableFactory);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* an Observer subscribes to it, and then it generates an Observable,
* typically with an Observable factory function. It does this afresh for each
* subscriber, so although each subscriber may think it is subscribing to the
* same Observable, in fact each subscriber gets its own individual
* Observable.
*
* @example &lt;caption&gt;Subscribe to either an Observable of clicks or an Observable of interval, at random&lt;/caption&amp;#
x3e;
* var clicksOrInterval = Rx.Observable.<span class="apidocCodeKeywordSpan">defer</span>(function () {
*   if (Math.random() &gt; 0.5) {
*     return Rx.Observable.fromEvent(document, 'click');
*   } else {
*     return Rx.Observable.interval(1000);
*   }
* });
* clicksOrInterval.subscribe(x =&gt; console.log(x));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.delay" id="apidoc.module.rxjs.delay">module rxjs.delay</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.delay.delay" id="apidoc.element.rxjs.delay.delay">
        function <span class="apidocSignatureSpan">rxjs.</span>delay
        <span class="apidocSignatureSpan">(delay, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function delay(delay, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return this.lift(new DelayOperator(delayFor, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* // [1, 0] after 1s
* // [1, 1] after 1.5s
* // [2, 1] after 2s
*
*
* @example &lt;caption&gt;Combine an array of Observables&lt;/caption&gt;
* const observables = [1, 5, 10].map(
*   n =&gt; Rx.Observable.of(n).<span class="apidocCodeKeywordSpan">delay</span>(n * 1000).startWith(0) // emit 0 and then emit
 n after n seconds
* );
* const combined = Rx.Observable.combineLatest(observables);
* combined.subscribe(value =&gt; console.log(value));
* // Logs
* // [0, 0, 0] immediately
* // [1, 0, 0] after 1s
* // [1, 5, 0] after 5s
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.delayWhen" id="apidoc.module.rxjs.delayWhen">module rxjs.delayWhen</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.delayWhen.delayWhen" id="apidoc.element.rxjs.delayWhen.delayWhen">
        function <span class="apidocSignatureSpan">rxjs.</span>delayWhen
        <span class="apidocSignatureSpan">(delayDurationSelector, subscriptionDelay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return new SubscriptionDelayObservable(this, subscriptionDelay)
            .lift(new DelayWhenOperator(delayDurationSelector));
    }
    return this.lift(new DelayWhenOperator(delayDurationSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* completes, the source Observable is subscribed to and starts behaving like
* described in the previous paragraph. If `subscriptionDelay` is not provided,
* `delayWhen` will subscribe to the source Observable as soon as the output
* Observable is subscribed.
*
* @example &lt;caption&gt;Delay each click by a random amount of time, between 0 and 5 seconds&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var delayedClicks = clicks.<span class="apidocCodeKeywordSpan">delayWhen</span>(event =&gt;
*   Rx.Observable.interval(Math.random() * 5000)
* );
* delayedClicks.subscribe(x =&gt; console.log(x));
*
* @see {@link debounce}
* @see {@link delay}
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.dematerialize" id="apidoc.module.rxjs.dematerialize">module rxjs.dematerialize</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.dematerialize.dematerialize" id="apidoc.element.rxjs.dematerialize.dematerialize">
        function <span class="apidocSignatureSpan">rxjs.</span>dematerialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dematerialize() {
    return this.lift(new DeMaterializeOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @example &lt;caption&gt;Convert an Observable of Notifications to an actual Observable&lt;/caption&gt;
* var notifA = new Rx.Notification('N', 'A');
* var notifB = new Rx.Notification('N', 'B');
* var notifE = new Rx.Notification('E', void 0,
*   new TypeError('x.toUpperCase is not a function')
* );
* var materialized = Rx.Observable.of(notifA, notifB, notifE);
* var upperCase = materialized.<span class="apidocCodeKeywordSpan">dematerialize</span>();
* upperCase.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
*
* // Results in:
* // A
* // B
* // TypeError: x.toUpperCase is not a function
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.distinct" id="apidoc.module.rxjs.distinct">module rxjs.distinct</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.distinct.distinct" id="apidoc.element.rxjs.distinct.distinct">
        function <span class="apidocSignatureSpan">rxjs.</span>distinct
        <span class="apidocSignatureSpan">(keySelector, flushes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function distinct(keySelector, flushes) {
    return this.lift(new DistinctOperator(keySelector, flushes));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
* hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct
`
* use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
* that the internal `Set` can be "flushed", basically clearing it of values.
*
* @example &lt;caption&gt;A simple example with numbers&lt;/caption&gt;
* Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
*   .<span class="apidocCodeKeywordSpan">distinct</span>()
*   .subscribe(x =&gt; console.log(x)); // 1, 2, 3, 4
*
* @example &lt;caption&gt;An example using a keySelector function&lt;/caption&gt;
* interface Person {
*    age: number,
*    name: string
* }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.distinct.DistinctSubscriber" id="apidoc.element.rxjs.distinct.DistinctSubscriber">
        function <span class="apidocSignatureSpan">rxjs.distinct.</span>DistinctSubscriber
        <span class="apidocSignatureSpan">(destination, keySelector, flushes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DistinctSubscriber(destination, keySelector, flushes) {
    _super.call(this, destination);
    this.keySelector = keySelector;
    this.values = new Set_1.Set();
    if (flushes) {
        this.add(subscribeToResult_1.subscribeToResult(this, flushes));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.distinctUntilChanged" id="apidoc.module.rxjs.distinctUntilChanged">module rxjs.distinctUntilChanged</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.distinctUntilChanged.distinctUntilChanged" id="apidoc.element.rxjs.distinctUntilChanged.distinctUntilChanged">
        function <span class="apidocSignatureSpan">rxjs.</span>distinctUntilChanged
        <span class="apidocSignatureSpan">(compare, keySelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function distinctUntilChanged(compare, keySelector) {
    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted
.
*
* If a comparator function is not provided, an equality check is used by default.
*
* @example &lt;caption&gt;A simple example with numbers&lt;/caption&gt;
* Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
*   .<span class="apidocCodeKeywordSpan">distinctUntilChanged</span>()
*   .subscribe(x =&gt; console.log(x)); // 1, 2, 1, 2, 3, 4
*
* @example &lt;caption&gt;An example using a compare function&lt;/caption&gt;
* interface Person {
*    age: number,
*    name: string
* }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.distinctUntilKeyChanged" id="apidoc.module.rxjs.distinctUntilKeyChanged">module rxjs.distinctUntilKeyChanged</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.distinctUntilKeyChanged.distinctUntilKeyChanged" id="apidoc.element.rxjs.distinctUntilKeyChanged.distinctUntilKeyChanged">
        function <span class="apidocSignatureSpan">rxjs.</span>distinctUntilKeyChanged
        <span class="apidocSignatureSpan">(key, compare)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged.call(this, function (x, y) {
        if (compare) {
            return compare(x[key], y[key]);
        }
        return x[key] === y[key];
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*  }
*
* Observable.of&lt;Person&gt;(
*     { age: 4, name: 'Foo'},
*     { age: 7, name: 'Bar'},
*     { age: 5, name: 'Foo'},
*     { age: 6, name: 'Foo'})
*     .<span class="apidocCodeKeywordSpan">distinctUntilKeyChanged</span>('name')
*     .subscribe(x =&gt; console.log(x));
*
* // displays:
* // { age: 4, name: 'Foo' }
* // { age: 7, name: 'Bar' }
* // { age: 5, name: 'Foo' }
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.do" id="apidoc.module.rxjs.do">module rxjs.do</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.do._do" id="apidoc.element.rxjs.do._do">
        function <span class="apidocSignatureSpan">rxjs.do.</span>_do
        <span class="apidocSignatureSpan">(nextOrObserver, error, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _do(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.elementAt" id="apidoc.module.rxjs.elementAt">module rxjs.elementAt</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.elementAt.elementAt" id="apidoc.element.rxjs.elementAt.elementAt">
        function <span class="apidocSignatureSpan">rxjs.</span>elementAt
        <span class="apidocSignatureSpan">(index, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function elementAt(index, defaultValue) {
    return this.lift(new ElementAtOperator(index, defaultValue));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `index` in the source Observable, or a default value if that `index` is out
* of range and the `default` argument is provided. If the `default` argument is
* not given and the `index` is out of range, the output Observable will emit an
* `ArgumentOutOfRangeError` error.
*
* @example &lt;caption&gt;Emit only the third click event&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">elementAt</span>(2);
* result.subscribe(x =&gt; console.log(x));
*
* // Results in:
* // click 1 = nothing
* // click 2 = nothing
* // click 3 = MouseEvent object logged to console
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.empty" id="apidoc.module.rxjs.empty">module rxjs.empty</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.empty.empty" id="apidoc.element.rxjs.empty.empty">
        function <span class="apidocSignatureSpan">rxjs.</span>empty
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function (scheduler) {
    return new EmptyObservable(scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var kind = this.kind;
    switch (kind) {
        case 'N':
            return Observable_1.Observable.of(this.value);
        case 'E':
            return Observable_1.Observable.throw(this.error);
        case 'C':
            return Observable_1.Observable.<span class="apidocCodeKeywordSpan">empty</span>();
    }
    throw new Error('unexpected notification kind value');
};
/**
 * A shortcut to create a Notification instance of the type `next` from a
 * given value.
 * @param {T} value The `next` value.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.every" id="apidoc.module.rxjs.every">module rxjs.every</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.every.every" id="apidoc.element.rxjs.every.every">
        function <span class="apidocSignatureSpan">rxjs.</span>every
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function every(predicate, thisArg) {
    return this.lift(new EveryOperator(predicate, thisArg, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
var Subscriber_1 = require('../Subscriber');
/**
* Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
*
* @example &lt;caption&gt;A simple example emitting true if all elements are less than 5, false otherwise&lt;/caption&gt;
;
*  Observable.of(1, 2, 3, 4, 5, 6)
*     .<span class="apidocCodeKeywordSpan">every</span>(x =&gt; x &lt; 5)
*     .subscribe(x =&gt; console.log(x)); // -&gt; false
*
* @param {function} predicate A function for determining if an item meets a specified condition.
* @param {any} [thisArg] Optional object to use for `this` in the callback.
* @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified
.
* @method every
* @owner Observable
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.exhaust" id="apidoc.module.rxjs.exhaust">module rxjs.exhaust</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.exhaust.exhaust" id="apidoc.element.rxjs.exhaust.exhaust">
        function <span class="apidocSignatureSpan">rxjs.</span>exhaust
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exhaust() {
    return this.lift(new SwitchFirstOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `exhaust` ignores every new inner Observable if the previous Observable has
* not yet completed. Once that one completes, it will accept and flatten the
* next inner Observable and repeat this process.
*
* @example &lt;caption&gt;Run a finite timer for each click, only if there is no currently active timer&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var higherOrder = clicks.map((ev) =&gt; Rx.Observable.interval(1000));
* var result = higherOrder.<span class="apidocCodeKeywordSpan">exhaust</span>();
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link combineAll}
* @see {@link concatAll}
* @see {@link switch}
* @see {@link mergeAll}
* @see {@link exhaustMap}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.exhaustMap" id="apidoc.module.rxjs.exhaustMap">module rxjs.exhaustMap</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.exhaustMap.exhaustMap" id="apidoc.element.rxjs.exhaustMap.exhaustMap">
        function <span class="apidocSignatureSpan">rxjs.</span>exhaustMap
        <span class="apidocSignatureSpan">(project, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exhaustMap(project, resultSelector) {
    return this.lift(new SwitchFirstMapOperator(project, resultSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* that projected Observable. However, `exhaustMap` ignores every new projected
* Observable if the previous projected Observable has not yet completed. Once
* that one completes, it will accept and flatten the next projected Observable
* and repeat this process.
*
* @example &lt;caption&gt;Run a finite timer for each click, only if there is no currently active timer&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">exhaustMap</span>((ev) =&gt; Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link concatMap}
* @see {@link exhaust}
* @see {@link mergeMap}
* @see {@link switchMap}
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.expand" id="apidoc.module.rxjs.expand">module rxjs.expand</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.expand.expand" id="apidoc.element.rxjs.expand.expand">
        function <span class="apidocSignatureSpan">rxjs.</span>expand
        <span class="apidocSignatureSpan">(project, concurrent, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (scheduler === void 0) { scheduler = undefined; }
    concurrent = (concurrent || 0) &lt; 1 ? Number.POSITIVE_INFINITY : concurrent;
    return this.lift(new ExpandOperator(project, concurrent, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* given to the `project` function to produce new output values. This is how
* *expand* behaves recursively.
*
* @example &lt;caption&gt;Start emitting the powers of two on every click, at most 10 of them&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var powersOfTwo = clicks
*   .mapTo(1)
*   .<span class="apidocCodeKeywordSpan">expand</span>(x =&gt; Rx.Observable.of(2 * x).delay(1000))
*   .take(10);
* powersOfTwo.subscribe(x =&gt; console.log(x));
*
* @see {@link mergeMap}
* @see {@link mergeScan}
*
* @param {function(value: T, index: number) =&gt; Observable} project A function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.expand.ExpandOperator" id="apidoc.element.rxjs.expand.ExpandOperator">
        function <span class="apidocSignatureSpan">rxjs.expand.</span>ExpandOperator
        <span class="apidocSignatureSpan">(project, concurrent, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ExpandOperator(project, concurrent, scheduler) {
    this.project = project;
    this.concurrent = concurrent;
    this.scheduler = scheduler;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.expand.ExpandSubscriber" id="apidoc.element.rxjs.expand.ExpandSubscriber">
        function <span class="apidocSignatureSpan">rxjs.expand.</span>ExpandSubscriber
        <span class="apidocSignatureSpan">(destination, project, concurrent, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ExpandSubscriber(destination, project, concurrent, scheduler) {
    _super.call(this, destination);
    this.project = project;
    this.concurrent = concurrent;
    this.scheduler = scheduler;
    this.index = 0;
    this.active = 0;
    this.hasCompleted = false;
    if (concurrent &lt; Number.POSITIVE_INFINITY) {
        this.buffer = [];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.filter" id="apidoc.module.rxjs.filter">module rxjs.filter</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.filter.filter" id="apidoc.element.rxjs.filter.filter">
        function <span class="apidocSignatureSpan">rxjs.</span>filter
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(predicate, thisArg) {
    return this.lift(new FilterOperator(predicate, thisArg));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
* Filter items emitted by the source Observable by only emitting those that
* satisfy a specified predicate.
*
* &lt;span class="informal"&gt;Like
* [Array.prototype.<span class="apidocCodeKeywordSpan">filter</span>()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/
Reference/Global_Objects/Array/filter),
* it only emits a value from the source if it passes a criterion function.&lt;/span&gt;
*
* &lt;img src="./img/filter.png" width="100%"&gt;
*
* Similar to the well-known `Array.prototype.filter` method, this operator
* takes values from the source Observable, passes them through a `predicate`
* function and only emits those values that yielded `true`.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.finally" id="apidoc.module.rxjs.finally">module rxjs.finally</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.finally._finally" id="apidoc.element.rxjs.finally._finally">
        function <span class="apidocSignatureSpan">rxjs.finally.</span>_finally
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _finally(callback) {
    return this.lift(new FinallyOperator(callback));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.find" id="apidoc.module.rxjs.find">module rxjs.find</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.find.find" id="apidoc.element.rxjs.find.find">
        function <span class="apidocSignatureSpan">rxjs.</span>find
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return this.lift(new FindValueOperator(predicate, this, false, thisArg));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `find` searches for the first item in the source Observable that matches the
* specified condition embodied by the `predicate`, and returns the first
* occurrence in the source. Unlike {@link first}, the `predicate` is required
* in `find`, and does not emit an error if a valid value is not found.
*
* @example &lt;caption&gt;Find and emit the first click that happens on a DIV element&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">find</span>(ev =&gt; ev.target.tagName === 'DIV');
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link filter}
* @see {@link first}
* @see {@link findIndex}
* @see {@link take}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.find.FindValueOperator" id="apidoc.element.rxjs.find.FindValueOperator">
        function <span class="apidocSignatureSpan">rxjs.find.</span>FindValueOperator
        <span class="apidocSignatureSpan">(predicate, source, yieldIndex, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FindValueOperator(predicate, source, yieldIndex, thisArg) {
    this.predicate = predicate;
    this.source = source;
    this.yieldIndex = yieldIndex;
    this.thisArg = thisArg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * in the `predicate` function.
 * @return {Observable} An Observable of the index of the first item that
 * matches the condition.
 * @method find
 * @owner Observable
 */
function findIndex(predicate, thisArg) {
    return this.lift(new find_1.<span class="apidocCodeKeywordSpan">FindValueOperator</span>(predicate, this, true, thisArg));
}
exports.findIndex = findIndex;
//# sourceMappingURL=findIndex.js.map
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.find.FindValueSubscriber" id="apidoc.element.rxjs.find.FindValueSubscriber">
        function <span class="apidocSignatureSpan">rxjs.find.</span>FindValueSubscriber
        <span class="apidocSignatureSpan">(destination, predicate, source, yieldIndex, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
    _super.call(this, destination);
    this.predicate = predicate;
    this.source = source;
    this.yieldIndex = yieldIndex;
    this.thisArg = thisArg;
    this.index = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.findIndex" id="apidoc.module.rxjs.findIndex">module rxjs.findIndex</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.findIndex.findIndex" id="apidoc.element.rxjs.findIndex.findIndex">
        function <span class="apidocSignatureSpan">rxjs.</span>findIndex
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findIndex(predicate, thisArg) {
    return this.lift(new find_1.FindValueOperator(predicate, this, true, thisArg));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the specified condition embodied by the `predicate`, and returns the
* (zero-based) index of the first occurrence in the source. Unlike
* {@link first}, the `predicate` is required in `findIndex`, and does not emit
* an error if a valid value is not found.
*
* @example &lt;caption&gt;Emit the index of first click that happens on a DIV element&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">findIndex</span>(ev =&gt; ev.target.tagName === 'DIV');
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link filter}
* @see {@link find}
* @see {@link first}
* @see {@link take}
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.first" id="apidoc.module.rxjs.first">module rxjs.first</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.first.first" id="apidoc.element.rxjs.first.first">
        function <span class="apidocSignatureSpan">rxjs.</span>first
        <span class="apidocSignatureSpan">(predicate, resultSelector, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function first(predicate, resultSelector, defaultValue) {
    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* may also take a `resultSelector` function to produce the output value from
* the input value, and a `defaultValue` to emit in case the source completes
* before it is able to emit a valid value. Throws an error if `defaultValue`
* was not provided and a matching element is not found.
*
* @example &lt;caption&gt;Emit only the first click that happens on the DOM&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">first</span>();
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Emits the first click that happens on a DIV&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.first(ev =&gt; ev.target.tagName === 'DIV');
* result.subscribe(x =&gt; console.log(x));
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.forkJoin" id="apidoc.module.rxjs.forkJoin">module rxjs.forkJoin</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.forkJoin.forkJoin" id="apidoc.element.rxjs.forkJoin.forkJoin">
        function <span class="apidocSignatureSpan">rxjs.</span>forkJoin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forkJoin = function () {
    var sources = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        sources[_i - 0] = arguments[_i];
    }
    if (sources === null || arguments.length === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    var resultSelector = null;
    if (typeof sources[sources.length - 1] === 'function') {
        resultSelector = sources.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`
    if (sources.length === 1 &amp;&amp; isArray_1.isArray(sources[0])) {
        sources = sources[0];
    }
    if (sources.length === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    return new ForkJoinObservable(sources, resultSelector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.from" id="apidoc.module.rxjs.from">module rxjs.from</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.from.from" id="apidoc.element.rxjs.from.from">
        function <span class="apidocSignatureSpan">rxjs.</span>from
        <span class="apidocSignatureSpan">(ish, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (ish, scheduler) {
    if (ish != null) {
        if (typeof ish[observable_1.$$observable] === 'function') {
            if (ish instanceof Observable_1.Observable &amp;&amp; !scheduler) {
                return ish;
            }
            return new FromObservable(ish, scheduler);
        }
        else if (isArray_1.isArray(ish)) {
            return new ArrayObservable_1.ArrayObservable(ish, scheduler);
        }
        else if (isPromise_1.isPromise(ish)) {
            return new PromiseObservable_1.PromiseObservable(ish, scheduler);
        }
        else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
            return new IteratorObservable_1.IteratorObservable(ish, scheduler);
        }
        else if (isArrayLike_1.isArrayLike(ish)) {
            return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
        }
    }
    throw new TypeError((ish !== null &amp;&amp; typeof ish || ish) + ' is not observable');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* object into an Observable that emits the items in that promise or array or
* iterable. A String, in this context, is treated as an array of characters.
* Observable-like objects (contains a function named with the ES2015 Symbol
* for Observable) can also be converted through this operator.
*
* @example &lt;caption&gt;Converts an array to an Observable&lt;/caption&gt;
* var array = [10, 20, 30];
* var result = Rx.Observable.<span class="apidocCodeKeywordSpan">from</span>(array);
* result.subscribe(x =&gt; console.log(x));
*
* // Results in the following:
* // 10 20 30
*
* @example &lt;caption&gt;Convert an infinite iterable (from a generator) to an Observable&lt;/caption&gt;
* function* generateDoubles(seed) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.fromEvent" id="apidoc.module.rxjs.fromEvent">module rxjs.fromEvent</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.fromEvent.fromEvent" id="apidoc.element.rxjs.fromEvent.fromEvent">
        function <span class="apidocSignatureSpan">rxjs.</span>fromEvent
        <span class="apidocSignatureSpan">(target, eventName, options, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEvent = function (target, eventName, options, selector) {
    if (isFunction_1.isFunction(options)) {
        selector = options;
        options = undefined;
    }
    return new FromEventObservable(target, eventName, selector, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* subscriber, so although each subscriber may think it is subscribing to the
* same Observable, in fact each subscriber gets its own individual
* Observable.
*
* @example &lt;caption&gt;Subscribe to either an Observable of clicks or an Observable of interval, at random&lt;/caption&amp;#
x3e;
* var clicksOrInterval = Rx.Observable.defer(function () {
*   if (Math.random() &gt; 0.5) {
*     return Rx.Observable.<span class="apidocCodeKeywordSpan">fromEvent</span>(document, 'click');
*   } else {
*     return Rx.Observable.interval(1000);
*   }
* });
* clicksOrInterval.subscribe(x =&gt; console.log(x));
*
* // Results in the following behavior:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.fromEventPattern" id="apidoc.module.rxjs.fromEventPattern">module rxjs.fromEventPattern</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.fromEventPattern.fromEventPattern" id="apidoc.element.rxjs.fromEventPattern.fromEventPattern">
        function <span class="apidocSignatureSpan">rxjs.</span>fromEventPattern
        <span class="apidocSignatureSpan">(addHandler, removeHandler, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromEventPattern = function (addHandler, removeHandler, selector) {
    return new FromEventPatternObservable(addHandler, removeHandler, selector);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*   document.addEventListener('click', handler);
* }
*
* function removeClickHandler(handler) {
*   document.removeEventListener('click', handler);
* }
*
* var clicks = Rx.Observable.<span class="apidocCodeKeywordSpan">fromEventPattern</span>(
*   addClickHandler,
*   removeClickHandler
* );
* clicks.subscribe(x =&gt; console.log(x));
*
* @see {@link from}
* @see {@link fromEvent}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.fromPromise" id="apidoc.module.rxjs.fromPromise">module rxjs.fromPromise</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.fromPromise.fromPromise" id="apidoc.element.rxjs.fromPromise.fromPromise">
        function <span class="apidocSignatureSpan">rxjs.</span>fromPromise
        <span class="apidocSignatureSpan">(promise, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromPromise = function (promise, scheduler) {
    return new PromiseObservable(promise, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
* Observable. If the Promise resolves with a value, the output Observable
* emits that resolved value as a `next`, and then completes. If the Promise
* is rejected, then the output Observable emits the corresponding Error.
*
* @example &lt;caption&gt;Convert the Promise returned by Fetch to an Observable&lt;/caption&gt;
* var result = Rx.Observable.<span class="apidocCodeKeywordSpan">fromPromise</span>(fetch('http://myserver.com/'));
* result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));
*
* @see {@link bindCallback}
* @see {@link from}
*
* @param {Promise&lt;T&gt;} promise The promise to be converted.
* @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.groupBy" id="apidoc.module.rxjs.groupBy">module rxjs.groupBy</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.groupBy.groupBy" id="apidoc.element.rxjs.groupBy.groupBy">
        function <span class="apidocSignatureSpan">rxjs.</span>groupBy
        <span class="apidocSignatureSpan">(keySelector, elementSelector, durationSelector, subjectSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return this.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.groupBy.GroupedObservable" id="apidoc.element.rxjs.groupBy.GroupedObservable">
        function <span class="apidocSignatureSpan">rxjs.groupBy.</span>GroupedObservable
        <span class="apidocSignatureSpan">(key, groupSubject, refCountSubscription)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GroupedObservable(key, groupSubject, refCountSubscription) {
    _super.call(this);
    this.key = key;
    this.groupSubject = groupSubject;
    this.refCountSubscription = refCountSubscription;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.if" id="apidoc.module.rxjs.if">module rxjs.if</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.if._if" id="apidoc.element.rxjs.if._if">
        function <span class="apidocSignatureSpan">rxjs.if.</span>_if
        <span class="apidocSignatureSpan">(condition, thenSource, elseSource)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_if = function (condition, thenSource, elseSource) {
    return new IfObservable(condition, thenSource, elseSource);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.ignoreElements" id="apidoc.module.rxjs.ignoreElements">module rxjs.ignoreElements</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.ignoreElements.ignoreElements" id="apidoc.element.rxjs.ignoreElements.ignoreElements">
        function <span class="apidocSignatureSpan">rxjs.</span>ignoreElements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ignoreElements() {
    return this.lift(new IgnoreElementsOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.interval" id="apidoc.module.rxjs.interval">module rxjs.interval</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.interval.interval" id="apidoc.element.rxjs.interval.interval">
        function <span class="apidocSignatureSpan">rxjs.</span>interval
        <span class="apidocSignatureSpan">(period, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interval = function (period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async_1.async; }
    return new IntervalObservable(period, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* By default, it uses a `null` IScheduler, which means the `next`
* notifications are sent synchronously, although with a different IScheduler
* it is possible to determine when those notifications will be delivered.
*
* @example &lt;caption&gt;Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second
.&lt;/caption&gt;
* var numbers = Rx.Observable.of(10, 20, 30);
* var letters = Rx.Observable.of('a', 'b', 'c');
* var interval = Rx.Observable.<span class="apidocCodeKeywordSpan">interval</span>(1000);
* var result = numbers.concat(letters).concat(interval);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link create}
* @see {@link empty}
* @see {@link never}
* @see {@link throw}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.isArray" id="apidoc.module.rxjs.isArray">module rxjs.isArray</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.isArray.isArray" id="apidoc.element.rxjs.isArray.isArray">
        function <span class="apidocSignatureSpan">rxjs.</span>isArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArray() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
    if (trial === errorObject_1.errorObject) {
        hasErrors = true;
        errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
            flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
    }
}
if (isArray_1.<span class="apidocCodeKeywordSpan">isArray</span>(_subscriptions)) {
    index = -1;
    len = _subscriptions.length;
    while (++index &lt; len) {
        var sub = _subscriptions[index];
        if (isObject_1.isObject(sub)) {
            var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
            if (trial === errorObject_1.errorObject) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.isArrayLike" id="apidoc.module.rxjs.isArrayLike">module rxjs.isArrayLike</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.isArrayLike.isArrayLike" id="apidoc.element.rxjs.isArrayLike.isArrayLike">
        function <span class="apidocSignatureSpan">rxjs.</span>isArrayLike
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isArrayLike = function (x) { return x &amp;&amp; typeof x.length === 'number'; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
        else if (isPromise_1.isPromise(ish)) {
            return new PromiseObservable_1.PromiseObservable(ish, scheduler);
        }
        else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
            return new IteratorObservable_1.IteratorObservable(ish, scheduler);
        }
        else if (isArrayLike_1.<span class="apidocCodeKeywordSpan">isArrayLike</span>(ish)) {
            return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
        }
    }
    throw new TypeError((ish !== null &amp;&amp; typeof ish || ish) + ' is not observable');
};
FromObservable.prototype._subscribe = function (subscriber) {
    var ish = this.ish;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.isDate" id="apidoc.module.rxjs.isDate">module rxjs.isDate</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.isDate.isDate" id="apidoc.element.rxjs.isDate.isDate">
        function <span class="apidocSignatureSpan">rxjs.</span>isDate
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDate(value) {
    return value instanceof Date &amp;&amp; !isNaN(+value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    else if (isScheduler_1.isScheduler(period)) {
        scheduler = period;
    }
    if (!isScheduler_1.isScheduler(scheduler)) {
        scheduler = async_1.async;
    }
    this.scheduler = scheduler;
    this.dueTime = isDate_1.<span class="apidocCodeKeywordSpan">isDate</span>(dueTime) ?
        (+dueTime - this.scheduler.now()) :
        dueTime;
}
/**
 * Creates an Observable that starts emitting after an `initialDelay` and
 * emits ever increasing numbers after each `period` of time thereafter.
 *
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.isEmpty" id="apidoc.module.rxjs.isEmpty">module rxjs.isEmpty</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.isEmpty.isEmpty" id="apidoc.element.rxjs.isEmpty.isEmpty">
        function <span class="apidocSignatureSpan">rxjs.</span>isEmpty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEmpty() {
    return this.lift(new IsEmptyOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.isFunction" id="apidoc.module.rxjs.isFunction">module rxjs.isFunction</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.isFunction.isFunction" id="apidoc.element.rxjs.isFunction.isFunction">
        function <span class="apidocSignatureSpan">rxjs.</span>isFunction
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunction(x) {
    return typeof x === 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var SafeSubscriber = (function (_super) {
__extends(SafeSubscriber, _super);
function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
    _super.call(this);
    this._parentSubscriber = _parentSubscriber;
    var next;
    var context = this;
    if (isFunction_1.<span class="apidocCodeKeywordSpan">isFunction</span>(observerOrNext)) {
        next = observerOrNext;
    }
    else if (observerOrNext) {
        context = observerOrNext;
        next = observerOrNext.next;
        error = observerOrNext.error;
        complete = observerOrNext.complete;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.isNumeric" id="apidoc.module.rxjs.isNumeric">module rxjs.isNumeric</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.isNumeric.isNumeric" id="apidoc.element.rxjs.isNumeric.isNumeric">
        function <span class="apidocSignatureSpan">rxjs.</span>isNumeric
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray_1.isArray(val) &amp;&amp; (val - parseFloat(val) + 1) &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
__extends(IntervalObservable, _super);
function IntervalObservable(period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async_1.async; }
    _super.call(this);
    this.period = period;
    this.scheduler = scheduler;
    if (!isNumeric_1.<span class="apidocCodeKeywordSpan">isNumeric</span>(period) || period &lt; 0) {
        this.period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        this.scheduler = async_1.async;
    }
}
/**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.isObject" id="apidoc.module.rxjs.isObject">module rxjs.isObject</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.isObject.isObject" id="apidoc.element.rxjs.isObject.isObject">
        function <span class="apidocSignatureSpan">rxjs.</span>isObject
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObject(x) {
    return x != null &amp;&amp; typeof x === 'object';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
}
if (isArray_1.isArray(_subscriptions)) {
    index = -1;
    len = _subscriptions.length;
    while (++index &lt; len) {
        var sub = _subscriptions[index];
        if (isObject_1.<span class="apidocCodeKeywordSpan">isObject</span>(sub)) {
            var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || [];
                var err = errorObject_1.errorObject.e;
                if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                    errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.isPromise" id="apidoc.module.rxjs.isPromise">module rxjs.isPromise</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.isPromise.isPromise" id="apidoc.element.rxjs.isPromise.isPromise">
        function <span class="apidocSignatureSpan">rxjs.</span>isPromise
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPromise(value) {
    return value &amp;&amp; typeof value.subscribe !== 'function' &amp;&amp; typeof value.then === 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return ish;
    }
    return new FromObservable(ish, scheduler);
}
else if (isArray_1.isArray(ish)) {
    return new ArrayObservable_1.ArrayObservable(ish, scheduler);
}
else if (isPromise_1.<span class="apidocCodeKeywordSpan">isPromise</span>(ish)) {
    return new PromiseObservable_1.PromiseObservable(ish, scheduler);
}
else if (typeof ish[iterator_1.$$iterator] === 'function' || typeof ish === 'string') {
    return new IteratorObservable_1.IteratorObservable(ish, scheduler);
}
else if (isArrayLike_1.isArrayLike(ish)) {
    return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.isScheduler" id="apidoc.module.rxjs.isScheduler">module rxjs.isScheduler</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.isScheduler.isScheduler" id="apidoc.element.rxjs.isScheduler.isScheduler">
        function <span class="apidocSignatureSpan">rxjs.</span>isScheduler
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isScheduler(value) {
    return value &amp;&amp; typeof value.schedule === 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
ArrayObservable.of = function () {
    var array = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.<span class="apidocCodeKeywordSpan">isScheduler</span>(scheduler)) {
        array.pop();
    }
    else {
        scheduler = null;
    }
    var len = array.length;
    if (len &gt; 1) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.iterator" id="apidoc.module.rxjs.iterator">module rxjs.iterator</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.iterator.symbolIteratorPonyfill" id="apidoc.element.rxjs.iterator.symbolIteratorPonyfill">
        function <span class="apidocSignatureSpan">rxjs.iterator.</span>symbolIteratorPonyfill
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function symbolIteratorPonyfill(root) {
    var Symbol = root.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    }
    else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 &amp;&amp; typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i &lt; keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' &amp;&amp; key !== 'size' &amp;&amp; Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.last" id="apidoc.module.rxjs.last">module rxjs.last</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.last.last" id="apidoc.element.rxjs.last.last">
        function <span class="apidocSignatureSpan">rxjs.</span>last
        <span class="apidocSignatureSpan">(predicate, resultSelector, defaultValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function last(predicate, resultSelector, defaultValue) {
    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.let" id="apidoc.module.rxjs.let">module rxjs.let</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.let.letProto" id="apidoc.element.rxjs.let.letProto">
        function <span class="apidocSignatureSpan">rxjs.let.</span>letProto
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function letProto(func) {
    return func(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.map" id="apidoc.module.rxjs.map">module rxjs.map</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.map.map" id="apidoc.element.rxjs.map.map">
        function <span class="apidocSignatureSpan">rxjs.</span>map
        <span class="apidocSignatureSpan">(project, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(project, thisArg) {
    if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
To import only what you need by patching (this is useful for size-sensitive bundling):

```js
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/map';

Observable.of(1,2,3).<span class="apidocCodeKeywordSpan">map</span>(x =&gt; x + '!!!'); // etc
```

To import what you need and use it with proposed [bind operator](https://github.com/tc39/proposal-bind-operator):

&gt; Note: This additional syntax requires [transpiler support](http://babeljs.io/docs/plugins/transform-function-bind/) and this
 syntax may be completely withdrawn from TC39 without notice! Use at your own risk.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.map.MapOperator" id="apidoc.element.rxjs.map.MapOperator">
        function <span class="apidocSignatureSpan">rxjs.map.</span>MapOperator
        <span class="apidocSignatureSpan">(project, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MapOperator(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.mapTo" id="apidoc.module.rxjs.mapTo">module rxjs.mapTo</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.mapTo.mapTo" id="apidoc.element.rxjs.mapTo.mapTo">
        function <span class="apidocSignatureSpan">rxjs.</span>mapTo
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapTo(value) {
    return this.lift(new MapToOperator(value));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* output Observable. Those output values resulting from the projection are also
* given to the `project` function to produce new output values. This is how
* *expand* behaves recursively.
*
* @example &lt;caption&gt;Start emitting the powers of two on every click, at most 10 of them&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var powersOfTwo = clicks
*   .<span class="apidocCodeKeywordSpan">mapTo</span>(1)
*   .expand(x =&gt; Rx.Observable.of(2 * x).delay(1000))
*   .take(10);
* powersOfTwo.subscribe(x =&gt; console.log(x));
*
* @see {@link mergeMap}
* @see {@link mergeScan}
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.materialize" id="apidoc.module.rxjs.materialize">module rxjs.materialize</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.materialize.materialize" id="apidoc.element.rxjs.materialize.materialize">
        function <span class="apidocSignatureSpan">rxjs.</span>materialize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function materialize() {
    return this.lift(new MaterializeOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* This operator is useful for producing metadata of the source Observable, to
* be consumed as `next` emissions. Use it in conjunction with
* {@link dematerialize}.
*
* @example &lt;caption&gt;Convert a faulty Observable to an Observable of Notifications&lt;/caption&gt;
* var letters = Rx.Observable.of('a', 'b', 13, 'd');
* var upperCase = letters.map(x =&gt; x.toUpperCase());
* var materialized = upperCase.<span class="apidocCodeKeywordSpan">materialize</span>();
* materialized.subscribe(x =&gt; console.log(x));
*
* // Results in the following:
* // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
* // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
* // - Notification {kind: "E", value: undefined, error: TypeError:
* //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.max" id="apidoc.module.rxjs.max">module rxjs.max</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.max.max" id="apidoc.element.rxjs.max.max">
        function <span class="apidocSignatureSpan">rxjs.</span>max
        <span class="apidocSignatureSpan">(comparer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) &gt; 0 ? x : y; }
        : function (x, y) { return x &gt; y ? x : y; };
    return this.lift(new reduce_1.ReduceOperator(max));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    while (spliceCount &lt; eventsCount) {
        if ((now - _events[spliceCount].time) &lt; _windowTime) {
            break;
        }
        spliceCount++;
    }
    if (eventsCount &gt; _bufferSize) {
        spliceCount = Math.<span class="apidocCodeKeywordSpan">max</span>(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount &gt; 0) {
        _events.splice(0, spliceCount);
    }
    return _events;
};
return ReplaySubject;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.merge" id="apidoc.module.rxjs.merge">module rxjs.merge</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.merge.merge" id="apidoc.element.rxjs.merge.merge">
        function <span class="apidocSignatureSpan">rxjs.</span>merge
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeStatic() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length &gt; 1 &amp;&amp; typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null &amp;&amp; observables.length === 1 &amp;&amp; observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.mergeAll" id="apidoc.module.rxjs.mergeAll">module rxjs.mergeAll</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.mergeAll.mergeAll" id="apidoc.element.rxjs.mergeAll.mergeAll">
        function <span class="apidocSignatureSpan">rxjs.</span>mergeAll
        <span class="apidocSignatureSpan">(concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return this.lift(new MergeAllOperator(concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* inner Observable on the output Observable. The output Observable only
* completes once all inner Observables have completed. Any error delivered by
* a inner Observable will be immediately emitted on the output Observable.
*
* @example &lt;caption&gt;Spawn a new interval Observable for each click event, and blend their outputs as one Observable&lt;
;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var higherOrder = clicks.map((ev) =&gt; Rx.Observable.interval(1000));
* var firstOrder = higherOrder.<span class="apidocCodeKeywordSpan">mergeAll</span>();
* firstOrder.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Count from 0 to 9 every second for each click, but only allow 2 concurrent timers&lt;/caption&gt;
;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var higherOrder = clicks.map((ev) =&gt; Rx.Observable.interval(1000).take(10));
* var firstOrder = higherOrder.mergeAll(2);
* firstOrder.subscribe(x =&gt; console.log(x));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.mergeAll.MergeAllOperator" id="apidoc.element.rxjs.mergeAll.MergeAllOperator">
        function <span class="apidocSignatureSpan">rxjs.mergeAll.</span>MergeAllOperator
        <span class="apidocSignatureSpan">(concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MergeAllOperator(concurrent) {
    this.concurrent = concurrent;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
function concatAll() {
    return this.lift(new mergeAll_1.<span class="apidocCodeKeywordSpan">MergeAllOperator</span>(1));
}
exports.concatAll = concatAll;
//# sourceMappingURL=concatAll.js.map
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.mergeAll.MergeAllSubscriber" id="apidoc.element.rxjs.mergeAll.MergeAllSubscriber">
        function <span class="apidocSignatureSpan">rxjs.mergeAll.</span>MergeAllSubscriber
        <span class="apidocSignatureSpan">(destination, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MergeAllSubscriber(destination, concurrent) {
    _super.call(this, destination);
    this.concurrent = concurrent;
    this.hasCompleted = false;
    this.buffer = [];
    this.active = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.mergeMap" id="apidoc.module.rxjs.mergeMap">module rxjs.mergeMap</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.mergeMap.mergeMap" id="apidoc.element.rxjs.mergeMap.mergeMap">
        function <span class="apidocSignatureSpan">rxjs.</span>mergeMap
        <span class="apidocSignatureSpan">(project, resultSelector, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @example &lt;caption&gt;Emit the number 7, then complete.&lt;/caption&gt;
* var result = Rx.Observable.empty().startWith(7);
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Map and flatten only odd numbers to the sequence 'a', 'b', 'c'&lt;/
caption&gt;
* var interval = Rx.Observable.interval(1000);
* var result = interval.<span class="apidocCodeKeywordSpan">mergeMap</span>(x =&gt;
*   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
* );
* result.subscribe(x =&gt; console.log(x));
*
* // Results in the following to the console:
* // x is equal to the count on the interval eg(0,1,2,3,...)
* // x will occur every 1000ms
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.mergeMap.MergeMapOperator" id="apidoc.element.rxjs.mergeMap.MergeMapOperator">
        function <span class="apidocSignatureSpan">rxjs.mergeMap.</span>MergeMapOperator
        <span class="apidocSignatureSpan">(project, resultSelector, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MergeMapOperator(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    this.project = project;
    this.resultSelector = resultSelector;
    this.concurrent = concurrent;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
function concatMap(project, resultSelector) {
    return this.lift(new mergeMap_1.<span class="apidocCodeKeywordSpan">MergeMapOperator</span>(project, resultSelector, 1));
}
exports.concatMap = concatMap;
//# sourceMappingURL=concatMap.js.map
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.mergeMap.MergeMapSubscriber" id="apidoc.element.rxjs.mergeMap.MergeMapSubscriber">
        function <span class="apidocSignatureSpan">rxjs.mergeMap.</span>MergeMapSubscriber
        <span class="apidocSignatureSpan">(destination, project, resultSelector, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    _super.call(this, destination);
    this.project = project;
    this.resultSelector = resultSelector;
    this.concurrent = concurrent;
    this.hasCompleted = false;
    this.buffer = [];
    this.active = 0;
    this.index = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.mergeMapTo" id="apidoc.module.rxjs.mergeMapTo">module rxjs.mergeMapTo</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.mergeMapTo.mergeMapTo" id="apidoc.element.rxjs.mergeMapTo.mergeMapTo">
        function <span class="apidocSignatureSpan">rxjs.</span>mergeMapTo
        <span class="apidocSignatureSpan">(innerObservable, resultSelector, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Maps each source value to the given Observable `innerObservable` regardless
* of the source value, and then merges those resulting Observables into one
* single Observable, which is the output Observable.
*
* @example &lt;caption&gt;For each click event, start an interval Observable ticking every 1 second&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">mergeMapTo</span>(Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link concatMapTo}
* @see {@link merge}
* @see {@link mergeAll}
* @see {@link mergeMap}
* @see {@link mergeScan}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.mergeMapTo.MergeMapToOperator" id="apidoc.element.rxjs.mergeMapTo.MergeMapToOperator">
        function <span class="apidocSignatureSpan">rxjs.mergeMapTo.</span>MergeMapToOperator
        <span class="apidocSignatureSpan">(ish, resultSelector, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MergeMapToOperator(ish, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    this.ish = ish;
    this.resultSelector = resultSelector;
    this.concurrent = concurrent;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Observable} An observable of values merged together by joining the
 * passed observable with itself, one after the other, for each value emitted
 * from the source.
 * @method concatMapTo
 * @owner Observable
 */
function concatMapTo(innerObservable, resultSelector) {
    return this.lift(new mergeMapTo_1.<span class="apidocCodeKeywordSpan">MergeMapToOperator</span>(innerObservable, resultSelector
, 1));
}
exports.concatMapTo = concatMapTo;
//# sourceMappingURL=concatMapTo.js.map
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.mergeMapTo.MergeMapToSubscriber" id="apidoc.element.rxjs.mergeMapTo.MergeMapToSubscriber">
        function <span class="apidocSignatureSpan">rxjs.mergeMapTo.</span>MergeMapToSubscriber
        <span class="apidocSignatureSpan">(destination, ish, resultSelector, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    _super.call(this, destination);
    this.ish = ish;
    this.resultSelector = resultSelector;
    this.concurrent = concurrent;
    this.hasCompleted = false;
    this.buffer = [];
    this.active = 0;
    this.index = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.mergeScan" id="apidoc.module.rxjs.mergeScan">module rxjs.mergeScan</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.mergeScan.mergeScan" id="apidoc.element.rxjs.mergeScan.mergeScan">
        function <span class="apidocSignatureSpan">rxjs.</span>mergeScan
        <span class="apidocSignatureSpan">(accumulator, seed, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return this.lift(new MergeScanOperator(accumulator, seed, concurrent));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* &lt;span class="informal"&gt;It's like {@link scan}, but the Observables returned
* by the accumulator are merged into the outer Observable.&lt;/span&gt;
*
* @example &lt;caption&gt;Count the number of click events&lt;/caption&gt;
* const click$ = Rx.Observable.fromEvent(document, 'click');
* const one$ = click$.mapTo(1);
* const seed = 0;
* const count$ = one$.<span class="apidocCodeKeywordSpan">mergeScan</span>((acc, one) =&gt; Rx.Observable.of(acc + one), seed);
* count$.subscribe(x =&gt; console.log(x));
*
* // Results:
* 1
* 2
* 3
* 4
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.mergeScan.MergeScanOperator" id="apidoc.element.rxjs.mergeScan.MergeScanOperator">
        function <span class="apidocSignatureSpan">rxjs.mergeScan.</span>MergeScanOperator
        <span class="apidocSignatureSpan">(accumulator, seed, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MergeScanOperator(accumulator, seed, concurrent) {
    this.accumulator = accumulator;
    this.seed = seed;
    this.concurrent = concurrent;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.mergeScan.MergeScanSubscriber" id="apidoc.element.rxjs.mergeScan.MergeScanSubscriber">
        function <span class="apidocSignatureSpan">rxjs.mergeScan.</span>MergeScanSubscriber
        <span class="apidocSignatureSpan">(destination, accumulator, acc, concurrent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
    _super.call(this, destination);
    this.accumulator = accumulator;
    this.acc = acc;
    this.concurrent = concurrent;
    this.hasValue = false;
    this.hasCompleted = false;
    this.buffer = [];
    this.active = 0;
    this.index = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.multicast" id="apidoc.module.rxjs.multicast">module rxjs.multicast</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.multicast.multicast" id="apidoc.element.rxjs.multicast.multicast">
        function <span class="apidocSignatureSpan">rxjs.</span>multicast
        <span class="apidocSignatureSpan">(subjectOrSubjectFactory, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === 'function') {
        subjectFactory = subjectOrSubjectFactory;
    }
    else {
        subjectFactory = function subjectFactory() {
            return subjectOrSubjectFactory;
        };
    }
    if (typeof selector === 'function') {
        return this.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
    connectable.source = this;
    connectable.subjectFactory = subjectFactory;
    return connectable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.multicast.MulticastOperator" id="apidoc.element.rxjs.multicast.MulticastOperator">
        function <span class="apidocSignatureSpan">rxjs.multicast.</span>MulticastOperator
        <span class="apidocSignatureSpan">(subjectFactory, selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MulticastOperator(subjectFactory, selector) {
    this.subjectFactory = subjectFactory;
    this.selector = selector;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.never" id="apidoc.module.rxjs.never">module rxjs.never</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.never.never" id="apidoc.element.rxjs.never.never">
        function <span class="apidocSignatureSpan">rxjs.</span>never
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">never = function () {
    return new NeverObservable();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* subscription from being disposed automatically. Subscriptions need to be
* manually disposed.
*
* @example &lt;caption&gt;Emit the number 7, then never emit anything else (not even complete).&lt;/caption&gt;
* function info() {
*   console.log('Will not be called');
* }
* var result = Rx.Observable.<span class="apidocCodeKeywordSpan">never</span>().startWith(7);
* result.subscribe(x =&gt; console.log(x), info, info);
*
* @see {@link create}
* @see {@link empty}
* @see {@link of}
* @see {@link throw}
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.noop" id="apidoc.module.rxjs.noop">module rxjs.noop</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.noop.noop" id="apidoc.element.rxjs.noop.noop">
        function <span class="apidocSignatureSpan">rxjs.</span>noop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() { }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     * @name never
     * @owner Observable
     */
    NeverObservable.create = function () {
        return new NeverObservable();
    };
    NeverObservable.prototype._subscribe = function (subscriber) {
        noop_1.<span class="apidocCodeKeywordSpan">noop</span>();
    };
    return NeverObservable;
}(Observable_1.Observable));
exports.NeverObservable = NeverObservable;
//# sourceMappingURL=NeverObservable.js.map
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.not" id="apidoc.module.rxjs.not">module rxjs.not</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.not.not" id="apidoc.element.rxjs.not.not">
        function <span class="apidocSignatureSpan">rxjs.</span>not
        <span class="apidocSignatureSpan">(pred, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * pass the predicate.
 * @method partition
 * @owner Observable
 */
function partition(predicate, thisArg) {
    return [
        filter_1.filter.call(this, predicate, thisArg),
        filter_1.filter.call(this, not_1.<span class="apidocCodeKeywordSpan">not</span>(predicate, thisArg))
    ];
}
exports.partition = partition;
//# sourceMappingURL=partition.js.map
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.observeOn" id="apidoc.module.rxjs.observeOn">module rxjs.observeOn</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.observeOn.observeOn" id="apidoc.element.rxjs.observeOn.observeOn">
        function <span class="apidocSignatureSpan">rxjs.</span>observeOn
        <span class="apidocSignatureSpan">(scheduler, delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return this.lift(new ObserveOnOperator(scheduler, delay));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.observeOn.ObserveOnMessage" id="apidoc.element.rxjs.observeOn.ObserveOnMessage">
        function <span class="apidocSignatureSpan">rxjs.observeOn.</span>ObserveOnMessage
        <span class="apidocSignatureSpan">(notification, destination)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObserveOnMessage(notification, destination) {
    this.notification = notification;
    this.destination = destination;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.observeOn.ObserveOnOperator" id="apidoc.element.rxjs.observeOn.ObserveOnOperator">
        function <span class="apidocSignatureSpan">rxjs.observeOn.</span>ObserveOnOperator
        <span class="apidocSignatureSpan">(scheduler, delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObserveOnOperator(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    this.scheduler = scheduler;
    this.delay = delay;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.observeOn.ObserveOnSubscriber" id="apidoc.element.rxjs.observeOn.ObserveOnSubscriber">
        function <span class="apidocSignatureSpan">rxjs.observeOn.</span>ObserveOnSubscriber
        <span class="apidocSignatureSpan">(destination, scheduler, delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObserveOnSubscriber(destination, scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    _super.call(this, destination);
    this.scheduler = scheduler;
    this.delay = delay;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    subscription = Subscription_1.Subscription.EMPTY;
}
else {
    this.observers.push(subscriber);
    subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
}
if (scheduler) {
    subscriber.add(subscriber = new observeOn_1.<span class="apidocCodeKeywordSpan">ObserveOnSubscriber</span>(subscriber, scheduler
));
}
var len = _events.length;
for (var i = 0; i &lt; len &amp;&amp; !subscriber.closed; i++) {
    subscriber.next(_events[i].value);
}
if (this.hasError) {
    subscriber.error(this.thrownError);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.of" id="apidoc.module.rxjs.of">module rxjs.of</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.of.of" id="apidoc.element.rxjs.of.of">
        function <span class="apidocSignatureSpan">rxjs.</span>of
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">of = function () {
    var array = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
    }
    else {
        scheduler = null;
    }
    var len = array.length;
    if (len &gt; 1) {
        return new ArrayObservable(array, scheduler);
    }
    else if (len === 1) {
        return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
    }
    else {
        return new EmptyObservable_1.EmptyObservable(scheduler);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

To import the entire core set of functionality:

```js
import Rx from 'rxjs/Rx';

Rx.Observable.<span class="apidocCodeKeywordSpan">of</span>(1,2,3)
```

To import only what you need by patching (this is useful for size-sensitive bundling):

```js
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.onErrorResumeNext" id="apidoc.module.rxjs.onErrorResumeNext">module rxjs.onErrorResumeNext</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.onErrorResumeNext.onErrorResumeNext" id="apidoc.element.rxjs.onErrorResumeNext.onErrorResumeNext">
        function <span class="apidocSignatureSpan">rxjs.</span>onErrorResumeNext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    if (nextSources.length === 1 &amp;&amp; isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return this.lift(new OnErrorResumeNextOperator(nextSources));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.onErrorResumeNext.onErrorResumeNextStatic" id="apidoc.element.rxjs.onErrorResumeNext.onErrorResumeNextStatic">
        function <span class="apidocSignatureSpan">rxjs.onErrorResumeNext.</span>onErrorResumeNextStatic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        nextSources[_i - 0] = arguments[_i];
    }
    var source = null;
    if (nextSources.length === 1 &amp;&amp; isArray_1.isArray(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.pairs" id="apidoc.module.rxjs.pairs">module rxjs.pairs</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.pairs.pairs" id="apidoc.element.rxjs.pairs.pairs">
        function <span class="apidocSignatureSpan">rxjs.</span>pairs
        <span class="apidocSignatureSpan">(obj, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pairs = function (obj, scheduler) {
    return new PairsObservable(obj, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @example &lt;caption&gt;Converts a javascript object to an Observable&lt;/caption&gt;
* var obj = {
*   foo: 42,
*   bar: 56,
*   baz: 78
* };
*
* var source = Rx.Observable.<span class="apidocCodeKeywordSpan">pairs</span>(obj);
*
* var subscription = source.subscribe(
*   function (x) {
*     console.log('Next: %s', x);
*   },
*   function (err) {
*     console.log('Error: %s', err);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.pairwise" id="apidoc.module.rxjs.pairwise">module rxjs.pairwise</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.pairwise.pairwise" id="apidoc.element.rxjs.pairwise.pairwise">
        function <span class="apidocSignatureSpan">rxjs.</span>pairwise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pairwise() {
    return this.lift(new PairwiseOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* to emit an array [(N-1)th, Nth] of the previous and the current value, as a
* pair. For this reason, `pairwise` emits on the second and subsequent
* emissions from the source Observable, but not on the first emission, because
* there is no previous value in that case.
*
* @example &lt;caption&gt;On every click (starting from the second), emit the relative distance to the previous click&lt;/
caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var pairs = clicks.<span class="apidocCodeKeywordSpan">pairwise</span>();
* var distance = pairs.map(pair =&gt; {
*   var x0 = pair[0].clientX;
*   var y0 = pair[0].clientY;
*   var x1 = pair[1].clientX;
*   var y1 = pair[1].clientY;
*   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
* });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.partition" id="apidoc.module.rxjs.partition">module rxjs.partition</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.partition.partition" id="apidoc.element.rxjs.partition.partition">
        function <span class="apidocSignatureSpan">rxjs.</span>partition
        <span class="apidocSignatureSpan">(predicate, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function partition(predicate, thisArg) {
    return [
        filter_1.filter.call(this, predicate, thisArg),
        filter_1.filter.call(this, not_1.not(predicate, thisArg))
    ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Observable in that array emits source values for which the predicate argument
* returns true. The second Observable emits source values for which the
* predicate returns false. The first behaves like {@link filter} and the second
* behaves like {@link filter} with the predicate negated.
*
* @example &lt;caption&gt;Partition click events into those on DIV elements and those elsewhere&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var parts = clicks.<span class="apidocCodeKeywordSpan">partition</span>(ev =&gt; ev.target.tagName === 'DIV');
* var clicksOnDivs = parts[0];
* var clicksElsewhere = parts[1];
* clicksOnDivs.subscribe(x =&gt; console.log('DIV clicked: ', x));
* clicksElsewhere.subscribe(x =&gt; console.log('Other clicked: ', x));
*
* @see {@link filter}
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.pluck" id="apidoc.module.rxjs.pluck">module rxjs.pluck</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.pluck.pluck" id="apidoc.element.rxjs.pluck.pluck">
        function <span class="apidocSignatureSpan">rxjs.</span>pluck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pluck() {
    var properties = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        properties[_i - 0] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return map_1.map.call(this, plucker(properties, length));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Given a list of strings describing a path to an object property, retrieves
* the value of a specified nested property from all values in the source
* Observable. If a property can't be resolved, it will return `undefined` for
* that value.
*
* @example &lt;caption&gt;Map every every click to the tagName of the clicked target element&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var tagNames = clicks.<span class="apidocCodeKeywordSpan">pluck</span>('target', 'tagName');
* tagNames.subscribe(x =&gt; console.log(x));
*
* @see {@link map}
*
* @param {...string} properties The nested properties to pluck from each source
* value (an object).
* @return {Observable} A new Observable of property values from the source values.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.publish" id="apidoc.module.rxjs.publish">module rxjs.publish</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.publish.publish" id="apidoc.element.rxjs.publish.publish">
        function <span class="apidocSignatureSpan">rxjs.</span>publish
        <span class="apidocSignatureSpan">(selector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publish(selector) {
    return selector ? multicast_1.multicast.call(this, function () { return new Subject_1.Subject(); }, selector) :
        multicast_1.multicast.call(this, new Subject_1.Subject());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// where the ConnectableObservable source synchronously emits values, and
// the RefCountSubscriber's downstream Observers synchronously unsubscribe,
// execution continues to here before the RefCountOperator has a chance to
// supply the RefCountSubscriber with the shared connection Subscription.
// For example:
// ```
// Observable.range(0, 10)
//   .<span class="apidocCodeKeywordSpan">publish</span>()
//   .refCount()
//   .take(5)
//   .subscribe();
// ```
// In order to account for this case, RefCountSubscriber should only dispose
// the ConnectableObservable's shared connection Subscription if the
// connection Subscription exists, *and* either:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.publishBehavior" id="apidoc.module.rxjs.publishBehavior">module rxjs.publishBehavior</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.publishBehavior.publishBehavior" id="apidoc.element.rxjs.publishBehavior.publishBehavior">
        function <span class="apidocSignatureSpan">rxjs.</span>publishBehavior
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publishBehavior(value) {
    return multicast_1.multicast.call(this, new BehaviorSubject_1.BehaviorSubject(value));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.publishLast" id="apidoc.module.rxjs.publishLast">module rxjs.publishLast</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.publishLast.publishLast" id="apidoc.element.rxjs.publishLast.publishLast">
        function <span class="apidocSignatureSpan">rxjs.</span>publishLast
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publishLast() {
    return multicast_1.multicast.call(this, new AsyncSubject_1.AsyncSubject());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.publishReplay" id="apidoc.module.rxjs.publishReplay">module rxjs.publishReplay</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.publishReplay.publishReplay" id="apidoc.element.rxjs.publishReplay.publishReplay">
        function <span class="apidocSignatureSpan">rxjs.</span>publishReplay
        <span class="apidocSignatureSpan">(bufferSize, windowTime, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publishReplay(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
    return multicast_1.multicast.call(this, new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.race" id="apidoc.module.rxjs.race">module rxjs.race</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.race.race" id="apidoc.element.rxjs.race.race">
        function <span class="apidocSignatureSpan">rxjs.</span>race
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `pair([obs1, obs2, ...])`
    if (observables.length === 1 &amp;&amp; isArray_1.isArray(observables[0])) {
        observables = observables[0];
    }
    return this.lift.call(raceStatic.apply(void 0, [this].concat(observables)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.race.RaceOperator" id="apidoc.element.rxjs.race.RaceOperator">
        function <span class="apidocSignatureSpan">rxjs.race.</span>RaceOperator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RaceOperator() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.race.RaceSubscriber" id="apidoc.element.rxjs.race.RaceSubscriber">
        function <span class="apidocSignatureSpan">rxjs.race.</span>RaceSubscriber
        <span class="apidocSignatureSpan">(destination)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RaceSubscriber(destination) {
    _super.call(this, destination);
    this.hasFirst = false;
    this.observables = [];
    this.subscriptions = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.race.raceStatic" id="apidoc.element.rxjs.race.raceStatic">
        function <span class="apidocSignatureSpan">rxjs.race.</span>raceStatic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function raceStatic() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `pair([obs1, obs2, ...])`
    if (observables.length === 1) {
        if (isArray_1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.range" id="apidoc.module.rxjs.range">module rxjs.range</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.range.range" id="apidoc.element.rxjs.range.range">
        function <span class="apidocSignatureSpan">rxjs.</span>range
        <span class="apidocSignatureSpan">(start, count, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">range = function (start, count, scheduler) {
    if (start === void 0) { start = 0; }
    if (count === void 0) { count = 0; }
    return new RangeObservable(start, count, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// connection Subscription on the shared ConnectableObservable. In cases
// where the ConnectableObservable source synchronously emits values, and
// the RefCountSubscriber's downstream Observers synchronously unsubscribe,
// execution continues to here before the RefCountOperator has a chance to
// supply the RefCountSubscriber with the shared connection Subscription.
// For example:
// ```
// Observable.<span class="apidocCodeKeywordSpan">range</span>(0, 10)
//   .publish()
//   .refCount()
//   .take(5)
//   .subscribe();
// ```
// In order to account for this case, RefCountSubscriber should only dispose
// the ConnectableObservable's shared connection Subscription if the
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.reduce" id="apidoc.module.rxjs.reduce">module rxjs.reduce</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.reduce.reduce" id="apidoc.element.rxjs.reduce.reduce">
        function <span class="apidocSignatureSpan">rxjs.</span>reduce
        <span class="apidocSignatureSpan">(accumulator, seed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length &gt;= 2) {
        hasSeed = true;
    }
    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.<span class="apidocCodeKeywordSpan">reduce</span>(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1
.UnsubscriptionError) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.reduce.ReduceOperator" id="apidoc.element.rxjs.reduce.ReduceOperator">
        function <span class="apidocSignatureSpan">rxjs.reduce.</span>ReduceOperator
        <span class="apidocSignatureSpan">(accumulator, seed, hasSeed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReduceOperator(accumulator, seed, hasSeed) {
    if (hasSeed === void 0) { hasSeed = false; }
    this.accumulator = accumulator;
    this.seed = seed;
    this.hasSeed = hasSeed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @method max
 * @owner Observable
 */
function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) &gt; 0 ? x : y; }
        : function (x, y) { return x &gt; y ? x : y; };
    return this.lift(new reduce_1.<span class="apidocCodeKeywordSpan">ReduceOperator</span>(max));
}
exports.max = max;
//# sourceMappingURL=max.js.map
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.reduce.ReduceSubscriber" id="apidoc.element.rxjs.reduce.ReduceSubscriber">
        function <span class="apidocSignatureSpan">rxjs.reduce.</span>ReduceSubscriber
        <span class="apidocSignatureSpan">(destination, accumulator, seed, hasSeed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReduceSubscriber(destination, accumulator, seed, hasSeed) {
    _super.call(this, destination);
    this.accumulator = accumulator;
    this.hasSeed = hasSeed;
    this.index = 0;
    this.hasValue = false;
    this.acc = seed;
    if (!this.hasSeed) {
        this.index++;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.repeat" id="apidoc.module.rxjs.repeat">module rxjs.repeat</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.repeat.repeat" id="apidoc.element.rxjs.repeat.repeat">
        function <span class="apidocSignatureSpan">rxjs.</span>repeat
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function repeat(count) {
    if (count === void 0) { count = -1; }
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    else if (count &lt; 0) {
        return this.lift(new RepeatOperator(-1, this));
    }
    else {
        return this.lift(new RepeatOperator(count - 1, this));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.repeatWhen" id="apidoc.module.rxjs.repeatWhen">module rxjs.repeatWhen</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.repeatWhen.repeatWhen" id="apidoc.element.rxjs.repeatWhen.repeatWhen">
        function <span class="apidocSignatureSpan">rxjs.</span>repeatWhen
        <span class="apidocSignatureSpan">(notifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function repeatWhen(notifier) {
    return this.lift(new RepeatWhenOperator(notifier));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.retry" id="apidoc.module.rxjs.retry">module rxjs.retry</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.retry.retry" id="apidoc.element.rxjs.retry.retry">
        function <span class="apidocSignatureSpan">rxjs.</span>retry
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry(count) {
    if (count === void 0) { count = -1; }
    return this.lift(new RetryOperator(count, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.retryWhen" id="apidoc.module.rxjs.retryWhen">module rxjs.retryWhen</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.retryWhen.retryWhen" id="apidoc.element.rxjs.retryWhen.retryWhen">
        function <span class="apidocSignatureSpan">rxjs.</span>retryWhen
        <span class="apidocSignatureSpan">(notifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retryWhen(notifier) {
    return this.lift(new RetryWhenOperator(notifier, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.sample" id="apidoc.module.rxjs.sample">module rxjs.sample</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.sample.sample" id="apidoc.element.rxjs.sample.sample">
        function <span class="apidocSignatureSpan">rxjs.</span>sample
        <span class="apidocSignatureSpan">(notifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sample(notifier) {
    return this.lift(new SampleOperator(notifier));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* emitted since the previous sampling, unless the source has not emitted
* anything since the previous sampling. The `notifier` is subscribed to as soon
* as the output Observable is subscribed.
*
* @example &lt;caption&gt;On every click, sample the most recent "seconds" timer&lt;/caption&gt;
* var seconds = Rx.Observable.interval(1000);
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = seconds.<span class="apidocCodeKeywordSpan">sample</span>(clicks);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link audit}
* @see {@link debounce}
* @see {@link sampleTime}
* @see {@link throttle}
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.sampleTime" id="apidoc.module.rxjs.sampleTime">module rxjs.sampleTime</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.sampleTime.sampleTime" id="apidoc.element.rxjs.sampleTime.sampleTime">
        function <span class="apidocSignatureSpan">rxjs.</span>sampleTime
        <span class="apidocSignatureSpan">(period, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sampleTime(period, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new SampleTimeOperator(period, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* source has not emitted anything since the previous sampling. The sampling
* happens periodically in time every `period` milliseconds (or the time unit
* defined by the optional `scheduler` argument). The sampling starts as soon as
* the output Observable is subscribed.
*
* @example &lt;caption&gt;Every second, emit the most recent click at most once&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">sampleTime</span>(1000);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link auditTime}
* @see {@link debounceTime}
* @see {@link delay}
* @see {@link sample}
* @see {@link throttleTime}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.scan" id="apidoc.module.rxjs.scan">module rxjs.scan</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.scan.scan" id="apidoc.element.rxjs.scan.scan">
        function <span class="apidocSignatureSpan">rxjs.</span>scan
        <span class="apidocSignatureSpan">(accumulator, seed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scan(accumulator, seed) {
    var hasSeed = false;
    // providing a seed of `undefined` *should* be valid and trigger
    // hasSeed! so don't use `seed !== undefined` checks!
    // For this reason, we have to check it here at the original call site
    // otherwise inside Operator/Subscriber we won't know if `undefined`
    // means they didn't provide anything or if they literally provided `undefined`
    if (arguments.length &gt;= 2) {
        hasSeed = true;
    }
    return this.lift(new ScanOperator(accumulator, seed, hasSeed));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* that value will be used as the initial value for the accumulator. If no seed
* value is specified, the first item of the source is used as the seed.
*
* @example &lt;caption&gt;Count the number of click events&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var ones = clicks.mapTo(1);
* var seed = 0;
* var count = ones.<span class="apidocCodeKeywordSpan">scan</span>((acc, one) =&gt; acc + one, seed);
* count.subscribe(x =&gt; console.log(x));
*
* @see {@link expand}
* @see {@link mergeScan}
* @see {@link reduce}
*
* @param {function(acc: R, value: T, index: number): R} accumulator
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.sequenceEqual" id="apidoc.module.rxjs.sequenceEqual">module rxjs.sequenceEqual</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.sequenceEqual.sequenceEqual" id="apidoc.element.rxjs.sequenceEqual.sequenceEqual">
        function <span class="apidocSignatureSpan">rxjs.</span>sequenceEqual
        <span class="apidocSignatureSpan">(compareTo, comparor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sequenceEqual(compareTo, comparor) {
    return this.lift(new SequenceEqualOperator(compareTo, comparor));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* var keys = Rx.Observable.fromEvent(document, 'keyup')
*  .map(e =&gt; e.code);
* var matches = keys.bufferCount(11, 1)
*  .mergeMap(
*    last11 =&gt;
*      Rx.Observable.from(last11)
*        .<span class="apidocCodeKeywordSpan">sequenceEqual</span>(code)
*   );
* matches.subscribe(matched =&gt; console.log('Successful cheat at Contra? ', matched));
*
* @see {@link combineLatest}
* @see {@link zip}
* @see {@link withLatestFrom}
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.sequenceEqual.SequenceEqualOperator" id="apidoc.element.rxjs.sequenceEqual.SequenceEqualOperator">
        function <span class="apidocSignatureSpan">rxjs.sequenceEqual.</span>SequenceEqualOperator
        <span class="apidocSignatureSpan">(compareTo, comparor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SequenceEqualOperator(compareTo, comparor) {
    this.compareTo = compareTo;
    this.comparor = comparor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.sequenceEqual.SequenceEqualSubscriber" id="apidoc.element.rxjs.sequenceEqual.SequenceEqualSubscriber">
        function <span class="apidocSignatureSpan">rxjs.sequenceEqual.</span>SequenceEqualSubscriber
        <span class="apidocSignatureSpan">(destination, compareTo, comparor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SequenceEqualSubscriber(destination, compareTo, comparor) {
    _super.call(this, destination);
    this.compareTo = compareTo;
    this.comparor = comparor;
    this._a = [];
    this._b = [];
    this._oneComplete = false;
    this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.share" id="apidoc.module.rxjs.share">module rxjs.share</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.share.share" id="apidoc.element.rxjs.share.share">
        function <span class="apidocSignatureSpan">rxjs.</span>share
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function share() {
    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.single" id="apidoc.module.rxjs.single">module rxjs.single</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.single.single" id="apidoc.element.rxjs.single.single">
        function <span class="apidocSignatureSpan">rxjs.</span>single
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function single(predicate) {
    return this.lift(new SingleOperator(predicate, this));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.skip" id="apidoc.module.rxjs.skip">module rxjs.skip</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.skip.skip" id="apidoc.element.rxjs.skip.skip">
        function <span class="apidocSignatureSpan">rxjs.</span>skip
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skip(count) {
    return this.lift(new SkipOperator(count));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Observable. If `startWindowEvery` is not provided, then new windows are
* started immediately at the start of the source and when each window completes
* with size `windowSize`.
*
* @example &lt;caption&gt;Ignore every 3rd click event, starting from the first one&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.windowCount(3)
*   .map(win =&gt; win.<span class="apidocCodeKeywordSpan">skip</span>(1)) // skip first of every 3 clicks
*   .mergeAll(); // flatten the Observable-of-Observables
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Ignore every 3rd click event, starting from the third one&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.windowCount(2, 3)
*   .mergeAll(); // flatten the Observable-of-Observables
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.skipUntil" id="apidoc.module.rxjs.skipUntil">module rxjs.skipUntil</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.skipUntil.skipUntil" id="apidoc.element.rxjs.skipUntil.skipUntil">
        function <span class="apidocSignatureSpan">rxjs.</span>skipUntil
        <span class="apidocSignatureSpan">(notifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipUntil(notifier) {
    return this.lift(new SkipUntilOperator(notifier));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.skipWhile" id="apidoc.module.rxjs.skipWhile">module rxjs.skipWhile</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.skipWhile.skipWhile" id="apidoc.element.rxjs.skipWhile.skipWhile">
        function <span class="apidocSignatureSpan">rxjs.</span>skipWhile
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skipWhile(predicate) {
    return this.lift(new SkipWhileOperator(predicate));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.startWith" id="apidoc.module.rxjs.startWith">module rxjs.startWith</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.startWith.startWith" id="apidoc.element.rxjs.startWith.startWith">
        function <span class="apidocSignatureSpan">rxjs.</span>startWith
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startWith() {
    var array = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
    }
    else {
        scheduler = null;
    }
    var len = array.length;
    if (len === 1) {
        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
    }
    else if (len &gt; 1) {
        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
    }
    else {
        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* &lt;img src="./img/empty.png" width="100%"&gt;
*
* This static operator is useful for creating a simple Observable that only
* emits the complete notification. It can be used for composing with other
* Observables, such as in a {@link mergeMap}.
*
* @example &lt;caption&gt;Emit the number 7, then complete.&lt;/caption&gt;
* var result = Rx.Observable.empty().<span class="apidocCodeKeywordSpan">startWith</span>(7);
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Map and flatten only odd numbers to the sequence 'a', 'b', 'c'&lt;/
caption&gt;
* var interval = Rx.Observable.interval(1000);
* var result = interval.mergeMap(x =&gt;
*   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
* );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.subscribeOn" id="apidoc.module.rxjs.subscribeOn">module rxjs.subscribeOn</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.subscribeOn.subscribeOn" id="apidoc.element.rxjs.subscribeOn.subscribeOn">
        function <span class="apidocSignatureSpan">rxjs.</span>subscribeOn
        <span class="apidocSignatureSpan">(scheduler, delay)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subscribeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return this.lift(new SubscribeOnOperator(scheduler, delay));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.subscribeToResult" id="apidoc.module.rxjs.subscribeToResult">module rxjs.subscribeToResult</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.subscribeToResult.subscribeToResult" id="apidoc.element.rxjs.subscribeToResult.subscribeToResult">
        function <span class="apidocSignatureSpan">rxjs.</span>subscribeToResult
        <span class="apidocSignatureSpan">(outerSubscriber, result, outerValue, outerIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        }
        else {
            return result.subscribe(destination);
        }
    }
    else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i &lt; len &amp;&amp; !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    }
    else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) { return destination.error(err); })
            .then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () { throw err; });
        });
        return destination;
    }
    else if (result &amp;&amp; typeof result[iterator_1.$$iterator] === 'function') {
        var iterator = result[iterator_1.$$iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    }
    else if (result &amp;&amp; typeof result[observable_1.$$observable] === 'function') {
        var obs = result[observable_1.$$observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        }
        else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = ("You provided " + value + " where a stream was expected.")
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        catch (err) {
            this._error(err);
        }
    };
    DeferSubscriber.prototype._callFactory = function () {
        var result = this.factory();
        if (result) {
            this.add(subscribeToResult_1.<span class="apidocCodeKeywordSpan">subscribeToResult</span>(this, result));
        }
    };
    return DeferSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
//# sourceMappingURL=DeferObservable.js.map
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.switch" id="apidoc.module.rxjs.switch">module rxjs.switch</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.switch._switch" id="apidoc.element.rxjs.switch._switch">
        function <span class="apidocSignatureSpan">rxjs.switch.</span>_switch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _switch() {
    return this.lift(new SwitchOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.switchMap" id="apidoc.module.rxjs.switchMap">module rxjs.switchMap</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.switchMap.switchMap" id="apidoc.element.rxjs.switchMap.switchMap">
        function <span class="apidocSignatureSpan">rxjs.</span>switchMap
        <span class="apidocSignatureSpan">(project, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function switchMap(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* that inner Observable. When a new inner Observable is emitted, `switchMap`
* stops emitting items from the earlier-emitted inner Observable and begins
* emitting items from the new one. It continues to behave like this for
* subsequent inner Observables.
*
* @example &lt;caption&gt;Rerun an interval Observable on every click event&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">switchMap</span>((ev) =&gt; Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link concatMap}
* @see {@link exhaustMap}
* @see {@link mergeMap}
* @see {@link switch}
* @see {@link switchMapTo}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.switchMapTo" id="apidoc.module.rxjs.switchMapTo">module rxjs.switchMapTo</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.switchMapTo.switchMapTo" id="apidoc.element.rxjs.switchMapTo.switchMapTo">
        function <span class="apidocSignatureSpan">rxjs.</span>switchMapTo
        <span class="apidocSignatureSpan">(innerObservable, resultSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function switchMapTo(innerObservable, resultSelector) {
    return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* of the source value, and then flattens those resulting Observables into one
* single Observable, which is the output Observable. The output Observables
* emits values only from the most recently emitted instance of
* `innerObservable`.
*
* @example &lt;caption&gt;Rerun an interval Observable on every click event&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">switchMapTo</span>(Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link concatMapTo}
* @see {@link switch}
* @see {@link switchMap}
* @see {@link mergeMapTo}
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.take" id="apidoc.module.rxjs.take">module rxjs.take</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.take.take" id="apidoc.element.rxjs.take.take">
        function <span class="apidocSignatureSpan">rxjs.</span>take
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function take(count) {
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    else {
        return this.lift(new TakeOperator(count));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// execution continues to here before the RefCountOperator has a chance to
// supply the RefCountSubscriber with the shared connection Subscription.
// For example:
// ```
// Observable.range(0, 10)
//   .publish()
//   .refCount()
//   .<span class="apidocCodeKeywordSpan">take</span>(5)
//   .subscribe();
// ```
// In order to account for this case, RefCountSubscriber should only dispose
// the ConnectableObservable's shared connection Subscription if the
// connection Subscription exists, *and* either:
//   a. RefCountSubscriber doesn't have a reference to the shared connection
//      Subscription yet, or,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.takeLast" id="apidoc.module.rxjs.takeLast">module rxjs.takeLast</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.takeLast.takeLast" id="apidoc.element.rxjs.takeLast.takeLast">
        function <span class="apidocSignatureSpan">rxjs.</span>takeLast
        <span class="apidocSignatureSpan">(count)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function takeLast(count) {
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    }
    else {
        return this.lift(new TakeLastOperator(count));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `complete` notification emission from the source in order to emit the `next`
* values on the output Observable, because otherwise it is impossible to know
* whether or not more values will be emitted on the source. For this reason,
* all values are emitted synchronously, followed by the complete notification.
*
* @example &lt;caption&gt;Take the last 3 values of an Observable with many values&lt;/caption&gt;
* var many = Rx.Observable.range(1, 100);
* var lastThree = many.<span class="apidocCodeKeywordSpan">takeLast</span>(3);
* lastThree.subscribe(x =&gt; console.log(x));
*
* @see {@link take}
* @see {@link takeUntil}
* @see {@link takeWhile}
* @see {@link skip}
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.takeUntil" id="apidoc.module.rxjs.takeUntil">module rxjs.takeUntil</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.takeUntil.takeUntil" id="apidoc.element.rxjs.takeUntil.takeUntil">
        function <span class="apidocSignatureSpan">rxjs.</span>takeUntil
        <span class="apidocSignatureSpan">(notifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function takeUntil(notifier) {
    return this.lift(new TakeUntilOperator(notifier));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* a value nor terminate. This operator takes an optional `predicate` function
* as argument, in which case the output emission will represent the number of
* source values that matched `true` with the `predicate`.
*
* @example &lt;caption&gt;Counts how many seconds have passed before the first click happened&lt;/caption&gt;
* var seconds = Rx.Observable.interval(1000);
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var secondsBeforeClick = seconds.<span class="apidocCodeKeywordSpan">takeUntil</span>(clicks);
* var result = secondsBeforeClick.count();
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Counts how many odd numbers are there between 1 and 7&lt;/caption&gt;
* var numbers = Rx.Observable.range(1, 7);
* var result = numbers.count(i =&gt; i % 2 === 1);
* result.subscribe(x =&gt; console.log(x));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.takeWhile" id="apidoc.module.rxjs.takeWhile">module rxjs.takeWhile</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.takeWhile.takeWhile" id="apidoc.element.rxjs.takeWhile.takeWhile">
        function <span class="apidocSignatureSpan">rxjs.</span>takeWhile
        <span class="apidocSignatureSpan">(predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function takeWhile(predicate) {
    return this.lift(new TakeWhileOperator(predicate));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* boolean, representing a condition to be satisfied by the source values. The
* output Observable emits the source values until such time as the `predicate`
* returns false, at which point `takeWhile` stops mirroring the source
* Observable and completes the output Observable.
*
* @example &lt;caption&gt;Emit click events only while the clientX property is greater than 200&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">takeWhile</span>(ev =&gt; ev.clientX &gt; 200);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link take}
* @see {@link takeLast}
* @see {@link takeUntil}
* @see {@link skip}
*
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.throttle" id="apidoc.module.rxjs.throttle">module rxjs.throttle</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.throttle.throttle" id="apidoc.element.rxjs.throttle.throttle">
        function <span class="apidocSignatureSpan">rxjs.</span>throttle
        <span class="apidocSignatureSpan">(durationSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function throttle(durationSelector) {
    return this.lift(new ThrottleOperator(durationSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* is enabled by calling the `durationSelector` function with the source value,
* which returns the "duration" Observable. When the duration Observable emits a
* value or completes, the timer is disabled, and this process repeats for the
* next source value.
*
* @example &lt;caption&gt;Emit clicks at a rate of at most one click per second&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">throttle</span>(ev =&gt; Rx.Observable.interval(1000));
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link audit}
* @see {@link debounce}
* @see {@link delayWhen}
* @see {@link sample}
* @see {@link throttleTime}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.throttleTime" id="apidoc.module.rxjs.throttleTime">module rxjs.throttleTime</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.throttleTime.throttleTime" id="apidoc.element.rxjs.throttleTime.throttleTime">
        function <span class="apidocSignatureSpan">rxjs.</span>throttleTime
        <span class="apidocSignatureSpan">(duration, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function throttleTime(duration, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new ThrottleTimeOperator(duration, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* is enabled. After `duration` milliseconds (or the time unit determined
* internally by the optional `scheduler`) has passed, the timer is disabled,
* and this process repeats for the next source value. Optionally takes a
* {@link IScheduler} for managing timers.
*
* @example &lt;caption&gt;Emit clicks at a rate of at most one click per second&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">throttleTime</span>(1000);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link auditTime}
* @see {@link debounceTime}
* @see {@link delay}
* @see {@link sampleTime}
* @see {@link throttle}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.throw" id="apidoc.module.rxjs.throw">module rxjs.throw</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.throw._throw" id="apidoc.element.rxjs.throw._throw">
        function <span class="apidocSignatureSpan">rxjs.throw.</span>_throw
        <span class="apidocSignatureSpan">(error, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_throw = function (error, scheduler) {
    return new ErrorObservable(error, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.timeInterval" id="apidoc.module.rxjs.timeInterval">module rxjs.timeInterval</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.timeInterval.timeInterval" id="apidoc.element.rxjs.timeInterval.timeInterval">
        function <span class="apidocSignatureSpan">rxjs.</span>timeInterval
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeInterval(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new TimeIntervalOperator(scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.timeInterval.TimeInterval" id="apidoc.element.rxjs.timeInterval.TimeInterval">
        function <span class="apidocSignatureSpan">rxjs.timeInterval.</span>TimeInterval
        <span class="apidocSignatureSpan">(value, interval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeInterval(value, interval) {
    this.value = value;
    this.interval = interval;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.timeout" id="apidoc.module.rxjs.timeout">module rxjs.timeout</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.timeout.timeout" id="apidoc.element.rxjs.timeout.timeout">
        function <span class="apidocSignatureSpan">rxjs.</span>timeout
        <span class="apidocSignatureSpan">(due, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeout(due, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteTimeout = isDate_1.isDate(due);
    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError()));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.timeoutWith" id="apidoc.module.rxjs.timeoutWith">module rxjs.timeoutWith</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.timeoutWith.timeoutWith" id="apidoc.element.rxjs.timeoutWith.timeoutWith">
        function <span class="apidocSignatureSpan">rxjs.</span>timeoutWith
        <span class="apidocSignatureSpan">(due, withObservable, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    var absoluteTimeout = isDate_1.isDate(due);
    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
    return this.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.timer" id="apidoc.module.rxjs.timer">module rxjs.timer</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.timer.timer" id="apidoc.element.rxjs.timer.timer">
        function <span class="apidocSignatureSpan">rxjs.</span>timer
        <span class="apidocSignatureSpan">(initialDelay, period, scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timer = function (initialDelay, period, scheduler) {
    if (initialDelay === void 0) { initialDelay = 0; }
    return new TimerObservable(initialDelay, period, scheduler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `initialDelay`. The initial delay may be a {@link Date}. By default, this
* operator uses the `async` IScheduler to provide a notion of time, but you
* may pass any IScheduler to it. If `period` is not specified, the output
* Observable emits only one value, `0`. Otherwise, it emits an infinite
* sequence.
*
* @example &lt;caption&gt;Emits ascending numbers, one every second (1000ms), starting after 3 seconds&lt;/caption&gt;
* var numbers = Rx.Observable.<span class="apidocCodeKeywordSpan">timer</span>(3000, 1000);
* numbers.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Emits one number after five seconds&lt;/caption&gt;
* var numbers = Rx.Observable.timer(5000);
* numbers.subscribe(x =&gt; console.log(x));
*
* @see {@link interval}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.timestamp" id="apidoc.module.rxjs.timestamp">module rxjs.timestamp</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.timestamp.timestamp" id="apidoc.element.rxjs.timestamp.timestamp">
        function <span class="apidocSignatureSpan">rxjs.</span>timestamp
        <span class="apidocSignatureSpan">(scheduler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timestamp(scheduler) {
    if (scheduler === void 0) { scheduler = async_1.async; }
    return this.lift(new TimestampOperator(scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rxjs.timestamp.Timestamp" id="apidoc.element.rxjs.timestamp.Timestamp">
        function <span class="apidocSignatureSpan">rxjs.timestamp.</span>Timestamp
        <span class="apidocSignatureSpan">(value, timestamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Timestamp(value, timestamp) {
    this.value = value;
    this.timestamp = timestamp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.toArray" id="apidoc.module.rxjs.toArray">module rxjs.toArray</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.toArray.toArray" id="apidoc.element.rxjs.toArray.toArray">
        function <span class="apidocSignatureSpan">rxjs.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toArray() {
    return this.lift(new ToArrayOperator());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.toPromise" id="apidoc.module.rxjs.toPromise">module rxjs.toPromise</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.toPromise.toPromise" id="apidoc.element.rxjs.toPromise.toPromise">
        function <span class="apidocSignatureSpan">rxjs.</span>toPromise
        <span class="apidocSignatureSpan">(PromiseCtor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toPromise(PromiseCtor) {
    var _this = this;
    if (!PromiseCtor) {
        if (root_1.root.Rx &amp;&amp; root_1.root.Rx.config &amp;&amp; root_1.root.Rx.config.Promise) {
            PromiseCtor = root_1.root.Rx.config.Promise;
        }
        else if (root_1.root.Promise) {
            PromiseCtor = root_1.root.Promise;
        }
    }
    if (!PromiseCtor) {
        throw new Error('no Promise impl found');
    }
    return new PromiseCtor(function (resolve, reject) {
        var value;
        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve
(value); });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Converts an Observable sequence to a ES2015 compliant promise.
*
* @example
* // Using normal ES2015
* let source = Rx.Observable
*   .just(42)
*   .<span class="apidocCodeKeywordSpan">toPromise</span>();
*
* source.then((value) =&gt; console.log('Value: %s', value));
* // =&gt; Value: 42
*
* // Rejected Promise
* // Using normal ES2015
* let source = Rx.Observable
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.toSubscriber" id="apidoc.module.rxjs.toSubscriber">module rxjs.toSubscriber</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.toSubscriber.toSubscriber" id="apidoc.element.rxjs.toSubscriber.toSubscriber">
        function <span class="apidocSignatureSpan">rxjs.</span>toSubscriber
        <span class="apidocSignatureSpan">(nextOrObserver, error, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
        }
    }
    if (!nextOrObserver &amp;&amp; !error &amp;&amp; !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var observable = new Observable();
    observable.source = this;
    observable.operator = operator;
    return observable;
};
Observable.prototype.subscribe = function (observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = toSubscriber_1.<span class="apidocCodeKeywordSpan">toSubscriber</span>(observerOrNext, error, complete);
    if (operator) {
        operator.call(sink, this.source);
    }
    else {
        sink.add(this._trySubscribe(sink));
    }
    if (sink.syncErrorThrowable) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.tryCatch" id="apidoc.module.rxjs.tryCatch">module rxjs.tryCatch</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.tryCatch.tryCatch" id="apidoc.element.rxjs.tryCatch.tryCatch">
        function <span class="apidocSignatureSpan">rxjs.</span>tryCatch
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
while (_parent) {
    _parent.remove(this);
    // if this._parents is null or index &gt;= len,
    // then _parent is set to null, and the loop exits
    _parent = ++index &lt; len &amp;&amp; _parents[index] || null;
}
if (isFunction_1.isFunction(_unsubscribe)) {
    var trial = tryCatch_1.<span class="apidocCodeKeywordSpan">tryCatch</span>(_unsubscribe).call(this);
    if (trial === errorObject_1.errorObject) {
        hasErrors = true;
        errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
            flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
    }
}
if (isArray_1.isArray(_subscriptions)) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.using" id="apidoc.module.rxjs.using">module rxjs.using</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.using.using" id="apidoc.element.rxjs.using.using">
        function <span class="apidocSignatureSpan">rxjs.</span>using
        <span class="apidocSignatureSpan">(resourceFactory, observableFactory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">using = function (resourceFactory, observableFactory) {
    return new UsingObservable(resourceFactory, observableFactory);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.window" id="apidoc.module.rxjs.window">module rxjs.window</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.window.window" id="apidoc.element.rxjs.window.window">
        function <span class="apidocSignatureSpan">rxjs.</span>window
        <span class="apidocSignatureSpan">(windowBoundaries)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function window(windowBoundaries) {
    return this.lift(new WindowOperator(windowBoundaries));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* windows. It emits the current window and opens a new one whenever the
* Observable `windowBoundaries` emits an item. Because each window is an
* Observable, the output is a higher-order Observable.
*
* @example &lt;caption&gt;In every window of 1 second each, emit at most 2 click events&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var interval = Rx.Observable.interval(1000);
* var result = clicks.<span class="apidocCodeKeywordSpan">window</span>(interval)
*   .map(win =&gt; win.take(2)) // each window has at most 2 emissions
*   .mergeAll(); // flatten the Observable-of-Observables
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link windowCount}
* @see {@link windowTime}
* @see {@link windowToggle}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.windowCount" id="apidoc.module.rxjs.windowCount">module rxjs.windowCount</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.windowCount.windowCount" id="apidoc.element.rxjs.windowCount.windowCount">
        function <span class="apidocSignatureSpan">rxjs.</span>windowCount
        <span class="apidocSignatureSpan">(windowSize, startWindowEvery)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) { startWindowEvery = 0; }
    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the current window and propagates the notification from the source
* Observable. If `startWindowEvery` is not provided, then new windows are
* started immediately at the start of the source and when each window completes
* with size `windowSize`.
*
* @example &lt;caption&gt;Ignore every 3rd click event, starting from the first one&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.<span class="apidocCodeKeywordSpan">windowCount</span>(3)
*   .map(win =&gt; win.skip(1)) // skip first of every 3 clicks
*   .mergeAll(); // flatten the Observable-of-Observables
* result.subscribe(x =&gt; console.log(x));
*
* @example &lt;caption&gt;Ignore every 3rd click event, starting from the third one&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks.windowCount(2, 3)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.windowTime" id="apidoc.module.rxjs.windowTime">module rxjs.windowTime</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.windowTime.windowTime" id="apidoc.element.rxjs.windowTime.windowTime">
        function <span class="apidocSignatureSpan">rxjs.</span>windowTime
        <span class="apidocSignatureSpan">(windowTimeSpan)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function windowTime(windowTimeSpan) {
    var scheduler = async_1.async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler_1.isScheduler(arguments[3])) {
        scheduler = arguments[3];
    }
    if (isScheduler_1.isScheduler(arguments[2])) {
        scheduler = arguments[2];
    }
    else if (isNumeric_1.isNumeric(arguments[2])) {
        maxWindowSize = arguments[2];
    }
    if (isScheduler_1.isScheduler(arguments[1])) {
        scheduler = arguments[1];
    }
    else if (isNumeric_1.isNumeric(arguments[1])) {
        windowCreationInterval = arguments[1];
    }
    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.windowToggle" id="apidoc.module.rxjs.windowToggle">module rxjs.windowToggle</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.windowToggle.windowToggle" id="apidoc.element.rxjs.windowToggle.windowToggle">
        function <span class="apidocSignatureSpan">rxjs.</span>windowToggle
        <span class="apidocSignatureSpan">(openings, closingSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function windowToggle(openings, closingSelector) {
    return this.lift(new WindowToggleOperator(openings, closingSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* emitted by the source Observable between the time when the `openings`
* Observable emits an item and when the Observable returned by
* `closingSelector` emits an item.
*
* @example &lt;caption&gt;Every other second, emit the click events from the next 500ms&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var openings = Rx.Observable.interval(1000);
* var result = clicks.<span class="apidocCodeKeywordSpan">windowToggle</span>(openings, i =&gt;
*   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
* ).mergeAll();
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link window}
* @see {@link windowCount}
* @see {@link windowTime}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.windowWhen" id="apidoc.module.rxjs.windowWhen">module rxjs.windowWhen</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.windowWhen.windowWhen" id="apidoc.element.rxjs.windowWhen.windowWhen">
        function <span class="apidocSignatureSpan">rxjs.</span>windowWhen
        <span class="apidocSignatureSpan">(closingSelector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function windowWhen(closingSelector) {
    return this.lift(new WindowOperator(closingSelector));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* It emits the current window and opens a new one whenever the Observable
* produced by the specified `closingSelector` function emits an item. The first
* window is opened immediately when subscribing to the output Observable.
*
* @example &lt;caption&gt;Emit only the first two clicks events in every window of [1-5] random seconds&lt;/caption&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var result = clicks
*   .<span class="apidocCodeKeywordSpan">windowWhen</span>(() =&gt; Rx.Observable.interval(1000 + Math.random() * 4000))
*   .map(win =&gt; win.take(2)) // each window has at most 2 emissions
*   .mergeAll(); // flatten the Observable-of-Observables
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link window}
* @see {@link windowCount}
* @see {@link windowTime}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.withLatestFrom" id="apidoc.module.rxjs.withLatestFrom">module rxjs.withLatestFrom</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.withLatestFrom.withLatestFrom" id="apidoc.element.rxjs.withLatestFrom.withLatestFrom">
        function <span class="apidocSignatureSpan">rxjs.</span>withLatestFrom
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var project;
    if (typeof args[args.length - 1] === 'function') {
        project = args.pop();
    }
    var observables = args;
    return this.lift(new WithLatestFromOperator(observables, project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the source emits a value, optionally using a `project` function to determine
* the value to be emitted on the output Observable. All input Observables must
* emit at least one value before the output Observable will emit a value.
*
* @example &lt;caption&gt;On every click event, emit an array with the latest timer event plus the click event&lt;/caption
&gt;
* var clicks = Rx.Observable.fromEvent(document, 'click');
* var timer = Rx.Observable.interval(1000);
* var result = clicks.<span class="apidocCodeKeywordSpan">withLatestFrom</span>(timer);
* result.subscribe(x =&gt; console.log(x));
*
* @see {@link combineLatest}
*
* @param {ObservableInput} other An input Observable to combine with the source
* Observable. More than one input Observables may be given as argument.
* @param {Function} [project] Projection function for combining values
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.zip" id="apidoc.module.rxjs.zip">module rxjs.zip</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.zip.zip" id="apidoc.element.rxjs.zip.zip">
        function <span class="apidocSignatureSpan">rxjs.</span>zip
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zipStatic() {
    var observables = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rxjs.zipAll" id="apidoc.module.rxjs.zipAll">module rxjs.zipAll</a></h1>


    <h2>
        <a href="#apidoc.element.rxjs.zipAll.zipAll" id="apidoc.element.rxjs.zipAll.zipAll">
        function <span class="apidocSignatureSpan">rxjs.</span>zipAll
        <span class="apidocSignatureSpan">(project)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zipAll(project) {
    return this.lift(new zip_1.ZipOperator(project));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>